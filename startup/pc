# import logging
# import caproto
# handler = logging.FileHandler('pilatus-trigger-log.txt')     
# from caproto._log import LogFormatter, color_log_format, log_date_format
# handler.setFormatter(                                                                                                                                                               
#     LogFormatter(color_log_format, datefmt=log_date_format))     
# caproto_log = logging.getLogger('caproto')                                                                                                                                                    
# caproto_log.handlers.clear()
# caproto_log.addHandler(handler)       
# logging.getLogger('caproto.ch').setLevel('DEBUG')
import nslsii
nslsii.configure_base(get_ipython().user_ns, 'cms', publish_documents_with_kafka=True)

from bluesky.magics import BlueskyMagics
from bluesky.preprocessors import pchain

# At the end of every run, verify that files were saved and
# print a confirmation message.
from bluesky.callbacks.broker import verify_files_saved
# RE.subscribe(post_run(verify_files_saved), 'stop')

from pyOlog.ophyd_tools import *

# Uncomment the following lines to turn on verbose messages for
# debugging.
# import logging
# ophyd.logger.setLevel(logging.DEBUG)
# logging.basicConfig(level=logging.DEBUG)

# Add a callback that prints scan IDs at the start of each scan.
# def print_scan_ids(name, start_doc):
#     print("Transient Scan ID: {0} @ {1}".format(start_doc['scan_id'],time.strftime("%Y/%m/%d %H:%M:%S")))
#     print("Persistent Unique Scan ID: '{0}'".format(start_doc['uid']))
# 
# RE.subscribe(print_scan_ids, 'start')

# - HACK #1 -  patch EpicsSignal.get to retry when timeouts happen stolen from HXN
import ophyd

def _epicssignal_get(self, *, as_string=None, connection_timeout=1.0, **kwargs):
    '''Get the readback value through an explicit call to EPICS
    Parameters
    ----------
    count : int, optional
        Explicitly limit count for array data
    as_string : bool, optional
        Get a string representation of the value, defaults to as_string
        from this signal, optional
    as_numpy : bool
        Use numpy array as the return type for array data.
    timeout : float, optional
        maximum time to wait for value to be received.
        (default = 0.5 + log10(count) seconds)
    use_monitor : bool, optional
        to use value from latest monitor callback or to make an
        explicit CA call for the value. (default: True)
    connection_timeout : float, optional
        If not already connected, allow up to `connection_timeout` seconds
        for the connection to complete.
    '''
    if as_string is None:
        as_string = self._string

    with self._metadata_lock:
        if not self._read_pv.connected:
            if not self._read_pv.wait_for_connection(connection_timeout):
                raise TimeoutError('Failed to connect to %s' %
                                   self._read_pv.pvname)

        ret = None
        attempts = 0
        max_attempts = 4
        while ret is None and attempts < max_attempts:
            attempts += 1
            ret = self._read_pv.get(as_string=as_string, **kwargs)
            if ret is None:
                print(f'*** PV GET TIMED OUT {self._read_pv.pvname} *** attempt #{attempts}/{max_attempts}')
        if ret is None:
            print(f'*** PV GET TIMED OUT {self._read_pv.pvname} *** return `None` as value :(')
            # TODO we really want to raise TimeoutError here, but that may cause more
            # issues in the codebase than we have the time to fix...
            # If this causes issues, remove it to keep the old functionality...
            raise TimeoutError('Failed to get %s after %d attempts' %
                               (self._read_pv.pvname, attempts))
        if attempts > 1:
            print(f'*** PV GET succeeded {self._read_pv.pvname} on attempt #{attempts}')

    if as_string:
        return ophyd.signal.waveform_to_string(ret)

    return ret


from ophyd import EpicsSignal
from ophyd import EpicsSignalRO
# from ophyd import EpicsSignalBase

from ophyd.areadetector import EpicsSignalWithRBV

# Increase the timeout for EpicsSignal.get()
# This beamline was occasionally getting ReadTimeoutErrors
#EpicsSignal.set_defaults(timeout=10)
#EpicsSignalRO.set_defaults(timeout=10)
ophyd.signal.EpicsSignalBase.set_defaults(timeout=15)


# We have commented this because we would like to identify the PVs that are causing problems.
# Then the controls group can investigate why it is not working as expected.
# Increasing the get() timeout argument is the prefered way to work around this problem.
#EpicsSignal.get = _epicssignal_get
#EpicsSignalRO.get = _epicssignal_get
#EpicsSignalWithRBV.get = _epicssignal_get

from pathlib import Path

import appdirs


try:
    from bluesky.utils import PersistentDict
except ImportError:
    import msgpack
    import msgpack_numpy
    import zict

    class PersistentDict(zict.Func):
        """
        A MutableMapping which syncs it contents to disk.
        The contents are stored as msgpack-serialized files, with one file per item
        in the mapping.
        Note that when an item is *mutated* it is not immediately synced:
        >>> d['sample'] = {"color": "red"}  # immediately synced
        >>> d['sample']['shape'] = 'bar'  # not immediately synced
        but that the full contents are synced to disk when the PersistentDict
        instance is garbage collected.
        """
        def __init__(self, directory):
            self._directory = directory
            self._file = zict.File(directory)
            self._cache = {}
            super().__init__(self._dump, self._load, self._file)
            self.reload()

            # Similar to flush() or _do_update(), but without reference to self
            # to avoid circular reference preventing collection.
            # NOTE: This still doesn't guarantee call on delete or gc.collect()!
            #       Explicitly call flush() if immediate write to disk required.
            def finalize(zfile, cache, dump):
                zfile.update((k, dump(v)) for k, v in cache.items())

            import weakref
            self._finalizer = weakref.finalize(
                self, finalize, self._file, self._cache, PersistentDict._dump)

        @property
        def directory(self):
            return self._directory

        def __setitem__(self, key, value):
            self._cache[key] = value
            super().__setitem__(key, value)

        def __getitem__(self, key):
            return self._cache[key]

        def __delitem__(self, key):
            del self._cache[key]
            super().__delitem__(key)

        def __repr__(self):
            return f"<{self.__class__.__name__} {dict(self)!r}>"

        @staticmethod
        def _dump(obj):
            "Encode as msgpack using numpy-aware encoder."
            # See https://github.com/msgpack/msgpack-python#string-and-binary-type
            # for more on use_bin_type.
            return msgpack.packb(
                obj,
                default=msgpack_numpy.encode,
                use_bin_type=True)

        @staticmethod
        def _load(file):
            return msgpack.unpackb(
                file,
                object_hook=msgpack_numpy.decode,
                raw=False)

        def flush(self):
            """Force a write of the current state to disk"""
            for k, v in self.items():
                super().__setitem__(k, v)

        def reload(self):
            """Force a reload from disk, overwriting current cache"""
            self._cache = dict(super().items())

runengine_metadata_dir = appdirs.user_data_dir(appname="bluesky") / Path("runengine-metadata")

# PersistentDict will create the directory if it does not exist
RE.md = PersistentDict(runengine_metadata_dir)

print('a new version of bsui')
print('sth is happening')from ophyd.areadetector.base import (ADComponent as C, ad_group,
                                     EpicsSignalWithRBV as SignalWithRBV)
from ophyd.areadetector.plugins import PluginBase
from ophyd.device import DynamicDeviceComponent as DDC, Staged
from ophyd.signal import (EpicsSignalRO, EpicsSignal)


try:
    from nslsii.ad33 import StatsPluginV33
except ImportError:
    class StatsPluginV33(PluginBase):
        """This supports changes to time series PV names in AD 3-3 Due to https://github.com/areaDetector/ADCore/pull/333"""
        _default_suffix = 'Stats1:'
        _suffix_re = 'Stats\d:'
        _html_docs = ['NDPluginStats.html']
        _plugin_type = 'NDPluginStats'
        _default_configuration_attrs = (PluginBase._default_configuration_attrs + (
            'centroid_threshold', 'compute_centroid', 'compute_histogram',
            'compute_profiles', 'compute_statistics', 'bgd_width',
            'hist_size', 'hist_min', 'hist_max', 'ts_num_points', 'profile_size',
            'profile_cursor')
        )
        bgd_width = C(SignalWithRBV, 'BgdWidth')
        centroid_threshold = C(SignalWithRBV, 'CentroidThreshold')
        centroid = DDC(ad_group(EpicsSignalRO,
                                (('x', 'CentroidX_RBV'),
                                 ('y', 'CentroidY_RBV'))),
                       doc='The centroid XY',
                       default_read_attrs=('x', 'y'))
        compute_centroid = C(SignalWithRBV, 'ComputeCentroid', string=True)
        compute_histogram = C(SignalWithRBV, 'ComputeHistogram', string=True)
        compute_profiles = C(SignalWithRBV, 'ComputeProfiles', string=True)
        compute_statistics = C(SignalWithRBV, 'ComputeStatistics', string=True)
        cursor = DDC(ad_group(SignalWithRBV,
                              (('x', 'CursorX'),
                               ('y', 'CursorY'))),
                     doc='The cursor XY',
                     default_read_attrs=('x', 'y'))
        hist_entropy = C(EpicsSignalRO, 'HistEntropy_RBV')
        hist_max = C(SignalWithRBV, 'HistMax')
        hist_min = C(SignalWithRBV, 'HistMin')
        hist_size = C(SignalWithRBV, 'HistSize')
        histogram = C(EpicsSignalRO, 'Histogram_RBV')
        max_size = DDC(ad_group(EpicsSignal,
                                (('x', 'MaxSizeX'),
                                 ('y', 'MaxSizeY'))),
                       doc='The maximum size in XY',
                       default_read_attrs=('x', 'y'))
        max_value = C(EpicsSignalRO, 'MaxValue_RBV')
        max_xy = DDC(ad_group(EpicsSignalRO,
                              (('x', 'MaxX_RBV'),
                               ('y', 'MaxY_RBV'))),
                     doc='Maximum in XY',
                     default_read_attrs=('x', 'y'))
        mean_value = C(EpicsSignalRO, 'MeanValue_RBV')
        min_value = C(EpicsSignalRO, 'MinValue_RBV')
        min_xy = DDC(ad_group(EpicsSignalRO,
                              (('x', 'MinX_RBV'),
                               ('y', 'MinY_RBV'))),
                     doc='Minimum in XY',
                     default_read_attrs=('x', 'y'))
        net = C(EpicsSignalRO, 'Net_RBV')
        profile_average = DDC(ad_group(EpicsSignalRO,
                                       (('x', 'ProfileAverageX_RBV'),
                                        ('y', 'ProfileAverageY_RBV'))),
                              doc='Profile average in XY',
                              default_read_attrs=('x', 'y'))
        profile_centroid = DDC(ad_group(EpicsSignalRO,
                                        (('x', 'ProfileCentroidX_RBV'),
                                         ('y', 'ProfileCentroidY_RBV'))),
                               doc='Profile centroid in XY',
                               default_read_attrs=('x', 'y'))
        profile_cursor = DDC(ad_group(EpicsSignalRO,
                                      (('x', 'ProfileCursorX_RBV'),
                                       ('y', 'ProfileCursorY_RBV'))),
                             doc='Profile cursor in XY',
                             default_read_attrs=('x', 'y'))
        profile_size = DDC(ad_group(EpicsSignalRO,
                                    (('x', 'ProfileSizeX_RBV'),
                                     ('y', 'ProfileSizeY_RBV'))),
                           doc='Profile size in XY',
                           default_read_attrs=('x', 'y'))
        profile_threshold = DDC(ad_group(EpicsSignalRO,
                                         (('x', 'ProfileThresholdX_RBV'),
                                          ('y', 'ProfileThresholdY_RBV'))),
                                doc='Profile threshold in XY',
                                default_read_attrs=('x', 'y'))
        set_xhopr = C(EpicsSignal, 'SetXHOPR')
        set_yhopr = C(EpicsSignal, 'SetYHOPR')
        sigma_xy = C(EpicsSignalRO, 'SigmaXY_RBV')
        sigma_x = C(EpicsSignalRO, 'SigmaX_RBV')
        sigma_y = C(EpicsSignalRO, 'SigmaY_RBV')
        sigma = C(EpicsSignalRO, 'Sigma_RBV')
        ts_acquiring = C(EpicsSignal, 'TS:TSAcquiring')
        ts_centroid = DDC(ad_group(EpicsSignal,
                                   (('x', 'TS:TSCentroidX'),
                                    ('y', 'TS:TSCentroidY'))),
                          doc='Time series centroid in XY',
                          default_read_attrs=('x', 'y'))
        # ts_control = C(EpicsSignal, 'TS:TSControl', string=True)
        ts_current_point = C(EpicsSignal, 'TS:TSCurrentPoint')
        ts_max_value = C(EpicsSignal, 'TS:TSMaxValue')
        ts_max = DDC(ad_group(EpicsSignal,
                              (('x', 'TS:TSMaxX'),
                               ('y', 'TS:TSMaxY'))),
                     doc='Time series maximum in XY',
                     default_read_attrs=('x', 'y'))
        ts_mean_value = C(EpicsSignal, 'TS:TSMeanValue')
        ts_min_value = C(EpicsSignal, 'TS:TSMinValue')
        ts_min = DDC(ad_group(EpicsSignal,
                              (('x', 'TS:TSMinX'),
                               ('y', 'TS:TSMinY'))),
                     doc='Time series minimum in XY',
                     default_read_attrs=('x', 'y'))
        ts_net = C(EpicsSignal, 'TS:TSNet')
        ts_num_points = C(EpicsSignal, 'TS:TSNumPoints')
        ts_read = C(EpicsSignal, 'TS:TSRead')
        ts_sigma = C(EpicsSignal, 'TS:TSSigma')
        ts_sigma_x = C(EpicsSignal, 'TS:TSSigmaX')
        ts_sigma_xy = C(EpicsSignal, 'TS:TSSigmaXY')
        ts_sigma_y = C(EpicsSignal, 'TS:TSSigmaY')
        ts_total = C(EpicsSignal, 'TS:TSTotal')
        total = C(EpicsSignalRO, 'Total_RBV')
from ophyd import EpicsMotor, Device, Component as Cpt

#slity = EpicsMotor('XF:11BMA-OP{Slt:0-Ax:T}Mtr', name='slity')


#class Slits(Device):
#    top = Cpt(EpicsMotor, '-Ax:T}Mtr')
#    bottom = Cpt(EpicsMotor, '-Ax:B}Mtr')

beamline_stage = 'default'
# beamline_stage = 'open_MAXS'
# beamline_stage = 'BigHuber'


#slits = Slits('XF:11BMA-OP{Slt:0', name='slits') 

###################################################################################
#above as found on 19 Oct 2016, then commented out
#below added by MF in Oct 2016
###################################################################################


########## motor classes ##########
class MotorCenterAndGap(Device):
    "Center and gap using Epics Motor records"
    xc = Cpt(EpicsMotor, '-Ax:XC}Mtr')
    yc = Cpt(EpicsMotor, '-Ax:YC}Mtr')
    xg = Cpt(EpicsMotor, '-Ax:XG}Mtr')
    yg = Cpt(EpicsMotor, '-Ax:YG}Mtr')

class Blades(Device):
    "Actual T/B/O/I and virtual center/gap using Epics Motor records"
    tp = Cpt(EpicsMotor, '-Ax:T}Mtr')
    bt = Cpt(EpicsMotor, '-Ax:B}Mtr')
    ob = Cpt(EpicsMotor, '-Ax:O}Mtr')
    ib = Cpt(EpicsMotor, '-Ax:I}Mtr')
    xc = Cpt(EpicsMotor, '-Ax:XCtr}Mtr')
    yc = Cpt(EpicsMotor, '-Ax:YCtr}Mtr')
    xg = Cpt(EpicsMotor, '-Ax:XGap}Mtr')
    yg = Cpt(EpicsMotor, '-Ax:YGap}Mtr')

class Filter(Device):
    "Attenuator filters"
    sts = Cpt(EpicsSignal, 'Pos-Sts')
    in_cmd = Cpt(EpicsSignal, 'In-Cmd')
    out_cmd = Cpt(EpicsSignal, 'Out-Cmd')



#class MotorSlits(Blades, MotorCenterAndGap):
#    "combine t b i o and xc yc xg yg"
#    pass

#class VirtualMotorSlits(Blades, VirtualMotorCenterAndGap):
#    "combine t b i o and xc yc xg yg"
#    pass


########## FOE motors ##########
## stages for Front End (FE) slits (divergence) (FOE)
# FE_x = EpicsMotor('FE:C11B-OP{Slt:12-Ax:X}t2.C', name='FE_x')
# FE_y = EpicsMotor('FE:C11B-OP{Slt:12-Ax:Y}t2.C', name='FE_y')


## stages for monochromator (FOE)
mono_bragg = EpicsMotor('XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr', name='mono_bragg')
mono_pitch2 = EpicsMotor('XF:11BMA-OP{Mono:DMM-Ax:P2}Mtr', name='mono_pitch2')
mono_roll2 = EpicsMotor('XF:11BMA-OP{Mono:DMM-Ax:R2}Mtr', name='mono_roll2')
mono_perp2 = EpicsMotor('XF:11BMA-OP{Mono:DMM-Ax:Y2}Mtr', name='mono_perp2')


## stages for toroidal mirror (FOE)
mir_usx = EpicsMotor('XF:11BMA-OP{Mir:Tor-Ax:XU}Mtr', name='mir_usx')
mir_dsx = EpicsMotor('XF:11BMA-OP{Mir:Tor-Ax:XD}Mtr', name='mir_dsx')
mir_usy = EpicsMotor('XF:11BMA-OP{Mir:Tor-Ax:YU}Mtr', name='mir_usy')
mir_dsyi = EpicsMotor('XF:11BMA-OP{Mir:Tor-Ax:YDI}Mtr', name='mir_dsyi')
mir_dsyo = EpicsMotor('XF:11BMA-OP{Mir:Tor-Ax:YDO}Mtr', name='mir_dsyo')
mir_bend = EpicsMotor('XF:11BMA-OP{Mir:Tor-Ax:UB}Mtr', name='mir_bend')


########## FOE slits ##########
## FMB Oxford slits -- usage: s0.tp, s0.bt, s0.ob, s0.ib, s0.xc, s0.xg, s0.yc, s0.yg
s0 = Blades('XF:11BMA-OP{Slt:0', name='s0') 	


########## Endstation slits #########		
## jj slits -- usage: s*.xc, s*.xg, s*.yc, s*.yg
s1 = MotorCenterAndGap('XF:11BMB-OP{Slt:1', name='s1')
s2 = MotorCenterAndGap('XF:11BMB-OP{Slt:2', name='s2') 
s3 = MotorCenterAndGap('XF:11BMB-OP{Slt:3', name='s3') 
s4 = MotorCenterAndGap('XF:11BMB-OP{Slt:4', name='s4') 
s5 = MotorCenterAndGap('XF:11BMB-OP{Slt:5', name='s5') 

# attenuators
filters = {f'filter{ifoil}':Filter(f'XF:11BMB-OP{{Fltr:{ifoil}}}', name=f'filter{ifoil}') for ifoil in range(1, 8+1)}
# filters_sts = [fil.sts.get() for fil in filters.values()]
# filters_cmd = [fil.cmd.get() for fil in filters.values()]
# locals().update(filters) 

########## Endstation motors ##########
## stages for Endstation diagnostics
bim3y = EpicsMotor('XF:11BMB-BI{IM:3-Ax:Y}Mtr', name='bim3y')
fs3y = EpicsMotor('XF:11BMB-BI{FS:3-Ax:Y}Mtr', name='fs3y')
bim4y = EpicsMotor('XF:11BMB-BI{IM:4-Ax:Y}Mtr', name='bim4y')
bim5y = EpicsMotor('XF:11BMB-BI{IM:5-Ax:Y}Mtr', name='bim5y')

## stages for sample positioning
#beamline_stage is defined by the current sample stage. 'default' is the regular vacuum chamber
#'open_WAXS' is the alternative stage position with Pilatus300k as the WAXS detector. 
if beamline_stage == 'default':
    smx = EpicsMotor('XF:11BMB-ES{Chm:Smpl-Ax:X}Mtr', name='smx')
    smy = EpicsMotor('XF:11BMB-ES{Chm:Smpl-Ax:Z}Mtr', name='smy')
    sth = EpicsMotor('XF:11BMB-ES{Chm:Smpl-Ax:theta}Mtr', name='sth')
    schi = EpicsMotor('XF:11BMB-ES{Chm:Smpl-Ax:chi}Mtr', name='schi')

elif beamline_stage == 'open_MAXS':
    smx = EpicsMotor('XF:11BMB-ES{Chm:Smpl2-Ax:X}Mtr', name='smx')
    smy = EpicsMotor('XF:11BMB-ES{Chm:Smpl2-Ax:Y}Mtr', name='smy')
    smz = EpicsMotor('XF:11BMB-ES{Chm:Smpl2-Ax:Z}Mtr', name='smz')
    #sth = EpicsMotor('XF:11BMB-ES{SM:2-Ax:theta}Mtr', name='sth')
    #schi = EpicsMotor('XF:11BMB-ES{SM:2-Ax:chi}Mtr', name='schi')
    #swap sth and schi at 082219 by RL
    sth = EpicsMotor('XF:11BMB-ES{SM:2-Ax:theta}Mtr', name='sth')
    schi = EpicsMotor('XF:11BMB-ES{SM:2-Ax:chi}Mtr', name='schi')
    
elif beamline_stage == 'BigHuber':
    # Huber
    smy = EpicsMotor('XF:11BMB-ES{Chm:Smpl3-Ax:Y}Mtr', name='smy')
    sth = EpicsMotor('XF:11BMB-ES{Chm:Smpl3-Ax:theta}Mtr', name='sth')
    schi = EpicsMotor('XF:11BMB-ES{Chm:Smpl3-Ax:chi}Mtr', name='schi')
    
    # Newports
    smx = EpicsMotor('XF:11BMB-ES{PTA:Sample-Ax:X}Mtr', name='smx')
    laserx = EpicsMotor('XF:11BMB-ES{PTA:Laser-Ax:X}Mtr', name='laserx')
    lasery = EpicsMotor('XF:11BMB-ES{PTA:Laser-Ax:Y}Mtr', name='lasery')
    
    
    
smy2 = EpicsMotor('XF:11BMB-ES{Chm:Smpl-Ax:Y}Mtr', name='smy2')
sphi = EpicsMotor('XF:11BMB-ES{Chm:Smpl-Ax:phi}Mtr', name='sphi')
srot = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Srot}Mtr', name='srot')
strans = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Strans}Mtr', name='strans')
strans2 = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Strans2}Mtr', name='strans2')
stilt = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Stilt}Mtr', name='stilt')
stilt2 = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Stilt2}Mtr', name='stilt2')


## stages for on-axis sample camera mirror/lens
camx = EpicsMotor('XF:11BMB-ES{Cam:OnAxis-Ax:X1}Mtr', name='camx')
camy = EpicsMotor('XF:11BMB-ES{Cam:OnAxis-Ax:Y1}Mtr', name='camy')

## stages for off-axis sample camera
cam2x = EpicsMotor('XF:11BMB-ES{Cam:OnAxis-Ax:X2}Mtr', name='cam2x')
cam2z = EpicsMotor('XF:11BMB-ES{Cam:OnAxis-Ax:Y2}Mtr', name='cam2z')

## stages for sample exchanger
armz = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Z}Mtr', name='armz')
armx = EpicsMotor('XF:11BMB-ES{SM:1-Ax:X}Mtr', name='armx')
armphi = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Yaw}Mtr', name='armphi')
army = EpicsMotor('XF:11BMB-ES{SM:1-Ax:Y}Mtr', name='army')
# armr = EpicsMotor('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr', name='armr')

# The SmarAct module is broken. Need to change to a SPARE_M for armr
armr = EpicsMotor('XF:11BMB-ES{Spare:L-Ax:M}Mtr', name='armr')


## stages for detectors
## currently not working. The new pilatus800k is sitting on a stage with manual movement
#DETx = EpicsMotor('XF:11BMB-ES{Det:Stg-Ax:X}Mtr', name='DETx')
#DETy =  EpicsMotor('XF:11BMB-ES{Det:Stg-Ax:Y}Mtr', name='DETy')
#WAXSx = EpicsMotor('XF:11BMB-ES{Det:WAXS-Ax:X}Mtr', name='WAXSx')
WAXSx = EpicsMotor('XF:11BMB-ES{Det:WAXS-Ax:X}Mtr', name='WAXSx')
WAXSy = EpicsMotor('XF:11BMB-ES{Det:WAXS-Ax:Y}Mtr', name='WAXSy')
WAXSz = EpicsMotor('XF:11BMB-ES{Det:WAXS-Ax:Z}Mtr', name='WAXSz')

SAXSx = EpicsMotor('XF:11BMB-ES{Det:SAXS-Ax:X}Mtr', name='SAXSx')
SAXSy = EpicsMotor('XF:11BMB-ES{Det:SAXS-Ax:Y}Mtr', name='SAXSy')

MAXSx = EpicsMotor('XF:11BMB-ES{Det:MAXS-Ax:X}Mtr', name='MAXSx')
MAXSy = EpicsMotor('XF:11BMB-ES{Det:MAXS-Ax:Y}Mtr', name='MAXSy')

## stages for beamstops
bsx = EpicsMotor('XF:11BMB-ES{BS:SAXS-Ax:X}Mtr', name='bsx')
bsy = EpicsMotor('XF:11BMB-ES{BS:SAXS-Ax:Y}Mtr', name='bsy')
bsphi = EpicsMotor('XF:11BMB-ES{BS:SAXS-Ax:phi}Mtr', name='bsphi')

##stage for vacuum gate
gatex = EpicsMotor('XF:11BMB-ES{Chm:Gate-Ax:X}Mtr', name='gatex')

## easy access for stages
def wbs():
    print('bsx = {}'.format(bsx.position))
    print('bsy = {}'.format(bsy.position))
    print('bsphi = {}'.format(bsphi.position))
    
def wsam():
    print('smx = {}'.format(smx.position))
    print('smy = {}'.format(smy.position))
    print('sth = {}'.format(sth.position))

def wWAXS():
    print('WAXSx = {}'.format(WAXSx.position))
    print('WAXSy = {}'.format(WAXSy.position))
    print('WAXSz = {}'.format(WAXSz.position))

def wSAXS():
    print('SAXSx = {}'.format(SAXSx.position))
    print('SAXSy = {}'.format(SAXSy.position))

def wMAXS():
    print('MAXSx = {}'.format(MAXSx.position))
    print('MAXSy = {}'.format(MAXSy.position))
    
def wGONIO():
    print('sort = {}'.format(srot.position))
    print('strans = {}'.format(strans.position))
    print('strans2 = {}'.format(strans2.position))
    print('stilt = {}'.format(stilt.position))
    print('stilt2 = {}'.format(stilt2.position))
    



from math import sin, cos, tan, asin, acos, atan, pi

##### mono utilities #####
hc_over_e = 12.39842
dmm_dsp = 20.1 		## DMM bilayer pitch in [Ang], according to Rigaku metrology report

def getE(q=0):
    '''Returns E(keV) based on the current mono_bragg position (q=1 for quiet)'''
    bragg = (pi/180.)*caget('XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr.RBV')	## in [rad]
    wavelen = 2. * dmm_dsp * sin(bragg)					## in [Ang]
    E = hc_over_e/wavelen
    if q == 0:
        print('E = %.4g keV, Wavelength = %.4g Ang, DMM d-sp = %.4g Ang, Bragg = %.4g rad (%.4g deg)' % (E, wavelen, dmm_dsp, bragg, bragg*180./pi))
    return(E)
 
def moveE(eng):
    '''Moves mono_bragg correspong to the specified E(keV)'''
    wavelen = hc_over_e/eng		        ## in [Ang]
    bragg = asin(wavelen/(2.*dmm_dsp))*180./pi	## in [deg]
    roll2 = -0.02617 - 0.010134*eng		## in [deg], based on linear fitting

    print('mono_bragg will move to %.4g deg' % bragg)
    print('mono_roll2 will move to %.4g deg' % roll2)
    yn = input('Are you sure? (y/n): ')
    if yn == 'y' or yn == 'Y':
        #mov(mono_bragg, bragg)
        #mov(mono_roll2, roll2)
        mono_bragg.move(bragg)
        mono_roll2.move(roll2)
        
        print('mono_bragg and mono_roll2 were moved')
    else:
        print('No move was made')
    getE()

def moveE_force(eng):
    '''Moves mono_bragg correspong to the specified E(keV)'''
    wavelen = hc_over_e/eng		        ## in [Ang]
    bragg = asin(wavelen/(2.*dmm_dsp))*180./pi	## in [deg]
    roll2 = -0.02617 - 0.010134*eng		## in [deg], based on linear fitting
    #mov(mono_bragg, bragg)
    #mov(mono_roll2, roll2)
    mono_bragg.move(bragg)
    mono_roll2.move(roll2)    

##### toroidal mirror utilities #####
mir_us_to_ds = 1.0669		## kinematic support pivot_to_pivot distance along Z in [m]
mir_ib_to_ob = 0.6096		## kinematic support pivot_to_pivot distance along X in [m]

def movr_mir_pitch(del_mrad):
    '''Moves the pitch of the mirror support by specified angle in [mrad]'''
    del_mm = 0.5 * mir_us_to_ds * del_mrad
    #movr(mir_usy,-del_mm)
    #movr(mir_dsyi,del_mm)
    #movr(mir_dsyo,del_mm)
    mir_usy.move(mir_usy.user_readback.value + -del_mm)
    mir_dsyi.move(mir_dsyi.user_readback.value + del_mm)
    mir_dsyo.move(mir_usyo.user_readback.value + del_mm)

def movr_mir_roll(del_mrad):
    '''Moves the roll of the mirror support by specified angle in [mrad]'''
    del_mm = 0.5 * mir_ib_to_ob * del_mrad
    #movr(mir_dsyi,-del_mm)
    #movr(mir_dsyo,del_mm)
    mir_dsyi.move(mir_dsyi.user_readback.value + -del_mm)
    mir_dsyo.move(mir_usyo.user_readback.value + del_mm)

def movr_mir_yaw(del_mrad):
    '''Moves the yaw of the mirror support by specified angle in [mrad]'''
    del_mm = 0.5 * mir_us_to_ds * del_mrad
    #movr(mir_usx,-del_mm)
    #movr(mir_dsx,del_mm)
    mir_usx.move(mir_usx.user_readback.value + -del_mm)
    mir_dsx.move(mir_dsx.user_readback.value + del_mm)


def movr_mir_y(del_mm):
    '''Moves the mirror support vertically by specified distance in [mm]'''
    #movr(mir_usy,del_mm)
    #movr(mir_dsyi,del_mm)
    #movr(mir_dsyo,del_mm)
    mir_usy.move(mir_usy.user_readback.value + del_mm)
    mir_dsyi.move(mir_dsyi.user_readback.value + del_mm)
    mir_dsyo.move(mir_usyo.user_readback.value + del_mm)


def movr_mir_x(del_mm):
    '''Moves the mirror support horizontally, normal to beam, by specified distance in [mm]'''
    #movr(mir_usx,del_mm)
    #movr(mir_dsx,del_mm)
    mir_usx.move(mir_usx.user_readback.value + del_mm)
    mir_dsx.move(mir_dsx.user_readback.value + del_mm)

def ave_mir_y():
    '''Returns the average height of the toroidal mirror in [mm] '''
    usy = caget('XF:11BMA-OP{Mir:Tor-Ax:YU}Mtr.RBV')
    dsyi = caget('XF:11BMA-OP{Mir:Tor-Ax:YDI}Mtr.RBV')
    dsyo = caget('XF:11BMA-OP{Mir:Tor-Ax:YDO}Mtr.RBV')
    ave_y = 0.5 * (usy + 0.5 * (dsyi + dsyo))
    print('Average mirror support height = %.4f mm relative to nominal zero height (1400 mm)' % ave_y)
    return(ave_y)



##### Experimental shutters #####
#updated by RL, 20210901
# These shutters are controlled by sending a TTL pulse via Ecat controller. 

trigger_new_pv = EpicsSignal('XF:11BM-ES{Shutter}')
shutter_sts1_pv = EpicsSignal('XF:11BM-ES{Psh_blade1}Pos')
shutter_sts2_pv = EpicsSignal('XF:11BM-ES{Psh_blade2}Pos')

def shutter_on(verbosity=3):
    # ii = 0
    # yield from bps.mv(trigger_new_pv, 1)
    # time.sleep(0.1)
    while shutter_state(verbosity=0) != 1:
        yield from bps.mv(trigger_new_pv, 1)
        time.sleep(0.01)
        # ii += 1

    # print(ii)
    if verbosity>=3:
        shutter_state(verbosity=verbosity)

def shutter_off(verbosity=3):
    while shutter_state(verbosity=0) != 0:
        yield from bps.mv(trigger_new_pv, 0)
        time.sleep(0.01)
        
    if verbosity>=3:
        shutter_state(verbosity=verbosity)

def shutter_state(verbosity=3):
    if shutter_sts1_pv.get()==1 & shutter_sts2_pv.get()==1:
        status = 1
        if verbosity>=3:
            print('Shutter is OPEN.')
    else:
        status = 0
        if verbosity>=3:
            print('Shutter is CLOSED.')


    return status

# old control, abandoned in 2021C3
# These shutters are controlled by sending a 5V pulse via QEM output on the Delta Tau controller MC06 
# (the same unit that controls slits S5). Both the opening and closing of the shutter are triggered 
# by the rise of the pulse. 
#
# Note: 
# - PV for the QEM output on MC06 is: 
#	XF:11BMB-CT{MC:06}Asyn.AOUT
# - This PV is located under Slit 5/Asyn --> asynRecord/More... --> asynOctet interface I/O --> ASCII 
# - 'M112=1' sets the state to high
# - 'M112=0' sets the state to low
# - 'M111=1' launches the change in state
# - A sleep time of ~2 ms between successive caput commands is needed to get proper response; 1 ms is too short
#####

#global xshutter_state
xshutter_state=0		## TODO: read the shutter state and set this accordingly

## Open shutter 
def xshutter_trigger():
    sleep_time = 0.005 
    caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M112=1')
    sleep(sleep_time)
    caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M111=1')
    sleep(sleep_time)
    caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M112=0')
    sleep(sleep_time)
    caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M111=1')

trigger_pv = EpicsSignal('XF:11BMB-CT{MC:06}Asyn.AOUT')
# shutter_sts1_pv = EpicsSignal('XF:11BMB-OP{PSh:2}Pos:1-Sts')
# shutter_sts2_pv = EpicsSignal('XF:11BMB-OP{PSh:2}Pos:2-Sts')


def xshutter_trigger_RE(verbosity=3):
    yield from bps.mv(trigger_pv, 'M112=1')
    yield from bps.mv(trigger_pv, 'M111=1')
    yield from bps.mv(trigger_pv, 'M112=0')
    yield from bps.mv(trigger_pv, 'M111=1')
    if verbosity>=3:
        value = yield from bps.read(shutter_sts_pv.read())
        print(value[shutter_sts_pv.name]['value'])

def xshutter(inout,q=0):
    global xshutter_state

    if inout=='o' or inout=='open' or inout==1:
        if xshutter_state==0:
            xshutter_trigger()   
            xshutter_state = 1
            if q==0:
                print('Experimental shutter opened')
                return(xshutter_state)
        elif xshutter_state==1:
            print('Experimental shutter is already open; no changes made')
        else:
            print('xshutter_state is neither 0 nor 1; no changes made')

    if inout=='c' or inout=='close' or inout==0:
        if xshutter_state==1:
            xshutter_trigger()   
            xshutter_state = 0
            if q==0:
                print('Experimental shutter closed')
                return(xshutter_state)
        elif xshutter_state==0:
            print('Experimental shutter is already closed; no changes made')
        else:
            print('xshutter_state is neither 0 nor 1; no changes made')

#import time as ttime  # tea time
#from datetime import datetime
from ophyd import (ProsilicaDetector, SingleTrigger,
                   TIFFPlugin, ImagePlugin, DetectorBase,
                   HDF5Plugin, AreaDetector, EpicsSignal, EpicsSignalRO,
                   ROIPlugin, TransformPlugin, ProcessPlugin, PilatusDetector,
                   ProsilicaDetectorCam, PilatusDetectorCam, StatsPlugin)
from ophyd.areadetector.cam import AreaDetectorCam
from ophyd.areadetector.base import ADComponent, EpicsSignalWithRBV
from ophyd.areadetector.filestore_mixins import FileStoreTIFFIterativeWrite
from ophyd import Component as Cpt, Signal
from ophyd.utils import set_and_wait
from nslsii.ad33 import SingleTriggerV33,  StatsPluginV33
#import filestore.api as fs


#class Elm(SingleTrigger, DetectorBase):
 #   pass

Pilatus2M_on = True
Pilatus300_on = False
#ONLY 1 Pilatus800 will be turned on at the same time. changed by RL, 20210831
#
beamline_stage = 'default'
# beamline_stage = 'open_MAXS'
if beamline_stage == 'open_MAXS' or beamline_stage == 'BigHuber':
    Pilatus800_on = False
    Pilatus800_2_on = True
elif beamline_stage == 'default':
    Pilatus800_on = True
    Pilatus800_2_on = False

# Pilatus800_on = True
# # Pilatus800_2_on = False
Pilatus800_2_on = True

class TIFFPluginWithFileStore(TIFFPlugin, FileStoreTIFFIterativeWrite):
    pass

class ProsilicaDetectorCamV33(ProsilicaDetectorCam):
    '''This is used to update the standard prosilica to AD33.
    '''
    wait_for_plugins = Cpt(EpicsSignal, 'WaitForPlugins',
                           string=True, kind='config')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.stage_sigs['wait_for_plugins'] = 'Yes'

    def ensure_nonblocking(self):
        self.stage_sigs['wait_for_plugins'] = 'Yes'
        for c in self.parent.component_names:
            cpt = getattr(self.parent, c)
            if cpt is self:
                continue
            if hasattr(cpt, 'ensure_nonblocking'):
                cpt.ensure_nonblocking()

# class Pilatus2M(SingleTrigger, PilatusDetector):
#     image = Cpt(ImagePlugin, 'image1:')
#     stats1 = Cpt(StatsPlugin, 'Stats1:')
#     stats2 = Cpt(StatsPlugin, 'Stats2:')
#     stats3 = Cpt(StatsPlugin, 'Stats3:')
#     stats4 = Cpt(StatsPlugin, 'Stats4:')
#     stats5 = Cpt(StatsPlugin, 'Stats5:')
#     roi1 = Cpt(ROIPlugin, 'ROI1:')
#     roi2 = Cpt(ROIPlugin, 'ROI2:')
#     roi3 = Cpt(ROIPlugin, 'ROI3:')
#     roi4 = Cpt(ROIPlugin, 'ROI4:')
#     proc1 = Cpt(ProcessPlugin, 'Proc1:')

#     tiff = Cpt(TIFFPluginWithFileStore,
#                suffix='TIFF1:',
#             #    write_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus2M/%Y/%m/%d/',
#                write_path_template='/nsls2/xf11bm/Pilatus2M/%Y/%m/%d/',
#                root='/nsls2/xf11bm')

#     def setExposureTime(self, exposure_time, verbosity=3):
#         caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime', exposure_time)
#         caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquirePeriod', exposure_time+0.1)


class StandardProsilica(SingleTrigger, ProsilicaDetector):
    # tiff = Cpt(TIFFPluginWithFileStore,
    #           suffix='TIFF1:',
    #           write_path_template='/XF11ID/data/')
    image = Cpt(ImagePlugin, 'image1:')
    stats1 = Cpt(StatsPluginV33, 'Stats1:')
    stats2 = Cpt(StatsPluginV33, 'Stats2:')
    stats3 = Cpt(StatsPluginV33, 'Stats3:')
    stats4 = Cpt(StatsPluginV33, 'Stats4:')
    stats5 = Cpt(StatsPluginV33, 'Stats5:')
    trans1 = Cpt(TransformPlugin, 'Trans1:')
    roi1 = Cpt(ROIPlugin, 'ROI1:')
    roi2 = Cpt(ROIPlugin, 'ROI2:')
    roi3 = Cpt(ROIPlugin, 'ROI3:')
    roi4 = Cpt(ROIPlugin, 'ROI4:')
    proc1 = Cpt(ProcessPlugin, 'Proc1:')



class StandardProsilicaV33(SingleTriggerV33, ProsilicaDetector):
    # tiff = Cpt(TIFFPluginWithFileStore,
    #           suffix='TIFF1:',
    #           write_path_template='/XF11ID/data/')
    cam = Cpt(ProsilicaDetectorCamV33, 'cam1:')
    image = Cpt(ImagePlugin, 'image1:')
    stats1 = Cpt(StatsPluginV33, 'Stats1:')
    stats2 = Cpt(StatsPluginV33, 'Stats2:')
    stats3 = Cpt(StatsPluginV33, 'Stats3:')
    stats4 = Cpt(StatsPluginV33, 'Stats4:')
    stats5 = Cpt(StatsPluginV33, 'Stats5:')
    trans1 = Cpt(TransformPlugin, 'Trans1:')
    roi1 = Cpt(ROIPlugin, 'ROI1:')
    roi2 = Cpt(ROIPlugin, 'ROI2:')
    roi3 = Cpt(ROIPlugin, 'ROI3:')
    roi4 = Cpt(ROIPlugin, 'ROI4:')
    proc1 = Cpt(ProcessPlugin, 'Proc1:')

class PilatusDetectorCamV33(PilatusDetectorCam):
    '''This is used to update the standard prosilica to AD33.
    '''
    wait_for_plugins = Cpt(EpicsSignal, 'WaitForPlugins',
                           string=True, kind='config')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.stage_sigs['wait_for_plugins'] = 'Yes'

    def ensure_nonblocking(self):
        self.stage_sigs['wait_for_plugins'] = 'Yes'
        for c in self.parent.component_names:
            cpt = getattr(self.parent, c)
            if cpt is self:
                continue
            if hasattr(cpt, 'ensure_nonblocking'):
                cpt.ensure_nonblocking()



# class Pilatus(SingleTrigger, PilatusDetector):
#     image = Cpt(ImagePlugin, 'image1:')
#     stats1 = Cpt(StatsPluginV33, 'Stats1:')
#     stats2 = Cpt(StatsPluginV33, 'Stats2:')
#     stats3 = Cpt(StatsPluginV33, 'Stats3:')
#     stats4 = Cpt(StatsPluginV33, 'Stats4:')
#     stats5 = Cpt(StatsPluginV33, 'Stats5:')
#     roi1 = Cpt(ROIPlugin, 'ROI1:')
#     roi2 = Cpt(ROIPlugin, 'ROI2:')
#     roi3 = Cpt(ROIPlugin, 'ROI3:')
#     roi4 = Cpt(ROIPlugin, 'ROI4:')
#     proc1 = Cpt(ProcessPlugin, 'Proc1:')

#     tiff = Cpt(TIFFPluginWithFileStore,
#                suffix='TIFF1:',
#                write_path_template='/nsls2/xf11bm/Pilatus300/%Y/%m/%d/',
#                root='/nsls2/xf11bm')

#     def setExposureTime(self, exposure_time, verbosity=3):
#         caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', exposure_time)
#         caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', exposure_time+0.1)

class PilatusV33(SingleTriggerV33, PilatusDetector):
    cam = Cpt(PilatusDetectorCamV33, 'cam1:')
    image = Cpt(ImagePlugin, 'image1:')
    stats1 = Cpt(StatsPluginV33, 'Stats1:')
    stats2 = Cpt(StatsPluginV33, 'Stats2:')
    stats3 = Cpt(StatsPluginV33, 'Stats3:')
    stats4 = Cpt(StatsPluginV33, 'Stats4:')
    stats5 = Cpt(StatsPluginV33, 'Stats5:')
    roi1 = Cpt(ROIPlugin, 'ROI1:')
    roi2 = Cpt(ROIPlugin, 'ROI2:')
    roi3 = Cpt(ROIPlugin, 'ROI3:')
    roi4 = Cpt(ROIPlugin, 'ROI4:')
    proc1 = Cpt(ProcessPlugin, 'Proc1:')


    tiff = Cpt(TIFFPluginWithFileStore,
               suffix='TIFF1:',
               write_path_template='/nsls2/xf11bm/Pilatus300/%Y/%m/%d/',
               root='/nsls2/xf11bm')

    def setExposureTime(self, exposure_time, verbosity=3):
        yield from mv(self.cam.acquire_time, exposure_time, self.cam.acquire_period, exposure_time+0.1)
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', exposure_time)
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', exposure_time+0.1)
    def setExposurePeriod(self, exposure_period, verbosity=3):
        yield from mv(self.cam.acquire_period, exposure_period)

    def setExposureNumber(self, exposure_number, verbosity=3):
        yield from mv(self.cam.num_images, exposure_number)

# class Pilatus800V33(PilatusV33):
#     tiff = Cpt(TIFFPluginWithFileStore,
#                suffix='TIFF1:',
#             #    write_path_template='/Pilatus800K/%Y/%m/%d/',       
#             #    read_path_template='/nsls2/xf11bm/Pilatus800K/%Y/%m/%d/',   
#             #    root='/nsls2/xf11bm')
#                write_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus800/%Y/%m/%d/',       
#             #    read_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus800/%Y/%m/%d/',   
#                root='/nsls2/data/cms/legacy/xf11bm')

class Pilatus800V33(SingleTriggerV33, PilatusDetector):
    cam = Cpt(PilatusDetectorCamV33, 'cam1:')
    image = Cpt(ImagePlugin, 'image1:')
    stats1 = Cpt(StatsPluginV33, 'Stats1:')
    stats2 = Cpt(StatsPluginV33, 'Stats2:')
    stats3 = Cpt(StatsPluginV33, 'Stats3:')
    stats4 = Cpt(StatsPluginV33, 'Stats4:')
    stats5 = Cpt(StatsPluginV33, 'Stats5:')
    roi1 = Cpt(ROIPlugin, 'ROI1:')
    roi2 = Cpt(ROIPlugin, 'ROI2:')
    roi3 = Cpt(ROIPlugin, 'ROI3:')
    roi4 = Cpt(ROIPlugin, 'ROI4:')
    proc1 = Cpt(ProcessPlugin, 'Proc1:')

    tiff = Cpt(TIFFPluginWithFileStore,
               suffix='TIFF1:',
            #    write_path_template='/nsls2/xf11bm/Pilatus2M/%Y/%m/%d/',     # GPFS client
               #write_path_template='/Pilatus2M/%Y/%m/%d/',                 # NSF-mount of GPFS directory
            #    root='/nsls2/xf11bm'
               read_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus800/%Y/%m/%d/',   

               write_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus800/%Y/%m/%d/',       
               root='/nsls2/data/cms/legacy/xf11bm')
               #root='/')

    def setExposureTime(self, exposure_time, verbosity=3):
        yield from mv(self.cam.acquire_time, exposure_time, self.cam.acquire_period, exposure_time+0.1)
        #self.cam.acquire_time.put(exposure_time)
        #self.cam.acquire_period.put(exposure_time+.1)
        #caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime', exposure_time)
        #caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquirePeriod', exposure_time+0.1)

    def setExposurePeriod(self, exposure_period, verbosity=3):
        yield from mv(self.cam.acquire_period, exposure_period)

    def setExposureNumber(self, exposure_number, verbosity=3):
        yield from mv(self.cam.num_images, exposure_number)

class Pilatus8002V33(PilatusV33):
    tiff = Cpt(TIFFPluginWithFileStore,
               suffix='TIFF1:',
            #    write_path_template='/Pilatus800K/%Y/%m/%d/',       
            #    read_path_template='/nsls2/xf11bm/Pilatus800K/%Y/%m/%d/',   
            #    root='/nsls2/xf11bm')
               write_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus800_2/%Y/%m/%d/',       
            #    read_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus800/%Y/%m/%d/',   
               root='/nsls2/data/cms/legacy/xf11bm')

class Pilatus300V33(PilatusV33):
    tiff = Cpt(TIFFPluginWithFileStore,
               suffix='TIFF1:',
               write_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus300/%Y/%m/%d/',
            #    read_path_template='/nsls2/xf11bm/Pilatus300/%Y/%m/%d/',
            #    root='/nsls2/xf11bm')
            #    read_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus300/%Y/%m/%d/',
               read_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus300/%Y/%m/%d/',   
               root='/nsls2/data/cms/legacy/xf11bm')
    
class Pilatus2M(SingleTrigger, PilatusDetector):

    image = Cpt(ImagePlugin, 'image1:')
    stats1 = Cpt(StatsPluginV33, 'Stats1:')
    stats2 = Cpt(StatsPluginV33, 'Stats2:')
    stats3 = Cpt(StatsPluginV33, 'Stats3:')
    stats4 = Cpt(StatsPluginV33, 'Stats4:')
    stats5 = Cpt(StatsPluginV33, 'Stats5:')
    roi1 = Cpt(ROIPlugin, 'ROI1:')
    roi2 = Cpt(ROIPlugin, 'ROI2:')
    roi3 = Cpt(ROIPlugin, 'ROI3:')
    roi4 = Cpt(ROIPlugin, 'ROI4:')
    proc1 = Cpt(ProcessPlugin, 'Proc1:')

    trans1 = Cpt(TransformPlugin, 'Trans1:')

    tiff = Cpt(TIFFPluginWithFileStore,
               suffix='TIFF1:',
               write_path_template='/nsls2/xf11bm/Pilatus2M/%Y/%m/%d/',
               root='/nsls2/xf11bm')

    def setExposureTime(self, exposure_time, verbosity=3):
        # how to do this with stage_sigs (warning, need to change this every time
        # if you set)
        # RE(pilatus2M.setEposure(1))   ---format 
        #self.cam.stage_sigs['acquire_time'] = exposure_time
        #self.cam.stage_sigs['acquire_period'] = exposure_time+.1

        yield from mv(self.cam.acquire_time, exposure_time, self.cam.acquire_period, exposure_time+0.1)
        #yield from mv(self.cam.acquire_period, exposure_time+0.1)



class Pilatus2MV33(SingleTriggerV33, PilatusDetector):
    cam = Cpt(PilatusDetectorCamV33, 'cam1:')
    image = Cpt(ImagePlugin, 'image1:')
    stats1 = Cpt(StatsPluginV33, 'Stats1:')
    stats2 = Cpt(StatsPluginV33, 'Stats2:')
    stats3 = Cpt(StatsPluginV33, 'Stats3:')
    stats4 = Cpt(StatsPluginV33, 'Stats4:')
    stats5 = Cpt(StatsPluginV33, 'Stats5:')
    roi1 = Cpt(ROIPlugin, 'ROI1:')
    roi2 = Cpt(ROIPlugin, 'ROI2:')
    roi3 = Cpt(ROIPlugin, 'ROI3:')
    roi4 = Cpt(ROIPlugin, 'ROI4:')
    proc1 = Cpt(ProcessPlugin, 'Proc1:')
    trans1 = Cpt(TransformPlugin, 'Trans1:')

    tiff = Cpt(TIFFPluginWithFileStore,
               suffix='TIFF1:',
            #    write_path_template='/nsls2/xf11bm/Pilatus2M/%Y/%m/%d/',     # GPFS client
               #write_path_template='/Pilatus2M/%Y/%m/%d/',                 # NSF-mount of GPFS directory
            #    root='/nsls2/xf11bm'
               write_path_template='/nsls2/data/cms/legacy/xf11bm/Pilatus2M/%Y/%m/%d/',     # Lustre client
               root='/nsls2/data/cms/legacy/xf11bm')
               #root='/')

    def setExposureTime(self, exposure_time, verbosity=3):
        yield from mv(self.cam.acquire_time, exposure_time, self.cam.acquire_period, exposure_time+0.1)
        #self.cam.acquire_time.put(exposure_time)
        #self.cam.acquire_period.put(exposure_time+.1)
        #caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime', exposure_time)
        #caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquirePeriod', exposure_time+0.1)

    def setExposurePeriod(self, exposure_period, verbosity=3):
        yield from mv(self.cam.acquire_period, exposure_period)

    def setExposureNumber(self, exposure_number, verbosity=3):
        yield from mv(self.cam.num_images, exposure_number)

    def stage(self):
        error = None
        #wrap the staging process in a retry loop
        for retry in range(5):
            try:
                return super().stage()
            except TimeoutError as err:
                # Staging failed becasue the IOC did not answer
                # some request in a resonable time
                #Stash the exception as the variable 'error'
                error = err
            else:
                # Staging worked. Strop retyring.
                break
        else:
            # We exhausted all retires and none worked. 
            # Raise the error captured above to produce a useful error message. 
            raise error


#class StandardProsilicaWithTIFF(StandardProsilica):
#    tiff = Cpt(TIFFPluginWithFileStore,
#               suffix='TIFF1:',
#               write_path_template='/nsls2/xf11bm/data/%Y/%m/%d/',
#               root='/nsls2/xf11bm/')



## This renaming should be reversed: no correspondance between CSS screens, PV names and ophyd....
#xray_eye1 = StandardProsilica('XF:11IDA-BI{Bpm:1-Cam:1}', name='xray_eye1')
#xray_eye2 = StandardProsilica('XF:11IDB-BI{Mon:1-Cam:1}', name='xray_eye2')
#xray_eye3 = StandardProsilica('XF:11IDB-BI{Cam:08}', name='xray_eye3')
#xray_eye1_writing = StandardProsilicaWithTIFF('XF:11IDA-BI{Bpm:1-Cam:1}', name='xray_eye1')
#xray_eye2_writing = StandardProsilicaWithTIFF('XF:11IDB-BI{Mon:1-Cam:1}', name='xray_eye2')
#xray_eye3_writing = StandardProsilicaWithTIFF('XF:11IDB-BI{Cam:08}', name='xray_eye3')
#fs1 = StandardProsilica('XF:11IDA-BI{FS:1-Cam:1}', name='fs1')
#fs2 = StandardProsilica('XF:11IDA-BI{FS:2-Cam:1}', name='fs2')
#fs_wbs = StandardProsilica('XF:11IDA-BI{BS:WB-Cam:1}', name='fs_wbs')
#dcm_cam = StandardProsilica('XF:11IDA-BI{Mono:DCM-Cam:1}', name='dcm_cam')
#fs_pbs = StandardProsilica('XF:11IDA-BI{BS:PB-Cam:1}', name='fs_pbs')
#elm = Elm('XF:11IDA-BI{AH401B}AH401B:',)

import time

time.sleep(1)
# fs1 = StandardProsilicaV33('XF:11BMA-BI{FS:1-Cam:1}', name='fs1')
time.sleep(1)
fs2 = StandardProsilicaV33('XF:11BMA-BI{FS:2-Cam:1}', name='fs2')
time.sleep(1)
fs3 = StandardProsilicaV33('XF:11BMB-BI{FS:3-Cam:1}', name='fs3')
time.sleep(1)
fs4 = StandardProsilicaV33('XF:11BMB-BI{FS:4-Cam:1}', name='fs4')
time.sleep(1)
# fs5 = StandardProsilicaV33('XF:11BMB-BI{FS:Test-Cam:1}', name='fs5')


#class StandardsimDetectorV33(SingleTriggerV33, ProsilicaDetector):
    ## tiff = Cpt(TIFFPluginWithFileStore,
    ##           suffix='TIFF1:',
    ##           write_path_template='/XF11ID/data/')
    #cam = Cpt(ProsilicaDetectorCamV33, 'cam1:')
    #image = Cpt(ImagePlugin, 'image1:')
    #stats1 = Cpt(StatsPluginV33, 'Stats1:')
    #stats2 = Cpt(StatsPluginV33, 'Stats2:')
    #stats3 = Cpt(StatsPluginV33, 'Stats3:')
    #stats4 = Cpt(StatsPluginV33, 'Stats4:')
    #stats5 = Cpt(StatsPluginV33, 'Stats5:')
    #trans1 = Cpt(TransformPlugin, 'Trans1:')
    #roi1 = Cpt(ROIPlugin, 'ROI1:')
    #roi2 = Cpt(ROIPlugin, 'ROI2:')
    #roi3 = Cpt(ROIPlugin, 'ROI3:')
    #roi4 = Cpt(ROIPlugin, 'ROI4:')
    #proc1 = Cpt(ProcessPlugin, 'Proc1:')

# simDetector = StandardProsilicaV33('13SIM1:', name='simDetector')


# all_standard_pros = [fs1, fs2, fs3, fs4, fs5, simDetector]
# all_standard_pros = [fs1, fs2, fs3, fs4]
all_standard_pros = [fs2, fs3, fs4]






for camera in all_standard_pros:
    camera.read_attrs = ['stats1', 'stats2','stats3','stats4','stats5']
    # camera.tiff.read_attrs = []  # leaving just the 'image'
    for stats_name in ['stats1', 'stats2','stats3','stats4','stats5']:
        stats_plugin = getattr(camera, stats_name)
        stats_plugin.read_attrs = ['total']
        #camera.stage_sigs[stats_plugin.blocking_callbacks] = 1

    #camera.stage_sigs[camera.roi1.blocking_callbacks] = 1
    #camera.stage_sigs[camera.trans1.blocking_callbacks] = 1
    #camera.cam.ensure_nonblocking()
    
    #camera.stage_sigs[camera.cam.trigger_mode] = 'Fixed Rate'


#for camera in [xray_eye1_writing, xray_eye2_writing, xray_eye3_writing]:
#    camera.read_attrs.append('tiff')
#    camera.tiff.read_attrs = []

#pilatus300 section is marked out as the detector sever cannot be reached after AC power outrage. 121417-RL
#pilatus300 section is unmarked.  032018-MF
#pilatus300 section is marked out for bluesky upgrade.  010819-RL

#pilatus300 section
#if True:
if Pilatus300_on == True:
    pilatus300 = Pilatus300V33('XF:11BMB-ES{Det:SAXS}:', name='pilatus300')
    #pilatus300 = PilatusV33('XF:11BMB-ES{Det:SAXS}:', name='pilatus300')
    pilatus300.tiff.read_attrs = []
    pilatus300.stats3.total.kind = 'hinted'
    pilatus300.stats4.total.kind = 'hinted'
    STATS_NAMES = ['stats1', 'stats2', 'stats3', 'stats4', 'stats5']
    pilatus300.read_attrs = ['tiff'] + STATS_NAMES
    for stats_name in STATS_NAMES:
        stats_plugin = getattr(pilatus300, stats_name)
        stats_plugin.read_attrs = ['total']

    pilatus300.cam.ensure_nonblocking()
else:
    pilatus300 = 'Pil300ISNOTWORKING'

#pilatus800 section
#if False:
#if True:
if Pilatus800_on == True:
    pilatus800 = Pilatus800V33('XF:11BMB-ES{Det:PIL800K}:', name='pilatus800')
    pilatus800.tiff.read_attrs = []
    pilatus800.stats3.total.kind = 'hinted'
    pilatus800.stats4.total.kind = 'hinted'
    STATS_NAMES = ['stats1', 'stats2', 'stats3', 'stats4', 'stats5']
    pilatus800.read_attrs = ['tiff'] + STATS_NAMES
    for stats_name in STATS_NAMES:
        stats_plugin = getattr(pilatus800, stats_name)
        stats_plugin.read_attrs = ['total']

    for item in pilatus800.stats1.configuration_attrs:
        item_check = getattr(pilatus800.stats1, item)
        item_check.kind= 'omitted'

    for item in pilatus800.stats2.configuration_attrs:
        item_check = getattr(pilatus800.stats2, item)
        item_check.kind= 'omitted'

    for item in pilatus800.stats3.configuration_attrs:
        item_check = getattr(pilatus800.stats3, item)
        item_check.kind= 'omitted'

    for item in pilatus800.stats4.configuration_attrs:
        item_check = getattr(pilatus800.stats4, item)
        item_check.kind= 'omitted'

    for item in pilatus800.stats5.configuration_attrs:
        item_check = getattr(pilatus800.stats5, item)
        item_check.kind= 'omitted'

    for item in pilatus800.tiff.configuration_attrs:
        item_check = getattr(pilatus800.tiff, item)
        item_check.kind= 'omitted'

    for item in pilatus800.cam.configuration_attrs:
        item_check = getattr(pilatus800.cam, item)
        item_check.kind= 'omitted'
else:
    pilatus800 = 'Pil800ISNOTWORKING'

#pilatus800_2 section  changed by RL, 20210831
#if False:
#if True:
if Pilatus800_2_on == True:
    #TODO: 
    pilatus8002 = Pilatus8002V33('XF:11BMB-ES{Det:PIL800K2}:', name='pilatus8002') #change PV
    pilatus8002.tiff.read_attrs = []
    pilatus8002.stats3.total.kind = 'hinted'
    pilatus8002.stats4.total.kind = 'hinted'
    STATS_NAMES = ['stats1', 'stats2', 'stats3', 'stats4', 'stats5']
    pilatus8002.read_attrs = ['tiff'] + STATS_NAMES
    for stats_name in STATS_NAMES:
        stats_plugin = getattr(pilatus8002, stats_name)
        stats_plugin.read_attrs = ['total']

    for item in pilatus8002.stats1.configuration_attrs:
        item_check = getattr(pilatus8002.stats1, item)
        item_check.kind= 'omitted'

    for item in pilatus8002.stats2.configuration_attrs:
        item_check = getattr(pilatus8002.stats2, item)
        item_check.kind= 'omitted'

    for item in pilatus8002.stats3.configuration_attrs:
        item_check = getattr(pilatus8002.stats3, item)
        item_check.kind= 'omitted'

    for item in pilatus8002.stats4.configuration_attrs:
        item_check = getattr(pilatus8002.stats4, item)
        item_check.kind= 'omitted'

    for item in pilatus8002.stats5.configuration_attrs:
        item_check = getattr(pilatus8002.stats5, item)
        item_check.kind= 'omitted'

    for item in pilatus8002.tiff.configuration_attrs:
        item_check = getattr(pilatus8002.tiff, item)
        item_check.kind= 'omitted'

    for item in pilatus8002.cam.configuration_attrs:
        item_check = getattr(pilatus8002.cam, item)
        item_check.kind= 'omitted'
else:
    pilatus8002 = 'Pil800-2ISNOTWORKING'

#pilatus2M section
#if False:
if Pilatus2M_on == True:
    pilatus2M = Pilatus2MV33('XF:11BMB-ES{Det:PIL2M}:', name='pilatus2M')
    pilatus2M.tiff.read_attrs = []
    STATS_NAMES2M = ['stats1', 'stats2', 'stats3', 'stats4']
    pilatus2M.read_attrs = ['tiff'] + STATS_NAMES2M
    for stats_name in STATS_NAMES2M:
        stats_plugin = getattr(pilatus2M, stats_name)
        stats_plugin.read_attrs = ['total']
    pilatus2M.cam.ensure_nonblocking()
    pilatus2M.tiff.ensure_blocking()
    pilatus2M.stats3.total.kind = 'hinted'
    pilatus2M.stats4.total.kind = 'hinted'


    for item in pilatus2M.stats1.configuration_attrs:
        item_check = getattr(pilatus2M.stats1, item)
        item_check.kind= 'omitted'

    for item in pilatus2M.stats2.configuration_attrs:
        item_check = getattr(pilatus2M.stats2, item)
        item_check.kind= 'omitted'

    for item in pilatus2M.stats3.configuration_attrs:
        item_check = getattr(pilatus2M.stats3, item)
        item_check.kind= 'omitted'

    for item in pilatus2M.stats4.configuration_attrs:
        item_check = getattr(pilatus2M.stats4, item)
        item_check.kind= 'omitted'

    for item in pilatus2M.stats5.configuration_attrs:
        item_check = getattr(pilatus2M.stats5, item)
        item_check.kind= 'omitted'

    for item in pilatus2M.tiff.configuration_attrs:
        item_check = getattr(pilatus2M.tiff, item)
        item_check.kind= 'omitted'

    for item in pilatus2M.cam.configuration_attrs:
        item_check = getattr(pilatus2M.cam, item)
        item_check.kind= 'omitted'
else:
    pilatus2M = 'Pil2MISNOTWORKING'



#define the current pilatus detector: pilatus_name and _Epicsname, instead of
#pilatus300 or pilatus2M
# pilatus_name = pilatus800
# pilatus_Epicsname = '{Det:PIL800K}'
pilatus_name = pilatus2M
pilatus_Epicsname = '{Det:PIL2M}'

#pilatus_name = pilatus800
#pilatus_Epicsname = '{Det:PIL800K}'

#######################################################
# These are test functions added by Julien
# We should remove them once we find the source of the
# current "None"type bug at CMS (TRAC ticket [2284]
def get_stage_sigs(dev, dd):
    for cpt_name in dev.component_names:
        cpt = getattr(dev, cpt_name)
        if hasattr(cpt, 'stage_sigs'):
            dd.update(cpt.stage_sigs)
        if hasattr(cpt, 'component_names'):
            get_stage_sigs(cpt, dd)

def stage_unstage_forever_plan(det):
    i = 0
    print("Started the stage_unstage_plan, running infinite loop...")
    while True:
        i += 1
        #print(f"Staging {i}th time")
        yield from bps.stage(det)
        yield from bps.unstage(det)

def trigger_forever_plan(det):
    i = 0
    print("Started the stage_unstage_plan, running infinite loop...")
    while True:
        i += 1
        #print(f"Staging {i}th time")
        yield from bps.stage(det)
        yield from bps.trigger(det, group="det")
        yield from bps.wait("det")
        yield from bps.unstage(det)

def count_forever_plan(det):
    i = 0
    print("Started the count_forever plan, running infinite loop...")
    while True:
        i += 1
        #print(f"Staging {i}th time")
        yield from bp.count([det])

def stage_unstage_once_plan(det):
    #print(f"Staging {i}th time")
    yield from bps.stage(det)
    yield from bps.unstage(det)

def count_no_save_plan(det):
    #print(f"Staging {i}th time")
    yield from bps.stage(det)
    yield from bps.trigger(det)
    yield from bps.unstage(det)

# to get stage sigs
#from collections import OrderedDict
#stage_sigs = OrderedDict()
#get_stage_sigs(pilatus2M, stage_sigs)


#######################################################

#pilatus_name = pilatus300
#pilatus_Epicsname = '{Det:SAXS}'
# for cam_number, fs in zip([1,2,3,4], [fs1, fs2, fs3, fs4]):
for cam_number, fs in zip([2,3,4], [fs2, fs3, fs4]):
    G, port_dict = fs.get_asyn_digraph()
    cam = port_dict['cam{:02}'.format(cam_number)]
    for v in port_dict.values():
        try:
            if v.nd_array_port.get() == 'CAM':
                v.nd_array_port.set('cam{:02}'.format(cam_number))
        except AttributeError:
            pass
    fs.validate_asyn_ports()

def xp_set(seconds):
#    sleep_time=0.002
    #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime',seconds)
    caput('XF:11BMB-ES{}:cam1:AcquireTime'.format(pilatus_Epicsname),seconds)
#    sleep(sleep_time)
    caput('XF:11BMB-ES{}:cam1:AcquirePeriod'.format(pilatus_Epicsname),seconds+0.1)

def xp(seconds):
    sleep_time=0.1
    caput('XF:11BMB-ES{}:cam1:Acquire'.format(pilatus_Epicsname),1)
    time.sleep(seconds+sleep_time)


import time
#import select
import re
from ophyd import Device


#from ophyd.areadetector.plugins import ImagePlugin, TIFFPlugin

#class ImagePluginCustom(ImagePlugin):
    #@property
    #def image(self):
        #return 0.0

   
#from ophyd.areadetector.filestore_mixins import FileStoreTIFFIterativeWrite
#class TIFFPluginWithFileStore(TIFFPlugin, FileStoreTIFFIterativeWrite):
    #pass
    

class PhotonicSciences_CMS(Device):
    
    #image = Cpt(ImagePluginCustom, 'image1:')
    #tiff = Cpt(TIFFPluginWithFileStore,
               #suffix='TIFF1:',
               #write_path_template='/nsls2/xf11bm/waxsdet/%Y/%m/%d/')
    
    
    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,
                 name='PhotonicSciences_CMS', parent=None, **kwargs):

        super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)
        
        self.file_path = '/nsls2/xf11bm/waxsdet/images'
        
        self.temperature_re = re.compile('.+CCD temperature (.+) deg.+')
        self.status_re = re.compile('.+detector status=(.+)\.')
        self.exposure_re = re.compile('.+exposure time set to (.+) second.+')

        self.exposure_time = 1
        self.max_wait_time = 10.0
        
        self.connect_socket()
        self.detector_binning(2, 2)
        
        
    def setExposureTime(self, exposure_time, verbosity=3):
       self.detector_set_exposure_time(exposure_time, verbosity=verbosity) 


    # Ophyd methods
    ########################################
    def stage(self, *args, poling_period=0.1, **kwargs):
        
        # Give detector a chance to get ready 
        start_time = time.time()
        while (not self.detector_is_ready(verbosity=0)) and (time.time()-start_time)<(self.max_wait_time):
            time.sleep(poling_period)
        
        if not self.detector_is_ready():
            print('ERROR: {} is not responding.'.format(self.name))
            
        return super().stage(*args, **kwargs)
    
    
    def trigger(self):
        
        self.detector_measure()
        
        return super().trigger()


    #def unstage(self):
        #return super().unstage()
        
        
        
    # Essential socket interaction
    ########################################
        
    def connect_socket(self):
        
        self.server_address= '10.11.129.11 '
        #self.server_address= '10.11.129.12 ' #The backup computer

        #self.server_IP = '10.11.129.11' 
        self.server_port = 27015
        
        import socket
        #self.sock = socket.socket()
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.server_address)
        self.sock.connect((self.server_address, self.server_port))
        
        self.sock.settimeout(0.5)
        
        
    def disconnect_socket(self):
        
        self.sock.close()
    
        
    def send_socket(self, msg):
        
        #self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return
        self.sock.send(msg.encode('ascii', 'ignore'))
        #self.sock.send(msg.encode('utf-8'))


    def send_get_reply(self, msg, verbosity=3):
        
        #self.send_socket('\r')
        self.send_socket(msg)
        
        time.sleep(0.5)
        
        return self.read_socket(verbosity=verbosity)
    
        
    def read_socket(self, timeout_s=3, verbosity=3):
        
        start_time = time.time()
        terminator = chr(0x18)
    
        # Look for the response
        amount_received = 0
        amount_cutoff = 5000
        
        txt = ''
        msg_received = ''
        
        while terminator not in txt and time.time()-start_time<timeout_s and amount_received<amount_cutoff:
            try:
                data = self.sock.recv(1)
            except:
                break
                                    
            amount_received += len(data)
            txt = data.decode('ascii')
            
            msg_received += txt
            
        msg_received = msg_received.replace(terminator, '')
        
        if time.time()-start_time>timeout_s:
            if verbosity>=1:
                print('Read timeout after {:.1f} s.'.format(time.time()-start_time))
            return ''
        
        else:
            if verbosity>=2:
                print(msg_received)
            return msg_received
            
            
    # Detector commands
    ########################################
            
    def detector_status(self, verbosity=3):
        
        reply = self.send_get_reply('ST', verbosity=verbosity)
        m = self.status_re.match(reply)
        if m:
            code = int(m.groups()[0])
            return code
        else:
            return None
            
    def detector_is_ready(self, verbosity=3):
        return self.detector_status(verbosity=verbosity)==1
            
            
    def detector_abort(self, verbosity=3):
        
        return self.send_get_reply('AB', verbosity=verbosity)
    
    
    def detector_binning(self, binx=2, biny=2, verbosity=3):
        
        if binx==None or biny==None:
            binx = 2
            biny = 2
        
        return self.send_get_reply('BN {:d} {:d}'.format(binx, biny), verbosity=verbosity)
    
    
    
    def detector_trigger(self, verbosity=3):
        
        return self.send_get_reply('TR', verbosity=verbosity)

    def detector_temperature(self, verbosity=3):
        
        reply = self.send_get_reply('T?', verbosity=verbosity)
        m = self.temperature_re.match(reply)
        if m:
            T = float(m.groups()[0])
            return T
        
        else:
            return reply
        
        
    def detector_set_exposure_time(self, exposure_time, verbosity=3):
        
        self.exposure_time = exposure_time
        reply = self.send_get_reply('EX {:10.2f}'.format(exposure_time), verbosity=verbosity)
        
        return reply
    
    #def detector_get_exposure_time(self, verbosity=3):
        
        #reply = self.send_get_reply('EX', verbosity=verbosity)
        #m = self.exposure_re.match(reply)
        #if m:
            #exposure_time = float(m.groups()[0])
            #return exposure_time
        
        #else:
            #return reply
    
    def detector_expose(self, verbosity=3):
        
        return self.send_get_reply('GO', verbosity=verbosity)
    
    
    def detector_save(self, filename, verbosity=3):
        
        reply = self.send_get_reply('SV {:s}'.format(filename), verbosity=verbosity)
        
        return reply
    
    
    def detector_measure(self, exposure_time=None, savename='_current', verbosity=3, poling_period=0.1):
        
        if exposure_time is not None:
            self.detector_set_exposure_time(exposure_time)
            self.exposure_time = exposure_time
        else:
            exposure_time = self.exposure_time
            
        self.detector_expose()
        
        if verbosity>=2:
            start_time = time.time()
            time.sleep(0.2)
            while (not self.detector_is_ready(verbosity=0)) and (time.time()-start_time)<(exposure_time+self.max_wait_time):
                percentage = 100*(time.time()-start_time)/exposure_time
                print( 'Exposing {:6.2f} s  ({:3.0f}%)      \r'.format((time.time()-start_time), percentage), end='')
                time.sleep(poling_period)
        else:
            time.sleep(exposure_time + 0.2)
        

        self.file_name = savename
        self.detector_save(savename, verbosity=verbosity)
    
    
    
    

#psccd = PhotonicSciences_CMS()
#psccd = None

#psccd.detector_is_ready()
#psccd.detector_temperature()
import ophyd

##### FOE #####
quad_electrometer1_1 = ophyd.EpicsSignalRO("XF:11BMA-BI{IM:1}EM180:Current1:MeanValue_RBV", name='quad_electrometer1_1')
quad_electrometer1_2 = ophyd.EpicsSignalRO("XF:11BMA-BI{IM:1}EM180:Current2:MeanValue_RBV", name='quad_electrometer1_2')
quad_electrometer1_3 = ophyd.EpicsSignalRO("XF:11BMA-BI{IM:1}EM180:Current3:MeanValue_RBV", name='quad_electrometer1_3')
quad_electrometer1_4 = ophyd.EpicsSignalRO("XF:11BMA-BI{IM:1}EM180:Current4:MeanValue_RBV", name='quad_electrometer1_4')

bim1 = ophyd.EpicsSignalRO("XF:11BMA-BI{IM:1}EM180:Current1:MeanValue_RBV", name='bim1')
bim2 = ophyd.EpicsSignalRO("XF:11BMA-BI{IM:1}EM180:Current2:MeanValue_RBV", name='bim2')


##### Endstation #####
## TODO: fix 'precision' and 'units' at EPICS level
ion_chamber1 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:3}:IC1_MON", name='ion_chamber1')
ion_chamber2 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:3}:IC2_MON", name='ion_chamber2')
ion_chamber3 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:3}:IC3_MON", name='ion_chamber3')
ion_chamber4 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:3}:IC4_MON", name='ion_chamber4')


class ScaleSignal(ophyd.signal.DerivedSignal):
    def __init__(self, *args, factor, **kwargs):
        self._factor = factor
        super().__init__(*args, **kwargs)
        
    def inverse(self, value):
        return self._factor * value
    def forward(self, value):
        return value / self._factor
    def describe(self):
        desc = super().describe()
        wd = desc[self.name]
        wd['derived_type'] = 'ScaleSignal'
        wd['factor'] = self._factor
        return desc

scaled_ic1 = ScaleSignal(ion_chamber1, factor=1e9, name='scaled_ic1')
scaled_ic2 = ScaleSignal(ion_chamber2, factor=1e9, name='scaled_ic2')
scaled_ic3 = ScaleSignal(ion_chamber3, factor=1e9, name='scaled_ic3')
scaled_ic4 = ScaleSignal(ion_chamber4, factor=1e9, name='scaled_ic4')


quad_electrometer2_1 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV", name='quad_electrometer2_1')
quad_electrometer2_2 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:2}EM180:Current2:MeanValue_RBV", name='quad_electrometer2_2')
quad_electrometer2_3 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:2}EM180:Current3:MeanValue_RBV", name='quad_electrometer2_3')
quad_electrometer2_4 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:2}EM180:Current4:MeanValue_RBV", name='quad_electrometer2_4')


# bim6 is the monitor after the sample (called dsmon on X9)
# The monitor sits on an arm on the DET system, so it can be moved with DETx and DETy
#bim6 = ophyd.EpicsSignalRO("XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV", name='bim6')
class EpicsSignalROWait(ophyd.EpicsSignalRO):
    '''Customized version of EpicsSignal that has a 'wait_time' in the 'read()'
    function. This can be used for signals that need some time to settle before
    a value is read.'''
    
    def __init__(self, *args, wait_time=None, **kwargs):
        
        if wait_time is not None:
            self._wait_time = wait_time
        else:
            self._wait_time = 0
            
        super().__init__(*args, **kwargs)
        
    def read(self, *args, **kwargs):
        
        #print('waiting {} s'.format(self._wait_time))
        sleep(self._wait_time)
        return super().read(*args, **kwargs)
            

bim6 = EpicsSignalROWait("XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV", wait_time=1, name='bim6')

class EpicsSignalROIntegrate(ophyd.EpicsSignalRO):
    '''Customized version of EpicsSignal that has manually integrates (averages
    a few values). This can be used for signals that are otherwise too erratic.'''

    def __init__(self, *args, wait_time=None, integrate_num=1, integrate_delay=0.01, **kwargs):

        if wait_time is not None:
            self._wait_time = wait_time
        else:
            self._wait_time = 0
            
        self._integrate_num = integrate_num
        self._integrate_delay = integrate_delay

        super().__init__(*args, **kwargs)


    def read(self, *args, **kwargs):

        #print('waiting {} s'.format(self._wait_time))
        sleep(self._wait_time)
        
        value = 0.0
        num = 0.0
        for i in range(self._integrate_num):
            value_current = super().read(*args, **kwargs)[self.name]['value']
            #print(value_current)
            value += value_current
            num += 1.0
            sleep(self._integrate_delay)
        
        value /= num
        
        ret = super().read(*args, **kwargs)
        ret[self.name]['value'] = value
        
        return ret


bim6_integrating = EpicsSignalROIntegrate("XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV", wait_time=0.5, integrate_num=8, integrate_delay=0.1, name='bim6')



########## FOE ##########


########## Endstation ##########
###TODO: change bim3, bim4, bim5 to EPICS signal

## Ion chamber: FMB Oxford I404
from math import exp

def curr_to_flux(amp):
    '''Converts Ion Chamber current [A] to flux [ph/s] for FMB Oxford IC filled with gas N2 at 1 atm'''
    E = getE(q=1)	## E in [keV]
    V_ion = 0.036	## ionization energy of N2 gas in [keV]
    IC_len = 6.0	## active length of Ion Chamber in [cm]
    qe = 1.602e-19	## electron charge in [C]

    ## Absorption length [cm] of gas N2 (1 atm, 1.131 g/L) vs E [keV]
    # based on polynomial fit to the calculated abs length data from: henke.lbl.gov/optical_constants/atten2.html 
    # see /home/xf11bm/masa/atten_len_N2* 
    abs_len = 355.21 - 112.26*E + 11.200*E*E - 0.10611*E*E*E	

    N_abs = amp*V_ion/(qe*E)
    flux = N_abs / (1.0 - exp(-IC_len/abs_len))
    return(flux)    

def get_bim3(q=0):
    '''Returns flux at ion chamber in [ph/s] (q=1 for quiet)'''
    bim3_v1 = caget('XF:11BMB-BI{IM:3}:IC1_MON')
    bim3_v2 = caget('XF:11BMB-BI{IM:3}:IC2_MON')
    bim3_h1 = caget('XF:11BMB-BI{IM:3}:IC3_MON')
    bim3_h2 = caget('XF:11BMB-BI{IM:3}:IC4_MON')
    flux_v = curr_to_flux(bim3_v1+bim3_v2)
    flux_h = curr_to_flux(bim3_h1+bim3_h2)
    if q==0:
        print('BIM3 Ion Chamber (Endstation)')
        print('Vertical:')
        print(' Signal 1: %.3e A' % bim3_v1)
        print(' Signal 2: %.3e A' % bim3_v2)
        print(' Signal - total: %.3e A' % (bim3_v1+bim3_v2))
        print('   Flux - total: %.3e ph/s' % flux_v)
        print('Horizontal:')
        print(' Signal 1: %.3e A' % bim3_h1)
        print(' Signal 2: %.3e A' % bim3_h2)
        print(' Signal - total: %.3e A' % (bim3_h1+bim3_h2))
        print('   Flux - total: %.3e ph/s' % flux_h)
    return(flux_h)


##### Following added in July 2017: Check first #####
## Scintillation detector: FMB Oxford C400, channel 1
def get_bim4(q=0):
    '''Returns flux at scintillation detector in [cts/s] (q=1 for quiet)'''
    bim4_sec = caget('XF:11BMB-BI{IM:4}:GET_PERIOD')
    bim4_cts = caget('XF:11BMB-BI{IM:4}:C1_1')

    ### Ratio between estimated beam flux to raw scintillator counts (see Olog entry on July 7, 2017)
    # For unslitted, unattenuated beam, BIM4 yields 2.86E5 cts/sec for 1.85E11 ph/s at BIM3:
    # 1.85E11 / 2.86E5 = 647000 (ph/s)/(cts/sec).
    # bim4_factor = 647000.

    ### Ratio between estimated beam flux to raw scintillator counts (see Olog entry on January 18, 2018)
    # For unslitted beam with absorber 4 and evacuated chamber, 
    # BIM4 yields 1.978E5 cts/sec for 1.73E11 ph/s at BIM3 and 1.55e11 ph/s at Pilatus2M:
    # Scale factor = (1.545e11 ph/sec) / (1.978e+05 ph/s) = 7.786e5.
    bim4_factor = 7.786E5

    if bim4_sec != 0.0:
        bim4_cps = bim4_cts/bim4_sec
        bim4_flux = bim4_cps * bim4_factor
    else:
        bim4_cps = -1
        bim4_flux = -1

    if q==0:
        print('BIM4 Scintillation Detector (Endstation)')
        print('Raw count rate: %.3e ph/s' % bim4_cps)
        print('Beam flux: %.3e ph/s' % bim4_flux)
        if bim4_flux == -1:
            print('Counting time seems to be set to zero. Check settigs on FMB Oxford C400.')

    return(bim4_flux)


## Dectris RIGI diamond diode BPM: FMB Oxford F460, channels 1-4
def get_bim5(q=0):
    '''Returns flux at 4-quadrant diamond diode BPM in [cts/s] (q=1 for quiet)'''

    bim5_i0_dark = -3.8e-10	# dark current in A
    bim5_i1_dark = 5.5e-10	# dark current in A
    bim5_i2_dark = 2.3e-10	# dark current in A
    bim5_i3_dark = 5.3e-10	# dark current in A
    bim5_i0 = caget('XF:11BMB-BI{BPM:1}Cur:I0-I') - bim5_i0_dark    # upper left
    bim5_i1 = caget('XF:11BMB-BI{BPM:1}Cur:I1-I') - bim5_i1_dark    # upper right
    bim5_i2 = caget('XF:11BMB-BI{BPM:1}Cur:I2-I') - bim5_i2_dark    # lower left
    bim5_i3 = caget('XF:11BMB-BI{BPM:1}Cur:I3-I') - bim5_i3_dark    # lower right

    ### Ratio between estimated beam flux to raw TOTAL current for the 4 quadrants 
    # (see Olog entry on July 7, 2017).
    # For unslitted, unattenuated beam, BIM5 yields a TOTAL current of 4.8E-8 A at ~230 mA ring current, 
    # corresponding to 1.38E11 ph/s at BIM3:
    # 1.38E11 / 4.8E-8 = 0.29E19 (ph/s)/A.
    # With dark current (total = 9.3e-10 A = 0.093e-8 A) taken into account, 
    # 1.38E11 / 4.7E-8 = 0.294E19 (ph/s)/A.
    # bim5_curr_to_flux = 2.94E18

    ### Ratio between estimated beam flux to raw TOTAL current for the 4 quadrants 
    # (see Olog entry on January 18, 2018).
    # For unslitted beam with absorber 4 and evacuated chamber, 
    # BIM5 yields 5.09e-8 A for for 1.73E11 ph/s at BIM3 and 1.55e11 ph/s at Pilatus2M:
    # Scale factor = (1.545e11 ph/sec) / (5.0902e-08 A) = 3.025e+18
    bim5_curr_to_flux = 3.025E18

    bim5_T = bim5_i0+bim5_i1
    bim5_B = bim5_i2+bim5_i3
    bim5_L = bim5_i0+bim5_i2
    bim5_R = bim5_i1+bim5_i3

    bim5_v = (bim5_T - bim5_B)/(bim5_T + bim5_B)
    bim5_h = (bim5_R - bim5_L)/(bim5_R + bim5_L)
    bim5_flux = bim5_curr_to_flux * (bim5_T + bim5_B)

    if q==0:
        print('BIM5 Diamond Diode BPM (Endstation)')
        print('Vertical:')
        print(' Signal Top: %.3e A' % bim5_T)
        print(' Signal Bottom: %.3e A' % bim5_B)
        print(' Offset [-1(B) to 1(T), 0 at center]: %.3f' % bim5_v)
        print('Horizontal:')
        print(' Signal Right: %.3e A' % bim5_R)
        print(' Signal Left: %.3e A' % bim5_L)
        print(' Offset [-1(L) to 1(R), 0 at center]: %.3f' % bim5_h)
        print('Total Signal: %.3e A' % (bim5_T + bim5_B))
        print('Total Flux: %.3e ph/s' % bim5_flux)

    return(bim5_flux)


import time
#import select
import re
from ophyd import Device


#class SerialDevice():
    
#    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,
#                 name='SerialDevice', parent=None, **kwargs):

        #super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)

        
            

            
class Agilent_34970A(Device):
    # Note: Command terminator is a newline character \n.
    # Note: On serial cable, data transmit/receive pins (pins 2 and 3 on Dsub-9 connector) must be reversed.
    # Settings as of 07/25/2017: Baud rate = 19200 bits/s, Stop bits = 1, Parity = None, Flow control = None 
    # Moxa port 9: socket = 10.11.130.53:4009
    
    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,
                 name='Agilent_34970A', parent=None, **kwargs):

        super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)

        #self.port_number = 9
        #self.server_port = 4000 + self.port_number
        self.connect_socket()
        self.HP34901_channel = 100	# 20 channel multiplexer module card in slot 1        
        self.HP34907_channel = 300	# DIO/DAC card in slot 3

    # Essential socket interaction
    ########################################
        
    def connect_socket(self):
        
        #self.server_address= '10.11.130.51'
        #self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch
        self.server_address= '10.68.82.73'     # NEW IP, 20201112
        #self.server_IP = '10.11.129.2'
        self.port_number = 9
        self.server_port = 4000 + self.port_number
        
        import socket
        #self.sock = socket.socket()
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.server_address)
        self.sock.connect((self.server_address, self.server_port))
        
        self.sock.settimeout(0.5)
        
        
    def disconnect_socket(self):
        
        self.sock.close()
    
        
    def send_socket(self, msg):
        
        #self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return
        self.sock.send(msg.encode('ascii', 'ignore'))
        #self.sock.send(msg.encode('utf-8'))


    def send_get_reply(self, msg, verbosity=3):
        
        #self.send_socket('\r')
        self.send_socket(msg)
        
        time.sleep(0.5)
        
        return self.read_socket(verbosity=verbosity)
    
        
    def read_socket(self, timeout_s=3, verbosity=3):
        
        start_time = time.time()
        terminator = chr(0x18)
    
        # Look for the response
        amount_received = 0
        amount_cutoff = 5000
        
        txt = ''
        msg_received = ''
        
        while terminator not in txt and time.time()-start_time<timeout_s and amount_received<amount_cutoff:
            try:
                data = self.sock.recv(1)
            except:
                break
                                    
            amount_received += len(data)
            txt = data.decode('ascii')
            
            msg_received += txt
            
        msg_received = msg_received.replace(terminator, '')
        
        if time.time()-start_time>timeout_s:
            if verbosity>=1:
                print('Read timeout after {:.1f} s.'.format(time.time()-start_time))
            return ''
        
        else:
            if verbosity>=2:
                print(msg_received)
            return msg_received
        

    # Commands for Agilent 34970A unit
    ########################################

    # Reset Agilent 34970A unit to factory default settings.
    def reset_Agilent34970A(self, verbosity = 3):
        self.send_socket('*RST\n')


    # Commands for HP34901 20-channel muliplexer module card
    ########################################

    # Reset HP34901 to factory default settings.
    def reset_HP34901(self, verbosity = 3):
        self.send_socket('SYSTEM:CPON {chan}\n'.format(chan=self.HP34901_channel))


    # Read DC voltage on specified channel.
    def readDCV(self, channel, verbosity = 1):
        if (channel < 1 or channel > 20):
            print('Invalid multiplexer channel number; must be 1-20.\n')
            return 0

        read_channel = int(self.HP34901_channel + channel)
        self.send_socket('INPUT:IMP:AUTO ON, (@{chan})\n'.format(chan=read_channel))    
        self.send_socket('SENSE:ZERO:AUTO ON, (@{chan})\n'.format(chan=read_channel))    
        self.send_socket('MEAS:VOLT:DC? AUTO,MAX, (@{chan})\n'.format(chan=read_channel))    
        dcv = float(self.read_socket(verbosity=1))

        if (verbosity > 1):
            print('Channel {chan} is {volts} VDC.\n'.format(chan=channel, volts=dcv))

        return dcv

    
    # Commands for HP34907 DIO/DAC card
    ########################################

    # Output specified voltage on specified DAC channel
    def setDAC(self, channel, voltage, verbosity = 1):

        if (channel < 1 or channel > 2):
            print('Invalid DAC channel number; must be 1 or 2.\n')
            return 0

        if (voltage < -12.0 or voltage > 12.0):
            print('Invalid DAC voltage value; must be within +/-12 volts.\n')
            return 0

        dac_channel = int(self.HP34907_channel + channel + 3)
        self.send_socket('SOURCE:VOLTAGE {volts}, (@{chan})\n'.format(volts=voltage, chan=dac_channel))    
        #self.send_socket('SOURCE:VOLTAGE {volts}, (@{chan})\r'.format(volts=voltage, chan=dac_channel))    

        if (verbosity > 1):
            print('DAC output channel {chan} set to {volts} VDC.\n'.format(chan=channel, volts=voltage))

        return 1


    # Query voltage setting on specified DAC channel
    def readDAC(self, channel, verbosity = 1):

        if (channel < 1 or channel > 2):
            print('Invalid DAC channel number; must be 1 or 2.\n')
            return 0

        dac_channel = int(self.HP34907_channel + channel + 3)
        self.send_socket('SOURCE:VOLTAGE? (@{chan})\n'.format(chan=dac_channel))    
        voltage = float(self.read_socket(verbosity=1))

        if (verbosity > 1):
            print('DAC output channel {chan} set to {volts} VDC.\n'.format(chan=channel, volts=voltage))

        return voltage

 
    # Write digital byte to specified DIO channel
    def writeByteDIO(self, channel, value, verbosity = 1):

        if (channel < 1 or channel > 2):
            print('Invalid DIO channel number; must be 1 or 2.\n')
            return 0

        dio_channel = int(self.HP34907_channel + channel)
        diovalue = ((value ^ 0xf) & 0xf)
        #self.send_socket('SOURCE:DIGITAL:DATA:BYTE {byte}, (@{chan})\n'.format(byte=diovalue, chan=dio_channel))    
        self.send_socket('SOURCE:DIGITAL:DATA:BYTE {byte}, (@{chan})\n'.format(byte=value, chan=dio_channel))    

        if (verbosity > 1):
            print('DIO output channel {chan} set to {val}.\n'.format(chan=channel, val=value))

        return 1


    # Read digital byte on specified DIO channel
    def readByteDIO(self, channel, verbosity = 1):

        if (channel < 1 or channel > 2):
            print('Invalid DIO channel number; must be 1 or 2.\n')
            return 0

        dio_channel = int(self.HP34907_channel + channel)
        self.send_socket('SOURCE:DIGITAL:DATA:BYTE? (@{chan})\n'.format(chan=dio_channel))    
        value = int(self.read_socket(verbosity=1))
        diovalue = ((value ^ 0xf) & 0xf)

        if (verbosity > 1):
            print('DIO output channel {chan} set to {val}.\n'.format(chan=channel, val=value))

        return value

    

class Keithley_2000(Device):
    # Note: Command terminator is a carriage-return character \r.
    # Settings as of 07/25/2017: Baud rate = 19200 bits/s, Stop bits = 1, Parity = None, Flow control = None
    # Moxa port 10: socket = 10.11.130.53:4010
    
    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,
                 name='Keithley_2000', parent=None, **kwargs):

        super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)

        #self.port_number = 10
        #self.server_port = 4000 + self.port_number
        self.connect_socket()

    # Essential socket interaction
    ########################################
        
    def connect_socket(self):
        
        #self.server_address= '10.11.130.51'
        #self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch
        self.server_address= '10.68.82.73'     # NEW IP, 20201112
        #self.server_IP = '10.11.129.2'
        self.port_number = 10
        self.server_port = 4000 + self.port_number
        
        import socket
        #self.sock = socket.socket()
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.server_address)
        self.sock.connect((self.server_address, self.server_port))
        
        self.sock.settimeout(0.5)
        
        
    def disconnect_socket(self):
        
        self.sock.close()
    
        
    def send_socket(self, msg):
        
        #self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return
        self.sock.send(msg.encode('ascii', 'ignore'))
        #self.sock.send(msg.encode('utf-8'))


    def send_get_reply(self, msg, verbosity=3):
        
        #self.send_socket('\r')
        self.send_socket(msg)
        
        time.sleep(0.5)
        
        return self.read_socket(verbosity=verbosity)
    
        
    def read_socket(self, timeout_s=3, verbosity=3):
        
        start_time = time.time()
        terminator = chr(0x18)
    
        # Look for the response
        amount_received = 0
        amount_cutoff = 5000
        
        txt = ''
        msg_received = ''
        
        while terminator not in txt and time.time()-start_time<timeout_s and amount_received<amount_cutoff:
            try:
                data = self.sock.recv(1)
            except:
                break
                                    
            amount_received += len(data)
            txt = data.decode('ascii')
            
            msg_received += txt
            
        msg_received = msg_received.replace(terminator, '')
        
        if time.time()-start_time>timeout_s:
            if verbosity>=1:
                print('Read timeout after {:.1f} s.'.format(time.time()-start_time))
            return ''
        
        else:
            if verbosity>=2:
                print(msg_received)
            return msg_received


    # Select the channel for reading 
    def selectChannel(self, channel, verbosity = 1):
         
        if (channel < 1 or channel > 10):
            print('Invalid channel number; must be between 1 and 10.\n')
            return 0

        self.send_socket(':ROUT:CLOS (@{chan})\r'.format(chan=channel))    

        if (verbosity > 1):
            print('Keithley 2000 channel set to {chan}.\n'.format(chan=channel))

        return 1


    # Read resistance on the selected channel
    def readOhm(self, channel, verbosity = 1):

        self.selectChannel(channel, verbosity=1)
        time.sleep(0.2)
        self.send_socket(':SENS:FUNC \'RES\'\r')    
        time.sleep(0.1)
        self.send_socket(':SENS:DATA?\r')    
        time.sleep(0.1)
        ohm = float(self.read_socket(verbosity=1))

        if (verbosity > 1):
            print('The resistance on channel {chan} is {res} Ohm.\n'.format(chan=channel, res=ohm))

        return ohm


    # Read DC voltage on the selected channel
    def readDCV(self, channel, verbosity = 1):

        self.selectChannel(channel, verbosity=1)
        time.sleep(0.2)
        self.send_socket(':SENS:FUNC \'VOLT:DC\'\r')    
        time.sleep(0.1)
        self.send_socket(':SENS:DATA?\r')    
        time.sleep(0.1)
        dcv = float(self.read_socket(verbosity=1))

        if (verbosity > 1):
            print('The DC voltage on channel {chan} is {volts} VDC.\n'.format(chan=channel, volts=dcv))

        return dcv


    # Read 30 kOhm thermistor on the selected channel and return T[degC] 
    def readThermister30kohm(self, channel, verbosity = 1):

        ohm = self.readOhm(channel, verbosity=1)

        coeff_a = 0.000932681
        coeff_b = 0.000221455
        coeff_c = 0.000000126

        Temp = coeff_a;
        Temp += coeff_b * numpy.log(ohm)
        Temp += coeff_c * (numpy.log(ohm))**3
        Temp = 1.0/Temp - 273.15

        if (verbosity > 1):
            print('The temperature (30k-ohm thermistor) on channel {chan} is {degC} degC.\n'.format(chan=channel, degC=Temp))

        return Temp


    # Read 100 kOhm thermistor on the selected channel and return T[degC] 
    def readThermister100kohm(self, channel, verbosity = 1):

        ohm = self.readOhm(channel, verbosity=1)

        coeff_a = 0.000827094
        coeff_b = 0.000204256
        coeff_c = 1.15042e-07

        Temp = coeff_a;
        Temp += coeff_b * numpy.log(ohm)
        Temp += coeff_c * (numpy.log(ohm))**3
        Temp = 1.0/Temp - 273.15

        if (verbosity > 1):
            print('The temperature (100k-ohm thermistor) on channel {chan} is {degC} degC.\n'.format(chan=channel, degC=Temp))

        return Temp


    # Read Pt100 RTD on the selected channel and return T[degC] 
    def readPt100(self, channel, verbosity = 1):

        ohm = self.readOhm(channel, verbosity=1)

        # Conversion formula from: 
        # http://www.mosaic-industries.com/embedded-systems/microcontroller-projects/temperature-measurement/platinum-rtd-sensors/resistance-calibration-table
        c0 = -245.19
        c1 = 2.5293
        c2 = -0.066046 
        c3 = 4.0422e-3
        c4 = -2.0697e-6 
        c5 = -0.025422 
        c6 = 1.6883e-3 
        c7 = -1.3601e-6 

        Temp = ohm * (c1 + ohm * (c2 + ohm * (c3 + c4 * ohm)))
        Temp /= 1.0 + ohm * (c5 + ohm * (c6 + c7 * ohm))
        Temp += c0

        if (verbosity > 1):
            print('The temperature (Pt100 RTD) on channel {chan} is {degC} degC.\n'.format(chan=channel, degC=Temp))

        return Temp



class TTL_control(object):
    '''
    Uses the 2 8-bit DIO channels on Agilent34970A
    Note: agilent = Agilent_34970A(), unit = Agilent DIO channel number, port 1 = bit 1, etc.
    Note: If there is an error reading or setting, try to read/write to Agilent DIO channels directly first, and it should start working.
    '''

    def __init__(self, name='TTL_control', description="", pv=None, **args):
        
        self.name=name
        self.description=description
        
        
    def readPort(self, unit, port, verbosity=2):

        if (unit < 1 or unit > 2):
            print('Invalid TTL unit number; must be 1 or 2.\n')
            return 0

        if (port < 1 or port > 8):
            print('Invalid TTL port number; must be between 1 and 8.\n')
            return 0

        value = agilent.readByteDIO(unit, verbosity=1)
        bit_pos = int(port)
        onoff = int(bin(value)[2:].zfill(8)[-bit_pos])

        if (verbosity > 1):
            print('TTL unit {uu} port {pp} is currently set to {oo}.\n'.format(uu=unit, pp=bit_pos, oo=onoff))

        return onoff


    def readPorts(self, unit, verbosity=2):

        if (unit < 1 or unit > 2):
            print('Invalid TTL unit number; must be 1 or 2.\n')
            return 0

        value = agilent.readByteDIO(unit, verbosity=1)
        bits = [] 
        for i in range(1,8+1):
            #b = self.readPort(unit, i, verbosity=verbosity)
            b = int(bin(value)[2:].zfill(8)[-i]) 
            bits.append(b)            

        if (verbosity > 1):
            print('TTL unit {uu} ports 1-8 are currently set to {ll}.\n'.format(uu=unit, ll=bits))

        return value


    def setPort(self, unit, port, onoff, verbosity=2):

        if (unit < 1 or unit > 2):
            print('Invalid TTL unit number; must be 1 or 2.\n')
            return 0

        if (port < 1 or port > 8):
            print('Invalid TTL port number; must be between 1 and 8.\n')
            return 0
        
        # check the current setting and don't do anything if already set as requested
        b = self.readPort(unit, port, verbosity=1)
        if (onoff == b):
            if (verbosity > 1):
                print('TTL unit {uu} port {pp} is already set to {oo}.\n'.format(uu=unit, pp=port, oo=onoff))
            return 0
           
        value = agilent.readByteDIO(unit, verbosity=1)
        bit_pos = int(port)
        if (onoff == 1):
            value += 2**(bit_pos-1)
        elif (onoff == 0):
            value -= 2**(bit_pos-1)
        else:
            pass
        
        agilent.writeByteDIO(unit, value, verbosity=1)
        b_new = self.readPort(unit, port, verbosity=1)
        if (b_new != onoff):
            print('ERROR: TTL unit {uu} port {pp} is still set to {oo}.\n'.format(uu=unit, pp=port, oo=b_new))
            return 0
        else:
            if (verbosity > 1):
                print('TTL unit {uu} port {pp} has been set to {oo}.\n'.format(uu=unit, pp=port, oo=b_new))
            return 1
    

    def setPortOn(self, unit, port, verbosity=2):
        
        return self.setPort(unit, port, 1, verbosity=verbosity)


    def setPortOff(self, unit, port, verbosity=2):
        
        return self.setPort(unit, port, 0, verbosity=verbosity)


class Minichiller(Device):
    # Note: Command terminator is a carriage-return character \r.
    # Settings as of 10/09/2017: Baud rate = 9600 bits/s, Stop bits = 1, Parity = None, Flow control = None
    # Moxa port 11: socket = 10.11.130.53:4011
    
    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,
                 name='Minichiller', parent=None, **kwargs):

        super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)

        #self.port_number = 11
        #self.server_port = 4000 + self.port_number
        self.connect_socket()

    # Essential socket interaction
    ########################################
        
    def connect_socket(self):
        
        #self.server_address= '10.11.130.51'
        #self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch
        self.server_address= '10.68.82.73'     # NEW IP, 20201112
        #self.server_IP = '10.11.129.2'
        self.port_number = 11
        self.server_port = 4000 + self.port_number
        
        import socket
        #self.sock = socket.socket()
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.server_address)
        self.sock.connect((self.server_address, self.server_port))
        
        self.sock.settimeout(0.5)
        
        
    def disconnect_socket(self):
        
        self.sock.close()
    
        
    def send_socket(self, msg):
        
        #self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return
        self.sock.send(msg.encode('ascii', 'ignore'))
        #self.sock.send(msg.encode('utf-8'))


    def send_get_reply(self, msg, verbosity=3):
        
        #self.send_socket('\r')
        self.send_socket(msg)
        
        time.sleep(0.5)
        
        return self.read_socket(verbosity=verbosity)
    
        
    def read_socket(self, timeout_s=3, verbosity=3):
        
        start_time = time.time()
        terminator = chr(0x18)
    
        # Look for the response
        amount_received = 0
        amount_cutoff = 5000
        
        txt = ''
        msg_received = ''
        
        while terminator not in txt and time.time()-start_time<timeout_s and amount_received<amount_cutoff:
            try:
                data = self.sock.recv(1)
            except:
                break
                                    
            amount_received += len(data)
            txt = data.decode('ascii')
            
            msg_received += txt
            
        msg_received = msg_received.replace(terminator, '')
        
        if time.time()-start_time>timeout_s:
            if verbosity>=1:
                print('Read timeout after {:.1f} s.'.format(time.time()-start_time))
            return ''
        
        else:
            if verbosity>=2:
                print(msg_received)
            return msg_received

    # Output specified voltage on specified DAC channel
    def setTemp(self, degC, verbosity = 1):

        if degC < 0:
            sign='-'
        else:
            sign='+'

        if abs(degC) >= 10.0 and degC < 100.0:
            sign+='0'
        if abs(degC) >= 0.0 and degC < 10.0:
            sign+='00'
        if abs(degC) >= 0.1 and degC < 1.0:
            sign+='000'
        if abs(degC) >= 0.01 and degC < 0.10:
            sign+='0000'

        temperature = abs(int(degC * 100))

        self.send_socket('SP@{s}{temp}\r\n'.format(s=sign, temp=temperature))    

        if (verbosity > 1):
            self.readTemp(verbosity=verbosity)

        return 1


    # Query temperature in degC
    def readTemp(self, verbosity = 1):

        self.send_socket('SP?\r\n')    
        degC_raw = self.read_socket(verbosity=1)
        degC = int(degC_raw[2:])/100.0

        if (verbosity > 1):
            print('Temperature setpoint is set to {tt} degC.\n'.format(tt=degC))

        return degC

class SyringePump(Device):
    # Note: Command terminator is a carriage-return character \r.
    # Settings as of 12/09/2017: Baud rate = 9600 bits/s, Stop bits = 1, Parity = None, Flow control = None
    # Moxa port 11: socket = 10.11.130.53:4011
    
    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,
                 name='Minichiller', parent=None, **kwargs):

        super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)

        #self.port_number = 11
        #self.server_port = 4000 + self.port_number
        self.connect_socket()

    # Essential socket interaction
    ########################################
        
    def connect_socket(self):
        
        #self.server_address= '10.11.130.51'
        #self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch
        self.server_address= '10.68.82.73'     # NEW IP, 20201112
        #self.server_IP = '10.11.129.2'
        self.port_number = 11
        self.server_port = 4000 + self.port_number
        
        import socket
        #self.sock = socket.socket()
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(self.server_address)
        self.sock.connect((self.server_address, self.server_port))
        
        self.sock.settimeout(0.5)
        
        
    def disconnect_socket(self):
        
        self.sock.close()
    
        
    def send_socket(self, msg):
        
        #self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return
        self.sock.send(msg.encode('ascii', 'ignore'))
        #self.sock.send(msg.encode('utf-8'))


    def send_get_reply(self, msg, verbosity=3):
        
        #self.send_socket('\r')
        self.send_socket(msg)
        
        time.sleep(0.5)
        
        return self.read_socket(verbosity=verbosity)
    
        
    def read_socket(self, timeout_s=3, verbosity=3):
        
        start_time = time.time()
        terminator = chr(0x18)
    
        # Look for the response
        amount_received = 0
        amount_cutoff = 5000
        
        txt = ''
        msg_received = ''
        
        while terminator not in txt and time.time()-start_time<timeout_s and amount_received<amount_cutoff:
            try:
                data = self.sock.recv(1)
            except:
                break
                                    
            amount_received += len(data)
            txt = data.decode('ascii')
            
            msg_received += txt
            
        msg_received = msg_received.replace(terminator, '')
        
        if time.time()-start_time>timeout_s:
            if verbosity>=1:
                print('Read timeout after {:.1f} s.'.format(time.time()-start_time))
            return ''
        
        else:
            if verbosity>=2:
                print(msg_received)
            return msg_received

    #TODO:command input, including setting of speed and direction, inject , purge....
    # Output specified voltage on specified DAC channel
    def setTemp(self, degC, verbosity = 1):

        if degC < 0:
            sign='-'
        else:
            sign='+'

        if abs(degC) >= 10.0 and degC < 100.0:
            sign+='0'
        if abs(degC) >= 0.0 and degC < 10.0:
            sign+='00'
        if abs(degC) >= 0.1 and degC < 1.0:
            sign+='000'
        if abs(degC) >= 0.01 and degC < 0.10:
            sign+='0000'

        temperature = abs(int(degC * 100))

        self.send_socket('SP@{s}{temp}\r\n'.format(s=sign, temp=temperature))    

        if (verbosity > 1):
            self.readTemp(verbosity=verbosity)

        return 1


    # Query temperature in degC
    def readTemp(self, verbosity = 1):

        self.send_socket('SP?\r\n')    
        degC_raw = self.read_socket(verbosity=1)
        degC = int(degC_raw[2:])/100.0

        if (verbosity > 1):
            print('Temperature setpoint is set to {tt} degC.\n'.format(tt=degC))

        return degC


#agilent = Agilent_34970A()
##keithley = Keithley_2000()
#ttl = TTL_control()
##Sypump = SringePump()
##chiller = Minichiller()

def flow_off():
    agilent.setDAC(1,0.0)
    if agilent.readDAC(1) != 0.0:
        print('Gas flow is turned off.')

def flow_max():
    agilent.setDAC(1,3.5)
    print('Gas flow is set to MAX.')
def flow_on(voltage=1):
    agilent.setDAC(1,voltage)
    print('Voltage is set as {}. Please check the flow rate from flow meter.'.format(agilent.readDAC(1)))    

#XF:11BMB-CT{DIODE-Local:3}OutCh00:Data-SP

# PV list of Diode box: AO, Analog Output
#class Diode_AIpv(object):    
    #def __init__(self, ii):
        #self.name = 'AI_Chan{}'.format(ii)
        #self.sts = 'XF:11BMB-ES{}AI:{}-I'.format('{IO}', ii)
#Diode_AI=[None]
#for ii in range(1, 9):
    #Diode_AI.append(AIpv(ii))

    
Diode_AO=EpicsSignal('XF:11BMB-CT{DIODE-Local:3}OutCh00:Data-SP')
Diode_A1=EpicsSignal('XF:11BMB-CT{DIODE-Local:3}OutCh01:Data-SP')
Diode_A2=EpicsSignal('XF:11BMB-CT{DIODE-Local:3}OutCh02:Data-SP')
Diode_A3=EpicsSignal('XF:11BMB-CT{DIODE-Local:3}OutCh03:Data-SP')
#caput('XF:11BMB-CT{DIODE-Local:3}OutCh00:Data-SP.DESC', 'Diode AO 1')
#Diode_AO.get()
#Diode_AO.set()

    import time
from ophyd import Device
# Moxa ioLogik and MFC controller
# Moxa: AO E1241, IP: 10.11.130.111    Chan1-4
# Moxa: DIO E1214, IP: 10.11.130.112   Chan1-6   with relay
# Moxa: RTD  E1260, IP: 10.11.130.113  Chan1-6   reading only
# Moxa: Thermal Couple  E1241, IP: 10.11.130.114   Chan1-8  reading only
# Moxa: AO E1241, IP: 10.11.130.115   Chan5-8
# Moxa: AI E1240, IP: 10.11.130.116   Chan1-8    reading only 

# MFC: 


#20210907, change the AI/AO/DIO Moxa boxes to Ecat channels. 
#add TTL signals, see more in 19_shutter.py


# PV list of Moxa ioLogik:: AO, Analog Output
class AOpv(object):    
    def __init__(self, ii):
        self.name = 'AO_Chan{}'.format(ii)
        # self.sp = 'XF:11BM-ES{{Ecat:AO{}}}'.format(ii)
        self.sp = 'XF:11BM-ES{{Ecat:AO1}}{}'.format(ii)
        # self.sts = 'XF:11BMB-ES{}AO:{}-RB'.format('{IO}', ii)
        self.sts = self.sp
        # self.name = 'AO_Chan{}'.format(ii)
        # self.sp = 'XF:11BMB-ES{}AO:{}-SP'.format('{IO}', ii)
        # self.sts = 'XF:11BMB-ES{}AO:{}-RB'.format('{IO}', ii)
AO=[None]
for ii in range(1, 5):
    AO.append(AOpv(ii))

# PV list of Moxa ioLogik:: AI, Analog Input
class AIpv(object):    
    def __init__(self, ii):
        self.name = 'AI_Chan{}'.format(ii)
        # self.sts = 'XF:11BM-ES{Ecat:AI1_1}'
        self.sts = 'XF:11BM-ES{{Ecat:AI{}}}'.format(ii)
        # self.sp = 'XF:11BMB-ES{}AI:{}-SP'.format('{IO}', ii)
        
AI=[None]
for ii in range(1, 9):
    AI.append(AIpv(ii))

# PV list of Moxa ioLogik:: DO(Relay), Digital Output
class Relaypv(object):    
    def __init__(self, ii):
        self.name = 'Relay_Chan{}'.format(ii)
        self.sp = 'XF:11BMB-ES{}DO:{}-Cmd'.format('{IO}', ii)
        self.sts = 'XF:11BMB-ES{}DO:{}-Sts'.format('{IO}', ii)
Relay=[None]
for ii in range(1, 7):
    Relay.append(Relaypv(ii))

# PV list of Moxa ioLogik:: DI, Digital Input
class DIpv(object):    
    def __init__(self, ii):
        self.name = 'DI_Chan{}'.format(ii)
        self.sts = 'XF:11BMB-ES{}DI:{}-Sts'.format('{IO}', ii)
DI=[None]
for ii in range(1, 7):
    DI.append(DIpv(ii))

#PV list of Moxa ioLogik:: RTD
class RTDpv(object):    
    def __init__(self, ii):
        self.name = 'RTD_Chan{}'.format(ii)
        self.sts = 'XF:11BMB-ES{}T:{}-I'.format('{IO:RTD}', ii)
        
RTD=[None]
for ii in range(1, 7):
    RTD.append(RTDpv(ii))

# PV list of Moxa ioLogik:: TC, Thermal Couple
class TCpv(object):    
    def __init__(self, ii):
        self.name = 'TC_Chan{}'.format(ii)
        self.sts = 'XF:11BMB-ES{}T:{}-I'.format('{IO:TC}', ii)
TC=[None]
for ii in range(1, 7):
    TC.append(TCpv(ii))


#Format: ioL.read(RTD[2]), ioL.set(AO[1], 5), ioL.setOn(Relay[1]), ioL.setOff([Relay[2])

class ioLogik(Device):
    
    def __init__(self, prefix='', *args, read_attrs=None, configuration_attrs=None,name='ioLogik', parent=None, **kwargs):

        super().__init__(prefix=prefix, *args, read_attrs=read_attrs, configuration_attrs=configuration_attrs, name=name, parent=parent, **kwargs)
    
    def read(self, port):
        if port is not None and port in AO+AI+RTD+TC+Relay+DI:
            return caget(port.sts)
        else:
            print('The port is not valid')
            
    def set(self, port, val, verbosity=3):
        if port is not None and port in AO:
            if val >10 or val <0:
                print('Out of input range. It must be in range of (0, 10).')
                return caput(port.sp, 0)
            else:
                caput(port.sp, val)
                if verbosity >=3:
                    time.sleep(0.2)
                    return print('The {} is set as {}.'.format(port.name, self.read(port)))
        else:
            print('The port is not valid.')
    
    def setOn(self, port):
        if port is not None and port in Relay:
            caput(port.sp, 1)
            #re-check the port value
            if self.read(port)==1:
                print('{} is turned on.'.format(port.name))
            else:
                print('{} is turned off.'.format(port.name))
        else:
            print('The port is not valid')

    def setOff(self, port):
        if port is not None and port in Relay:
            caput(port.sp, 0)
            time.sleep(.2)
            if self.read(port)==1:
                print('{} is turned on.'.format(port.name))
            else:
                print('{} is turned off.'.format(port.name))
        else:    
            print('The port is not valid')
            
    def readRH(self, AI_chan, temperature=25.0, voltage_supply=5.0, coeff_slope=0.030, coeff_offset=0.787, verbosity=3):
        voltage_out = self.read(AI[AI_chan])
        corr_voltage_out = voltage_out * (5.0 / voltage_supply)
        #For sensor #220 used for SVA chamber
        #coeff_offset = 0.788 #from the certificate
        #coeff_offset = 0.746 #from the environment of RH=0
        #coeff_slope = 0.029

        #For sensor used for Linkam tensile stage
        #coeff_offset = 0.787
        #coeff_slope = 0.030

        #For sensor 114 used for environmental bar
        #coeff_offset = 0.787
        #coeff_slope = 0.030

        #For sensor 43 used in humidity stage
        # coeff_offset = 0.816887
        # coeff_slope = 0.028813



        #Sensor 43 is broken. For sensor 42 used in humidity stage
        coeff_offset = 0.814
        coeff_slope = 0.029

        sensor_RH = (corr_voltage_out - coeff_offset) / coeff_slope

        true_RH = sensor_RH / (1.0546 - 0.00216 * temperature)      # T in [degC]
        
        if verbosity >= 3:
            print('Raw sensor RH = {:.3f} pct.'.format(sensor_RH))
            print('T-corrected RH = {:.3f} pct at {:.3f} degC.'.format(true_RH, temperature))
        return true_RH


# MFC PVs: 
#FlowRate_Sts = 'XF:11BMB-ES{FC:1}F-I'
#FlowRate_SP = 'XF:11BMB-ES{FC:1}F:SP-SP'
#Mode_Sts = 'XF:11BMB-ES{FC:1}Mode:Opr-Sts'
#Mode_SP = 'XF:11BMB-ES{FC:1}Mode:Opr-Sel'
#ScaleFactor_SP = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-SP'
#ScaleFactor_Sts = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-RB'
#NominalRange_SP = 'XF:11BMB-ES{FC:1}F:FullRng-SP'
#NominalRange_Sts = 'XF:11BMB-ES{FC:1}F:FullRng-RB'

#FlowRate_Sts = 'XF:11BMB-ES{FC:1}F-I'
#FlowRate_SP = 'XF:11BMB-ES{FC:1}F:SP-SP'
#Mode_Sts = 'XF:11BMB-ES{FC:1}Mode:Opr-Sts'
#Mode_SP = 'XF:11BMB-ES{FC:1}Mode:Opr-Sel'
#ScaleFactor_SP = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-SP'
#ScaleFactor_Sts = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-RB'
#NominalRange_SP = 'XF:11BMB-ES{FC:1}F:FullRng-SP'
#NominalRange_Sts = 'XF:11BMB-ES{FC:1}F:FullRng-RB'
                  
class MassFlowControl(Device):
    
    def __init__(self):
        pass
        #self.FlowRate_Sts = 'XF:11BMB-ES{FC:1}F-I'
        #self.FlowRate_SP = 'XF:11BMB-ES{FC:1}F:SP-SP'
        #self.Mode_Sts = 'XF:11BMB-ES{FC:1}Mode:Opr-Sts'
        #self.Mode_SP = 'XF:11BMB-ES{FC:1}Mode:Opr-Sel'
        #self.ScaleFactor_SP = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-SP'
        #self.ScaleFactor_Sts = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-RB'
        #self.NominalRange_SP = 'XF:11BMB-ES{FC:1}F:FullRng-SP'
        #self.NominalRange_Sts = 'XF:11BMB-ES{FC:1}F:FullRng-RB'

    def setDevice(self, device='A1'):
        
        if device == 'A1':
            device_no = 1
        elif device == 'A2':
            device_no = 2 
        elif device == 'B1':
            device_no = 3
        elif device == 'B2':
            device_no = 4 
        else:
            print('The device is NOT valid.')
            device_no = 1
        print('Select Device {} in port {}'.format(device_no, device))
        self.FlowRate_Sts = 'XF:11BMB-ES{{FC:{}}}F-I'.format(device_no)
        self.FlowRate_SP = 'XF:11BMB-ES{{FC:{}}}F:SP-SP'.format(device_no)
        self.Mode_Sts = 'XF:11BMB-ES{{FC:{}}}Mode:Opr-Sts'.format(device_no)
        self.Mode_SP = 'XF:11BMB-ES{{FC:{}}}Mode:Opr-Sel'.format(device_no)
        self.ScaleFactor_SP = 'XF:11BMB-ES{{FC:{}}}Val:ScaleFactor-SP'.format(device_no)
        self.ScaleFactor_Sts = 'XF:11BMB-ES{{FC:{}}}Val:ScaleFactor-RB'.format(device_no)
        self.NominalRange_SP = 'XF:11BMB-ES{{FC:{}}}F:FullRng-SP'.format(device_no)
        self.NominalRange_Sts = 'XF:11BMB-ES{{FC:{}}}F:FullRng-RB'.format(device_no)
        
        return device_no
    
    def setFlow(self, device, rate, tolerence=1, verbosity=3):
        #set the setpoint of flow
        self.setDevice(device=device)
        caput(self.FlowRate_SP, rate)
        if verbosity >= 3:
            print('The flow rate has been set to {}'.format(rate))
            print('The current flow rate is {}'.format(caget(self.FlowRate_Sts)))
        return caget(self.FlowRate_Sts)
    
    def flow(self, device, verbosity=3):
        self.setDevice(device=device)
        if verbosity >= 3:
            print('The current flow rate is {}'.format(caget(self.FlowRate_Sts)))
        return caget(self.FlowRate_Sts)
        
    def setMode(self, device, mode, verbosity=3):
        #mode can be 0: OPEN, 1: Close, 2: SetPoint

        self.setDevice(device=device)

        if mode not in range(0, 3):
            return print('The input has to be 0: OPEN, 1: Close, 2: SetPoint')
        else:            
            caput(self.Mode_SP, mode)
            while self.mode(device=device) != mode:
                time.sleep(1)
                caput(self.Mode_SP, mode)
            if verbosity >=3:
                self.mode(device=device)
            return caget(self.Mode_Sts)
    
    def mode(self, device, verbosity=3):
        #OP mode: 0: OPEN, 1: Close, 2: SetPoint
        self.setDevice(device=device)
        if verbosity >= 3:
            self.readMode(device=device)
        return caget(self.Mode_Sts)
    
    def readMode(self, device, verbosity=3):
        #OP mode: 0: OPEN, 1: Close, 2: SetPoint
        self.setDevice(device=device)
        if caget(self.Mode_Sts)==0:
            return print('The current mode is {}'.format('ON'))
        if caget(self.Mode_Sts)==1:
            return print('The current mode is {}'.format('OFF'))
        if caget(self.Mode_Sts)==2:
            return print('The current mode is {}'.format('SETPOINT'))

    def scaleFactor(self, device, verbosity=3):
        #The scale factor depends on the gas. 
        #N2 and air are default as 1. Helium is 0.18.
        #More details are listed in the manual.
        self.setDevice(device=device)
        if verbosity >= 3:
            print('The scale factor is {}'.format(caget(self.ScaleFactor_Sts)))
        return caget(self.ScaleFactor_Sts)

    def setScaleFactor(self, device, val, verbosity=3):
        #Three modes: 0: OPEN, 1: Close, 2: SetPoint
        self.setDevice(device=device)

        caput(self.ScaleFactor_SP, val)
        while abs(self.scaleFactor() - val)>0.02:
            time.sleep(1)
            caput(self.ScaleFactor_SP, val)
        if verbosity >=3:
            self.scaleFactor()
        return caget(self.ScaleFactor_Sts)

    def deviceRange(self, device, verbosity=3):
        #Set the device by seting the Nominal Range. 
        #Model 201: 20SCCM. 
        self.setDevice(device=device)
        if verbosity >= 3:
            print('The range of this MFC device is up to {} SCCM.'.format(caget(self.NominalRange_Sts)))
        return caget(self.NominalRange_Sts)

    def setDeviceRange(self, device, val, verbosity=3):
        #Set the device by seting the Nominal Range. 
        #Model 201: 20SCCM. 
        self.setDevice(device=device)

        caput(self.NominalRange_SP, val)
        while abs(self.deviceRange() - val)>1:
            time.sleep(1)
            caput(self.NominalRange_SP, val)
        if verbosity >=3:
            self.deviceRange()
        return caget(self.NominalRange_Sts)            
            
        
    
ioL = ioLogik()
MFC = MassFlowControl()

class PhotoThermalAnnealer():
    
    def __init__(self, print_code='PTA> '):
        
        self.controlTTL_PV = 'XF:11BMB-ES{IO}AO:3-SP'
        self.powerV_PV = 'XF:11BMB-ES{IO}AO:4-SP'
        
        self.print_code = print_code
        #if verbosity>=3:
            #print('{}'.format(self.print_code))
        
        self.laserOff()
        
        self._use_calibration_NoFlow()
        #self._use_calibration_N2()
        
        #self.laser_calib_m, self.laser_calib_b, self.power_limit_low = 7.4632, -5.8773, 0.13 # BNL 70W IR Laser factory calibration (2019-Mar)
        self.laser_calib_m, self.laser_calib_b, self.power_limit_low = 7.5376, -6.9667, 0.38 # UW 70W IR Laser factory calibration (2019-Apr)
        
        #self.power_limit_high = 65.1 # For RTP
        self.power_limit_high = 70.0 # For LZA
    
    
    def linear_regression(self, data, verbosity=3):
        #import numpy as np
        from scipy import stats
        slope, intercept, r_value, p_value, std_err = stats.linregress(np.asarray(data)[:,0], np.asarray(data)[:,1])
        if verbosity>=5:
            print("    m = {:.3f} ; b = {:.3f} [R = {:.2f}]".format(slope, intercept, r_value))
        
        return slope, intercept, r_value
    
        
    # Laser control
    ########################################
    
    def laserOn(self):
        caput(self.controlTTL_PV, 5)

    def laserOff(self):
        caput(self.controlTTL_PV, 0)
        
    def laserPulse(self, duration):
        self.laserOn()
        print('{}  Laser on for {:.2f} s'.format(self.print_code, float(duration)))
        time.sleep(duration)
        self.laserOff()
        print('{}  Laser off'.format(self.print_code))
        
    def off(self):
        self.laserOff()
        
    def getVoltage(self, verbosity=3):
        
        Voltage = float(caget(self.powerV_PV))
        power_W = self.laser_calib_m*Voltage + self.laser_calib_b
        
        if verbosity>=3:
            print('{}    Voltage = {:.2f} V ({:.2f} W)'.format(self.print_code, Voltage, power_W))
        
        return Voltage
    
    def getLaserPower(self, verbosity=3):
        
        Voltage = float(caget(self.powerV_PV))
        power_W = self.laser_calib_m*Voltage + self.laser_calib_b
        
        if verbosity>=3:
            print('{}    Power = {:.2f} W ({:.2f} V)'.format(self.print_code, power_W, Voltage))
        
        return power_W
        
    def setLaserPower(self, power_W, verbosity=3):
        
        if power_W>=self.power_limit_high:
            print("{}Desired laser power must be less than {:.2f} W (your input was {:.2f} W).".format(self.print_code, self.power_limit_high, power_W))
            return
        
        if power_W<=self.power_limit_low:
            print("{}Desired laser power must be greater than {:.2f} W (your input was {:.2f} W).".format(self.print_code, self.power_limit_low, power_W))
            power_W = 0
            
        power_V = (power_W - self.laser_calib_b)/self.laser_calib_m

        if power_V>10.25 or power_V<0:
            print("{}Desired laser power ({:.2f} W) requires {:.2f} V, which is not possible.".format(self.print_code, power_W, power_V))
            return

        if verbosity>=3:
            print("{}Setting laser to {:.2f} W (using control voltage of {:.2f} V)".format(self.print_code, power_W, power_V))
        caput(self.powerV_PV, power_V)
        
        
        

    # Temperature calibration
    # (conversion from laser power into temperature)
    ########################################
        
    def _use_calibration_NoFlow(self, verbosity=3):
    
        # Normal RTP height, no air flow, open GISAXS windows
        # [ power_W, Temperature_C ] , # power_V
        data = [ 
            [0, 30.0] , # 0.0
            [10, 175.9] , # 2.13
            [12.43, 206.7] , # 2.45
            [15.0, 239.9] , # 2.80
            [16.38, 257.2] , # 2.98
            [18.35, 279.9] , # 3.25
            [20.0, 298.4] , # 3.47
            [25.0, 350.1] , # 4.14
            #[50.0, >400] , # 7.49
            ]
        
        m, b, r_value = self.linear_regression(data, verbosity=verbosity)
        if verbosity>=3:
            print("{}    Calibration updated to: m = {:.3f}°C/W; b = {:.3f}°C    [R = {:.2f}]".format(self.print_code, m, b, r_value))
        self.calibration_m, self.calibration_b = m, b
    
    
    def _use_calibration_N2(self, verbosity=3):
    
        # Normal RTP height, N2 flow, Kapton GISAXS windows
        # [ power_W, Temperature_C ] , # power_V
        data = [ 
            [0, 24.2] , # 0.0
            [9.24, 164.9] , # 2.02
            [10.79, 188.0] , # 2.23
            [10.79, 190.9] , # 2.23
            [12.34, 211.4] , # 2.44
            [13.89, 227] , # 2.65
            [15.44, 252] , # 2.65
            [16.99, 271] , # 3.06
            ]
        
        m, b, r_value = self.linear_regression(data, verbosity=verbosity)
        if verbosity>=3:
            print("{}    Calibration updated to: m = {:.3f}°C/W; b = {:.3f}°C    [R = {:.2f}]".format(self.print_code, m, b, r_value))
        self.calibration_m, self.calibration_b = m, b
        
    
    def getTemperature(self, verbosity=3):
        
        power_W = self.getLaserPower(verbosity=0)
        m, b = self.calibration_m, self.calibration_b # [°C/W] , [°C]
        T = m*power_W + b
        
        if verbosity>=3:
            print("{}Current set temperature is {:.2f}°C (using {:.2f} W)".format(self.print_code, T, power_W))
            if abs(int(caget(self.controlTTL_PV))-5)>0.1:
                print("{}  Note: Laser is not turned on.")

        return T
    
    def setTemperature(self, T_target, verbosity=3):
        
        m, b = self.calibration_m, self.calibration_b # [°C/W] , [°C]
        
        power_W = (T_target-b)/m
        
        if verbosity>=3:
            print("{}Setting temperature to {:.2f}°C".format(self.print_code, T_target))
        self.setLaserPower(power_W)
    
        if verbosity>=3:
            if abs(int(caget(self.controlTTL_PV))-5)>0.1:
                print("{}  Note: Laser is not turned on.")

    
    # RTP protocols
    ########################################
    
    def controlTemperature(self, T_target, adjust_strength=0.5, delay_time=0.1, adjust_clip=1, verbosity=3):

        m, b = self.calibration_m, self.calibration_b # [°C/W] , [°C]
        
        power_W_nominal = (T_target-b)/m
        
        power_W_current = power_W_nominal
        
        while True:
            T_current = 0 # TODO: Obtain T from beamline
            
            adjust = adjust_strength*m*( T_target-T_current )
            adjust = np.clip(adjust, adjust-adjust_clip, adjust+adjust_clip)
            
            if verbosity>=3:
                print("{}        T = {:.2f}°C; Adjusting laser power by {:+.2f} W (from {:.2f} W to {:.2f} W)".format( self.print_code, T_current, adjust, power_W_current, power_W_current+adjust ))
                
            power_W_current += adjust
            self.setLaserPower(power_W_current)
            
            time.sleep(delay_time)
        
    
    def jumpTemperature(self, T_target, T_current=30, dwell_time=None, ramp_usage_factor=0.80, ramp_power=50, rate_initial=None, verbosity=3):
        
        if rate_initial is None:
            # Calculate the expected rate from prior calibration
            
            # T_i = 35C, power_W = 50, rate_initial = (358.9-47.2)/(68.905-59.829) = 34.34 °C/s
            rate_initial = 35*(ramp_power/50)
            # T_i = 35C, power_W = 65, rate_initial = 42 °C/s
            #rate_initial = 42*(ramp_power/65)
        
        ramp_time = ramp_usage_factor*(T_target-T_current)/rate_initial
        
        if verbosity>=4:
            print("{}    ramp_time = {:.1f} s".format(self.print_code, ramp_time))
            
        
        # Fast ramp
        self.setLaserPower(ramp_power)
        start_time = time.time()
        self.laserOn()
        
        i = 0
        while (time.time()-start_time)<ramp_time:
            if verbosity>=3:
                current_time = time.time()-start_time
                if i%50==0:
                    print("{}  FAST RAMP @ {:.1f}°C/s to T = {:.1f}°C; {:.1f} s (ramp_time {:.1f} s) {:.1f}%".format(self.print_code, rate_initial, T_target, current_time, ramp_time, 100.*current_time/ramp_time ))
                
            i += 1
            time.sleep(0.01)            
            
        # Stabilize at desired temperature
        self.setTemperature(T_target, verbosity=verbosity)
        
        if dwell_time is not None:
            if verbosity>=3:
                print("{}  Holding at T = {:.1f}°C for {:.1f} s...".format(self.print_code, T_target, dwell_time))
            time.sleep(dwell_time)
            self.laserOff()
            if verbosity>=3:
                print("{}  Laser off.".format(self.print_code))
        

    # LZA helpers
    ########################################
    def msg(self, txt, priority=1, indent=0, indent_char='  '):
        indent_str = indent_char*(indent)
        
        txt = 'LZA> {}{}'.format(indent_str, txt)
        if priority>=1:
            print(txt)
    
    #def date_stamp(self, priority=1, indent=0):
        #self.log.date_stamp(priority=priority, indent=indent)
        
    def start_timing(self, predicted_duration):
        """Allows one to define the predicted length of time for an event (or sequence of events),
        so one can thereafter check on the progress."""
        
        self.timing = True
        self.timing_predicted_duration = predicted_duration
        self.timing_start_time = time.time()
        
    def end_timing(self):
        self.timing = False
        
    def is_timing(self):
        return self.timing
        
    def get_run_timing(self):
        return time.time() - self.timing_start_time

    def get_remain_timing(self):
        # Usage: time_left = self.get_remain_timing()
        return self.timing_predicted_duration - self.get_run_timing()
        
    def timing_txt(self):
        
        date_str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        time_left = self.get_remain_timing()
        
        hours = int( time_left / (60*60) )
        minutes = int( (time_left-hours*60*60) / (60) )
        seconds = time_left%60
        
        #txt = '%s (ETC: %02d:%02d:%02d)' % (date_str, hours, minutes, seconds)
        left_str = str( datetime.timedelta(seconds=round(time_left,0)) )
        txt = '%s (%s)' % (date_str, left_str)
        
        return txt
        
    def timing_msg(self, priority=2, indent=0 ):
        txt = self.timing_txt()
        self.msg( txt, priority=priority, indent=indent )
        
    def timing_prediction_txt(self, predicted_duration):
        
        finish = time.time() + predicted_duration
        date_str = datetime.datetime.fromtimestamp( finish ).strftime("%Y-%m-%d %H:%M:%S")
        
        time_left = predicted_duration
        
        hours = int( time_left / (60*60) )
        minutes = int( (time_left-hours*60*60) / (60) )
        seconds = time_left%60
        
        left_str = str( datetime.timedelta(seconds=round(time_left,0)) )
        txt = '%s (%s)' % (date_str, left_str)
        
        return txt



    # LZA annealing protocols
    ########################################
    
    def single_sweep(self, length, velocity, delay_at_end=0.1):
        '''LZA sweep by moving the sample.'''
        
        velocity = round(velocity, 4)
        
        self.msg( 'sweep %.1f mm (@ %.4f mm/s)' % (length, velocity), priority=1, indent=1)
        
        sweep_time = abs(length/velocity)
        #self.stage.move_relative( +length, velocity=velocity )
        #time.sleep( sweep_time + delay_at_end )
        
        #self.stage.move_relative_wait_stop( +length, velocity=velocity )
        
        self.laserOn()
        self.xr(length, velocity=velocity, wait=False)
        time.sleep(sweep_time)
        self.laserOff() 
        
        # Wait for stage to finish moving
        while smx.moving:
            time.sleep(0.05)

        time.sleep( delay_at_end )

    
    def single_sweep_laser(self, length,  velocity, start=None, delay_at_end=0.1):
        '''LZA sweep by moving the laser.'''
        #move laser head in x direction
        
        if start==None:
            laserx_origin=laserx.position
        else :
            laserx_origin=start+laserx.position
            self.laserx_speedreset()
            laserx.move(laserx_origin)
        
        velocity = round(velocity, 4)
        
        self.msg( 'sweep %.1f mm (@ %.4f mm/s)' % (length, velocity), priority=1, indent=1)
        
        sweep_time = abs(length/velocity)
        #self.stage.move_relative( +length, velocity=velocity )
        #time.sleep( sweep_time + delay_at_end )
        
        #self.stage.move_relative_wait_stop( +length, velocity=velocity )
        
        self.laserOn()
        self.laserxr(length, velocity=velocity, wait=False)
        time.sleep(sweep_time)
        self.laserOff() 
        
        # Wait for stage to finish moving
        while laserx.moving:
            time.sleep(0.05)

        time.sleep( delay_at_end )

    def double_sweep(self, length, velocity, delay_at_end=0.1):
        
        self.single_sweep( +length, velocity, delay_at_end=delay_at_end )
        self.single_sweep( -length, velocity, delay_at_end=delay_at_end )

    def double_sweep_laser(self, length, velocity, start=None, delay_at_end=0.1):
        
        self.single_sweep_laser( +length, velocity, start=start, delay_at_end=delay_at_end )
        self.single_sweep_laser( -length, velocity, start=None, delay_at_end=delay_at_end )
        



    def anneal_cyclic(self, length, velocity, num_cycles, delay_at_end=0.1):
        
        self.msg( 'Cycling Anneal (%.1fmm X %.1f, @ %.4f mm/s)' % (length, num_cycles, velocity) , 1 )
        
      
        # Predict how long the anneal will take
        predicted_duration = ( (length/velocity) + delay_at_end )*2*num_cycles # Stage motion
        #predicted_duration += ( self.stage.com_wait_time*2 )*2*num_cycles # Serial communications
        self.start_timing(predicted_duration)
        
        #finish = time.time() + predicted_duration
        #date_str = datetime.datetime.fromtimestamp( finish ).strftime("%Y-%m-%d %H:%M:%S")
        self.msg( 'Will finish at %s' % (self.timing_prediction_txt(predicted_duration)) , indent=1)
        
        
        
        fractional_sweeps = num_cycles - int(num_cycles)
        if fractional_sweeps==0.5:
            num_cycles = int(num_cycles-fractional_sweeps)
        elif fractional_sweeps!=0.0:
            self.error( 'Cannot interpret number of cycles (%f).' % (num_cycles) )
        
        
        # Anneal cycles
        for cycle in range(num_cycles):
            
            self.msg( 'Cycle #: %d/%d (%.1f%% done)' % (cycle+1, num_cycles, (100.0*cycle/num_cycles)) , 1 )
            #self.date_stamp(indent=1)
            if self.is_timing():
                self.timing_msg(indent=1)
            
            self.double_sweep( length, velocity, delay_at_end=delay_at_end )
            
        # Final sweep (if any)
        if fractional_sweeps==0.5:
            self.single_sweep( +length, velocity, delay_at_end=delay_at_end )
    
        self.end_timing()
        self.msg( 'Run complete (%s)' % (  datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") ) )
        
        
    def anneal_cyclic_laser(self, length, velocity, num_cycles, start=None, delay_at_end=0.1, x_step=0.05, measure_method=None, measures=None, cycles_done=0):
        
        self.msg( 'Cycling Anneal (%.1fmm X %.1f, @ %.4f mm/s)' % (length, num_cycles, velocity) , 1 )
        
        if measures is None:
            measures = [1, 2, 4, 8, 16]
        
        if start==None:
            laserx_origin=laserx.position
        else :
            laserx_origin=start+laserx.position
            self.laserx_speedreset()
            laserx.move(laserx_origin)
        
        velocity = round(velocity, 4)        
        # Predict how long the anneal will take
        predicted_duration = ( (length/velocity) + delay_at_end )*2*num_cycles # Stage motion
        #predicted_duration += ( self.stage.com_wait_time*2 )*2*num_cycles # Serial communications
        self.start_timing(predicted_duration)
        
        #finish = time.time() + predicted_duration
        #date_str = datetime.datetime.fromtimestamp( finish ).strftime("%Y-%m-%d %H:%M:%S")
        self.msg( 'Will finish at %s' % (self.timing_prediction_txt(predicted_duration)) , indent=1)
        
        
        
        fractional_sweeps = num_cycles - int(num_cycles)
        if fractional_sweeps==0.5:
            num_cycles = int(num_cycles-fractional_sweeps)
        elif fractional_sweeps!=0.0:
            self.error( 'Cannot interpret number of cycles (%f).' % (num_cycles) )
        
        
        # Anneal cycles
        for cycle in range(num_cycles):
            
            self.msg( 'Cycle #: %d/%d (%.1f%% done)' % (cycle+1, num_cycles, (100.0*cycle/num_cycles)) , 1 )
            #self.date_stamp(indent=1)
            if self.is_timing():
                self.timing_msg(indent=1)
            
            self.double_sweep_laser( length, velocity, start=None, delay_at_end=delay_at_end ) 
            
            # Do the GISAXS measurement
            if (cycle+1+cycles_done) in measures:
                if measure_method is None:
                    extra = '{:d}X'.format(cycle+1+cycles_done)
                    self.LZA_measure(extra=extra, x_step=x_step)
                else:
                    self.measure_method()
            
            
        # Final sweep (if any)
        if fractional_sweeps==0.5:
            self.single_sweep_laser(length, velocity, delay_at_end=delay_at_end )
    
        self.end_timing()
        self.msg( 'Run complete (%s)' % (  datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") ) )


    def LZA_measure(self, extra=None, incident_angles=None, exposure_time=10, x_step=0.05):
        sam.xr(x_step)
        if incident_angles is None:
            #incident_angles = sam.incident_angles_default
            incident_angles = [0.12]
        sam.measureIncidentAngles(incident_angles, exposure_time=exposure_time, extra=extra)
        
        
        
    def single_sweep_measure(self, length=4, velocity=0.1, delay_at_end=0.1, exposure_time=1, extra=None):
        '''LZA sweep by moving the sample.'''
        
        velocity = round(velocity, 4)
        
        self.msg( 'sweep %.1f mm (@ %.4f mm/s)' % (length, velocity), priority=1, indent=1)
        
        sweep_time = abs(length/velocity)
        #self.stage.move_relative( +length, velocity=velocity )
        #time.sleep( sweep_time + delay_at_end )
        
        #self.stage.move_relative_wait_stop( +length, velocity=velocity )
        
        cms.modeMeasurement()
        sam.thabs(0.12)
        
        print('Laser on')
        self.laserOn()
        
        #self.xr(length, velocity=velocity, wait=False) # Move stage
        self.laserxr(-length, velocity=velocity, wait=False) # Move laser
        start_time = time.time()
        
        #time.sleep(sweep_time)
        num_images = int( ( length/velocity )/(exposure_time+0.3) )
        sam.measure_burst(exposure_time=exposure_time, num_images=num_images, extra=extra)
        
        while (time.time()-start_time)<sweep_time:
            time.sleep(0.05)
        
        
        print('Laser off')
        self.laserOff() 
        
        # Wait for stage to finish moving
        while smx.moving:
            time.sleep(0.05)

        time.sleep( delay_at_end )        


    # Other measurement styles
    ########################################
    
    def thermal_gradient_T_conversion(self, position, power_fractional=1.00, T_ambient=25):
        
        T_est = 492 - abs(position)*24.7 # P_frac = 0.45
        T_est = 528 - abs(position)*26.6 # P_frac = 0.50
        T_est = 950 - abs(position)*53.2 # P_frac = 1.00
        
        #T_excess = (T_est-T_ambient)*(power_fractional/0.45)
        #T_est = T_excess + T_ambient
        #print(T_est)
        #T_est = 831.24*power_fractional + 118.68 - (43.958*power_fractional + 4.9539)*position
        #print(T_est)
        
        return T_est

    def thermal_gradient_getAlignment(self, position):
        
        # For sam.x() = 0.0; state = {'origin': {'x': -41.0, 'y': 15.14, 'th': 0.3978: , 'phi': 0.0}}
        # For sam.x() = -14.0; state = {'origin': {'x': -41.0, 'y': 15.18, 'th': 0.3664, 'phi': 0.0}}
        
        x1, y1 = [0, 14.99]
        x2, y2 = [-14, 15.18]
        m = (y2-y1)/(x2-x1)
        b = y1-m*x1
        
        return 0.0
    
    def thermal_gradient_measure(self, exposure_time=10, power_fractional=1.00, x_offset=0, x_step=-0.05, already_heated=0):
        
        
        testing = False
        
        positions = [0, -2, -4, -6]
        heating_times = [2]*10
        
        cms.modeMeasurement()
        
        print('thermal gradient annealing using P_frac = {:.2f}'.format(power_fractional))
        self.centerLaser()
        self.setLaserPower(68.5*power_fractional)
        
        
        for i, heating_time in enumerate(heating_times):
            total_time = np.sum(heating_times[:i+1]) + already_heated
            
            # Anneal sample
            print(' PTA will anneal sample for +{:.2f}s ({:.2f} s total)'.format(heating_time, total_time))
            if not testing:
                sam.xo()
                #self.centerLaser()
                self.laserOn()
                time.sleep(heating_time)
                self.laserOff()
                
                time.sleep(10)
            
            if i in [0, 1, 4, 9]:
                # Measure spots
                for position in positions:
                    T_est = self.thermal_gradient_T_conversion(position+x_offset)
                    print('     Sample move to {:.4f} mm (T_est = {:.1f}°C)'.format(position+x_offset, T_est ))
                    
                    extra = 'P{:.2f}T{:.1f}Ct{:.1f}s'.format(power_fractional, T_est, total_time)
                    print('      will append to filename: "{}"'.format(extra))
                    
                    if not testing:
                        sam.xabs(position)
                        sam.xr(x_offset)
                        
                        sam.measureIncidentAngle(0.12, exposure_time=exposure_time, extra=extra)
                    
                x_offset += x_step
            
            
        

    # PTA stage/motion control
    ########################################
    
    def xabs(self, position, velocity=None, wait=True):
        if position>+124 or position<-124:
            print('ERROR: Cannot move sample x to that position')
            return
        
        if velocity is not None:
            caput('XF:11BMB-ES{PTA:Sample-Ax:X}Mtr.VELO', float(velocity))
        #smx.move(position)
        caput('XF:11BMB-ES{PTA:Sample-Ax:X}Mtr.VAL', position, wait=wait)
            
    def xr(self, amount, velocity=None, wait=True):
        self.xabs(smx.position+amount, velocity=velocity, wait=wait)
        
    def laserxabs(self, position, velocity=None, wait=True):
        if position>+124 or position<-124:
            print('ERROR: Cannot move sample x to that position')
            return
        
        if velocity is not None:
            caput('XF:11BMB-ES{PTA:Laser-Ax:X}Mtr.VELO', float(velocity))

        caput('XF:11BMB-ES{PTA:Laser-Ax:X}Mtr.VAL', position, wait=wait)
            
    def laserx_speedreset(self):
        caput('XF:11BMB-ES{PTA:Laser-Ax:X}Mtr.VELO', 5)
        
    def laserxr(self, amount, velocity=None, wait=True):
        self.laserxabs(laserx.position+amount, velocity=velocity, wait=wait)
        
   #def laserxabs(self, position):
        #if position>0 and position<+120:
            #laserx.move(position)
        #else:
            #print('ERROR: Cannot move laser x to that position')
    
    #def laserxr(self, amount):
        #self.laserxabs( laserx.position + amount )

    def laseryabs(self, position):
        if position>-21 and position<=0:
            lasery.move(position)
        else:
            print('ERROR: Cannot move laser y to that position')
    
    def laseryr(self, amount):
        self.laseryabs( lasery.position + amount )

    def loadSample(self):
        print("1. Turning laser off")
        self.laserOff()
        
        print("2. Moving sample stage to loading position")
        self.xabs(+120.0, velocity=10)
        
        print("3. User: Set vacuum valve from 'pump' to 'vent'")
        print("4. User: Open laser box")
        
    def startSample(self):
        self.laserOff()
        self.xabs(-75, velocity=10)
        self.centerLaser()
        
    def centerLaser(self):
        self.laserxabs(-67.1, velocity=10)

    def checkLaser(self, duration=2, power_W=5):
        self.setLaserPower(power_W)
        self.laserPulse(duration)

#pta = PhotoThermalAnnealer()


# simple_template = """{{- start.plan_name }} ['{{ start.uid[:6] }}'] (scan num: {{ start.scan_id }})"""


# count_template = """{% if 'plan_header_override' in start -%}{{start.plan_header_override}}{% else %}{{start.plan_name}}{% endif %} {% if 'sample_savename' in start -%}{{start.sample_savename}}{% else %}{%if 'sample_name' in start -%}{{start.sample_name}}{% endif %}{% endif %} :  {{start.plan_args.num}} ['{{ start.uid[:6] }}'] (scan num: {{ start.scan_id }})

# Scan Plan
# ----------------------------------------
# {{ start.plan_type }}
# {%- for k, v in start.plan_args | dictsort %}
#     {{ k }}: {{ v }}
# {%-  endfor %}
# {% if 'signature' in start -%}
# Call:
#     {{ start.signature }}
# {% endif %}

# Metadata
# ----------------------------------------
# {% for k, v in start.items() -%}
# {%- if k not in ['plan_type', 'plan_args'] -%}{{ k }} : {{ v }}
# {% endif -%}
# {%- endfor %}



# """



# #single_motor_template = """{{- start.plan_name}} :  {{ start.motors[0]}} {{start.plan_args.start}} {{start.plan_args.stop}} {{start.plan_args.num}} ['{{ start.uid[:6] }}'] (scan num: {{ start.scan_id }})

# # FIX: remove start and stop motors for now in template. Need to fix
# #single_motor_template = """{% if 'plan_header_override' in start -%}{{start.plan_header_override}}{% else %}{{start.plan_name}}{% endif %} :  {{ start.motors[0]}}  {{'%0.3f' %start.plan_args.start|float}}    {{'%0.3f' %start.plan_args.stop|float}} {{start.plan_args.num}} ['{{ start.uid[:6] }}'] (scan num: {{ start.scan_id }})

# single_motor_template = """{% if 'plan_header_override' in start -%}{{start.plan_header_override}}{% else %}{{start.plan_name}}{% endif %} :  {{ start.motors[0]}}  {{start.plan_args.num}} ['{{ start.uid[:6] }}'] (scan num: {{ start.scan_id }})

# Scan Plan
# ----------------------------------------
# {{ start.plan_type }}
# {%- for k, v in start.plan_args | dictsort %}
#     {{ k }}: {{ v }}
# {%-  endfor %}
# {% if 'signature' in start -%}
# Call:
#     {{ start.signature }}
# {% endif %}

# Metadata
# ----------------------------------------
# {% for k, v in start.items() -%}
# {%- if k not in ['plan_type', 'plan_args'] -%}{{ k }} : {{ v }}
# {% endif -%}


# {%- endfor -%}

# """


# from collections import defaultdict
# TEMPLATES = defaultdict(lambda: simple_template)
# TEMPLATES['ct'] = count_template
# TEMPLATES['count'] = count_template
# TEMPLATES['scan'] = single_motor_template
# TEMPLATES['dscan'] = single_motor_template
# TEMPLATES['ascan'] = single_motor_template
# TEMPLATES['ID_calibration'] = single_motor_template

# #from jinja2 import Template # What is this needed for?

# # connect olog
# from functools import partial
# from pyOlog import SimpleOlogClient
# from bluesky.callbacks.olog import logbook_cb_factory

# # Set up the logbook. This configures bluesky's summaries of
# # data acquisition (scan type, ID, etc.).

# LOGBOOKS = ['Data Acquisition']  # list of logbook names to publish to
# simple_olog_client = SimpleOlogClient()
# generic_logbook_func = simple_olog_client.log
# configured_logbook_func = partial(generic_logbook_func, logbooks=LOGBOOKS)

# This is for ophyd.commands.get_logbook, which simply looks for
# a variable called 'logbook' in the global IPython namespace.

##RL comment all below out at 06/11/19 to disable the olog. Expecting the newer version to fix it from DAMA.
#logbook = simple_olog_client


##logbook_cb = logbook_cb_factory(configured_logbook_func)
#logbook_cb = logbook_cb_factory(configured_logbook_func, desc_dispatch=TEMPLATES)

## uncomment this for debugging and comment the next two lines
##RE.subscribe(logbook_cb)
#import nslsii
#nslsii.configure_olog(get_ipython().user_ns, callback=logbook_cb)
from nslsii.devices import TwoButtonShutter

class TwoButtonShutterNC(TwoButtonShutter):
    def stop(self, *args):
        ...

class TriState(Device):
    full = Cpt(TwoButtonShutterNC, 'V:1}')
    soft = Cpt(TwoButtonShutterNC, 'V:1_Soft}')
    def set(self, value):
        if value == 'Open':
            return self.full.set('Open') #& self.soft.set('Open')
        elif value == 'Soft':
            return self.soft.set('Open') & self.full.set('Close')
        elif value == 'Close':
            return self.full.set('Close') & self.soft.set('Close')
        else:
            raise ValueError("value must be in {'Open', 'Close', 'Soft'}")

#class TriState(Device):
    #full = Cpt(TwoButtonShutterNC, 'V:1}')
    #soft = Cpt(TwoButtonShutterNC, 'V:1_Soft}')
    #def set(self, value):
        #if value == 'Open':
            #return self.full.set('Open') #& self.soft.set('Open')
        #elif value == 'Soft':
            #return self.soft.set('Open') & self.full.set('Not Open')
        #elif value == 'Not Open':
            #return self.full.set('Not Open') & self.soft.set('Not Open')
        #else:
            #raise ValueError("value must be in {'Open', 'Not Open', 'Soft'}")


def tri_plan(tri, value):
    if value == 'Open':
        yield from bps.mov(tri.full, 'Open')
    elif value == 'Soft':
        yield from bps.mov(tri.full, 'Close')
        yield from bps.mov(tri.soft, 'Open')
    elif value == 'Close':
        yield from bps.mov(tri.full, 'Close')
        yield from bps.mov(tri.soft, 'Close')

#RE(tri_plan(dev_tri, 'Open'))

#dev_tri = TriState('XF:11BMB-VA{Chm:Smpl-V', name='dev')
#dev_tri.read()
#%mov dev_tri 'Soft'

'''
class Foo:
    @proerty
    def bob(self):
        self._n += 1
        return f'bob {self._n}
class Foo:
    @proerty
    def bob(self):
        self._n += 1
        return f'bob {self._n}'
    def __init__(self):
        self._n = 0


class Foo:
    @property
    def bob(self):
        self._n += 1
        return f'bob {self._n}'
    def __init__(self):
        self._n = 0
foo = Foo()
foo.bob
foo.bob
foo.bob
foo.bob
class Foo:
    @property
    def bob(self):
        self._n += 1
        return f'bob {self._n}'
    @bob.setter
    def bob(self. val):
        self._n = val

    def __init__(self):
        self._n = 0
class Foo:
    @property
    def bob(self):
        self._n += 1
        return f'bob {self._n}'
    @bob.setter
    def bob(self, val):
        self._n = val

    def __init__(self):
        self._n = 0
foo = Foo()
foo.bob
foo.bob
foo.bob = 0
foo.bob
class Foo:
    @property
    def bob(self):
        self._n += 1
        return f'bob {self._n}'
    def __init__(self):
        self._n = 0
foo = Foo()
foo.bob = 5
dev_tri.component_names
dev_tri.read_attrs
dev_tri.full.component_names
??dev_tri.read
bps.mov
? bps.mov
bps.sleep
bps.mv
bps.mov
%mov
%mv
%wa
%wa
class TriState(Device):
    full = Cpt(TwoButtonShutter, 'V:1}')
    soft = Cpt(TwoButtonShutter, 'V:1_Soft}')
    def set(self, value):
        if value == 'Open':
            return self.full.set('Open') & self.soft.set('Open')
        elif value == 'Soft':
            return self.full.set('Close') & self.soft.set('Open')
        elif value == 'Close':
            return self.full.set('Close') & self.soft.set('Close')
        else:
            raise ValueError("value must be in {'Open', 'Close', 'Soft'}")
dev_tri = TriState('XF:11BMB-VA{Chm:Smpl-V', name='dev')
dev_tri.set('Close')
dev_tri.set('Open')
dev_tri.set('Soft')

#dev = TwoButtonShutter('XF:11BMB-VA{Chm:Smpl-VV:1}', name='Smpl_pump')
#dev.set('Close')
#dev.set('Open')
#dev_soft = TwoButtonShutter('XF:11BMB-VA{Chm:Smpl-VV:1_soft}', name='Smpl_pump_soft')
#dev_soft.set('Open')
#dev_soft = TwoButtonShutter('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}', name='Smpl_pump_soft')
#dev_soft.set('Open')
#dev_soft.set('Close')
#dev_soft.set('Open')
#dev.set('Close')
#dev_soft.set('Close')
#dev.set('Open')
#dev_soft.set('Close')
'''#!/usr/bin/python
# -*- coding: utf-8 -*-
# vi: ts=4 sw=4




################################################################################
#  Code for querying and controlling beamline components that 'affect' the
# beam. (Beam energy, beam flux, etc.)
################################################################################
# Known Bugs:
#  N/A
################################################################################
# TODO:
#  Search for "TODO" below.
################################################################################


# Notes
################################################################################
# verbosity=0 : Output nothing
# verbosity=1 : Output only final (minimal) result
# verbosity=2 : Output 'regular' amounts of information/data
# verbosity=3 : Output all useful information
# verbosity=4 : Output marginally useful things (e.g. essentially redundant/obvious things)
# verbosity=5 : Output everything (e.g. for testing)



# These imports are not necessary if part of the startup sequence.
# If this file is called separately, some of these may be needed.
#import numpy as np
#from epics import caget, caput
#from time import sleep

#from ophyd import EpicsMotor, Device, Component as Cpt
#from ophyd.commands import * # For mov, movr

#define pilatus_name and _Epicsname, instead of pilatus300 or pilatus2M
#moved to 20-area-detectors.py
#pilatus_name = pilatus2M
#pilatus_Epicsname = '{Det:PIL2M}'


class BeamlineDetector(object):
    
    def __init__(self, detector, **md):
        
        self.detector = detector
        
        self.md = md
        
    
    def get_md(self, prefix='detector_', **md):
        '''Returns a dictionary of the current metadata.
        The 'prefix' argument is prepended to all the md keys, which allows the
        metadata to be grouped with other metadata in a clear way. (Especially,
        to make it explicit that this metadata came from the beamline.)'''
        
        md_return = self.md.copy()
    
        # Include the user-specified metadata
        md_return.update(md)

        # Add an optional prefix
        if prefix is not None:
            md_return = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_return.items() }
    
        return md_return
            
            
class CMS_SAXS_Detector(BeamlineDetector):

    def setCalibration(self, direct_beam, distance, detector_position=None, pixel_size=0.172):
        
        self.direct_beam = direct_beam
        self.distance = distance
        if detector_position is None:
            self.detector_position = [SAXSx.user_readback.value, SAXSy.user_readback.value]
        else:
            self.detector_position = detector_position
        self.pixel_size = pixel_size
        
    
    def get_md(self, prefix='detector_SAXS_', **md):
        
        ###TODO: change all ROI settings without caget. 

        md_return = self.md.copy()
    
        x0, y0 = self.direct_beam
        position_defined_x, position_defined_y = self.detector_position
        position_current_x, position_current_y = SAXSx.user_readback.value, SAXSy.user_readback.value
        
            
        md_return['name'] = self.detector.name
        md_return['epics_name'] = '{Det:PIL2M}'

        md_return['x0_pix'] = round( x0 + (position_current_x-position_defined_x)/self.pixel_size , 2 )
        md_return['y0_pix'] = round( y0 + (position_current_y-position_defined_y)/self.pixel_size , 2 )

        md_return['distance_m'] = self.distance
    
        md_return['ROI1_X_min'] = caget('XF:11BMB-ES{}:ROI1:MinX'.format(pilatus_Epicsname))
        md_return['ROI1_X_size'] = caget('XF:11BMB-ES{}:ROI1:SizeX'.format(pilatus_Epicsname))
        md_return['ROI1_Y_min'] = caget('XF:11BMB-ES{}:ROI1:MinY'.format(pilatus_Epicsname))
        md_return['ROI1_Y_size'] = caget('XF:11BMB-ES{}:ROI1:SizeY'.format(pilatus_Epicsname))

        md_return['ROI2_X_min'] = caget('XF:11BMB-ES{}:ROI2:MinX'.format(pilatus_Epicsname))
        md_return['ROI2_X_size'] = caget('XF:11BMB-ES{}:ROI2:SizeX'.format(pilatus_Epicsname))
        md_return['ROI2_Y_min'] = caget('XF:11BMB-ES{}:ROI2:MinY'.format(pilatus_Epicsname))
        md_return['ROI2_Y_size'] = caget('XF:11BMB-ES{}:ROI2:SizeY'.format(pilatus_Epicsname))

        md_return['ROI3_X_min'] = caget('XF:11BMB-ES{}:ROI3:MinX'.format(pilatus_Epicsname))
        md_return['ROI3_X_size'] = caget('XF:11BMB-ES{}:ROI3:SizeX'.format(pilatus_Epicsname))
        md_return['ROI3_Y_min'] = caget('XF:11BMB-ES{}:ROI3:MinY'.format(pilatus_Epicsname))
        md_return['ROI3_Y_size'] = caget('XF:11BMB-ES{}:ROI3:SizeY'.format(pilatus_Epicsname))

        md_return['ROI4_X_min'] = caget('XF:11BMB-ES{}:ROI4:MinX'.format(pilatus_Epicsname))
        md_return['ROI4_X_size'] = caget('XF:11BMB-ES{}:ROI4:SizeX'.format(pilatus_Epicsname))
        md_return['ROI4_Y_min'] = caget('XF:11BMB-ES{}:ROI4:MinY'.format(pilatus_Epicsname))
        md_return['ROI4_Y_size'] = caget('XF:11BMB-ES{}:ROI4:SizeY'.format(pilatus_Epicsname))
        
        # Include the user-specified metadata
        md_return.update(md)

        # Add an optional prefix
        if prefix is not None:
            md_return = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_return.items() }
    
        return md_return

class CMS_WAXS_Detector(BeamlineDetector):

    def __init__(self, detector, **md):
        
        self.detector = pilatus800
        
        self.md = md
    
        
    def setCalibration(self, direct_beam, distance, detector_position=None, pixel_size=0.172):
        
        self.direct_beam = direct_beam
        self.distance = distance
        if detector_position is None:
            self.detector_position = [WAXSx.user_readback.value, WAXSy.user_readback.value]
        else:
            self.detector_position = detector_position
        self.pixel_size = pixel_size
        
    
    def get_md(self, prefix='detector_WAXS_', **md):
        
        md_return = self.md.copy()
    
        x0, y0 = self.direct_beam
        position_defined_x, position_defined_y = self.detector_position
        position_current_x, position_current_y = WAXSx.user_readback.value, WAXSy.user_readback.value
        
            
        md_return['name'] = self.detector.name
        md_return['epics_name'] = '{Det:PIL800K}'

        #if pilatus_name==pilatus300k:
            #md_return['x0_pix'] = round( x0 + (position_current_x-position_defined_x)/self.pixel_size , 2 )
            #md_return['y0_pix'] = round( y0 + (position_current_y-position_defined_y)/self.pixel_size , 2 )
        #if pilatus_name==pilatus800:
        md_return['x0_pix'] = round( x0 + (position_current_x-position_defined_x)/self.pixel_size , 2 )
        md_return['y0_pix'] = round( y0 + (position_current_y-position_defined_y)/self.pixel_size , 2 )
        
        #TODO:WAXS PV
        
        md_return['distance_m'] = self.distance
        
        md_return['ROI1_X_min'] = caget('XF:11BMB-ES{}:ROI1:MinX'.format(pilatus_Epicsname))
        md_return['ROI1_X_size'] = caget('XF:11BMB-ES{}:ROI1:SizeX'.format(pilatus_Epicsname))
        md_return['ROI1_Y_min'] = caget('XF:11BMB-ES{}:ROI1:MinY'.format(pilatus_Epicsname))
        md_return['ROI1_Y_size'] = caget('XF:11BMB-ES{}:ROI1:SizeY'.format(pilatus_Epicsname))

        md_return['ROI2_X_min'] = caget('XF:11BMB-ES{}:ROI2:MinX'.format(pilatus_Epicsname))
        md_return['ROI2_X_size'] = caget('XF:11BMB-ES{}:ROI2:SizeX'.format(pilatus_Epicsname))
        md_return['ROI2_Y_min'] = caget('XF:11BMB-ES{}:ROI2:MinY'.format(pilatus_Epicsname))
        md_return['ROI2_Y_size'] = caget('XF:11BMB-ES{}:ROI2:SizeY'.format(pilatus_Epicsname))

        md_return['ROI3_X_min'] = caget('XF:11BMB-ES{}:ROI3:MinX'.format(pilatus_Epicsname))
        md_return['ROI3_X_size'] = caget('XF:11BMB-ES{}:ROI3:SizeX'.format(pilatus_Epicsname))
        md_return['ROI3_Y_min'] = caget('XF:11BMB-ES{}:ROI3:MinY'.format(pilatus_Epicsname))
        md_return['ROI3_Y_size'] = caget('XF:11BMB-ES{}:ROI3:SizeY'.format(pilatus_Epicsname))

        md_return['ROI4_X_min'] = caget('XF:11BMB-ES{}:ROI4:MinX'.format(pilatus_Epicsname))
        md_return['ROI4_X_size'] = caget('XF:11BMB-ES{}:ROI4:SizeX'.format(pilatus_Epicsname))
        md_return['ROI4_Y_min'] = caget('XF:11BMB-ES{}:ROI4:MinY'.format(pilatus_Epicsname))
        md_return['ROI4_Y_size'] = caget('XF:11BMB-ES{}:ROI4:SizeY'.format(pilatus_Epicsname))
        
        # Include the user-specified metadata
        md_return.update(md)

        # Add an optional prefix
        if prefix is not None:
            md_return = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_return.items() }
    
        return md_return


class BeamlineElement(object):
    '''Defines a component of the beamline that (may) intersect the x-ray beam.'''
    
    def __init__(self, name, zposition, description="", pv=None, **args):
        
        self.name = name
        self.zposition = zposition
        self.description = description
        
        self.conversion_factor = 1
        
        self._pv_main = pv
        
        self.has_flux = True
        
        
    def state(self):
        """
        Returns the current state of the beamline element. Common states:
        out - Element is out of the way of the beam (and should not be blocking).
        in - Element is in the beam (but should not be blocking).
        block - Element is in the beam, and should be blocking the beam.
        undefined - Element is in an unexpected state.
        """
        
        return "out"

    
    def transmission(self, t=None, verbosity=0):
        """
        Returns the predicted transmission of this beamline element, based on 
        its current state.
        """
        
        if t is not None:
            print("WARNING: To change transmission, use 'setTransmission'.")
            print("WARNING: Beam transmission was not changed.")
            return
        
        tr_tot = 1.0
        
        if verbosity>=2:
            print('{:s} transmission = {:.6g}'.format(self.name, tr_tot))
        
        
        # Assume a generic beamline element doesn't block/perturb the beam
        return tr_tot
        
        
    def flux(self, verbosity=3):
        
        reading = self.reading(verbosity=0)
        flux = self.conversion_factor*reading # ph/s
        
        if verbosity>=2:
            print('flux = {:.4g} ph/s'.format(flux))
        
        return flux
    
    
        
        
class Shutter(BeamlineElement):
    
    # Example
    #          XF:11BMA-PPS{PSh}Enbl-Sts
    #  Status: XF:11BMA-PPS{PSh}Pos-Sts       0 for open, 1 for close
    #  Open:   XF:11BMA-PPS{PSh}Cmd:Opn-Cmd
    #  Close:  XF:11BMA-PPS{PSh}Cmd:Cls-Cmd
    
    def __init__(self, name, zposition, description="", pv=None, **args):
        
        super().__init__(name=name, zposition=zposition, description=description, pv=pv, **args)
        self.has_flux = False
        
    
    def state(self):
        """
        Returns the current state of the beamline element. Common states:
        out - Element is out of the way of the beam (and should not be blocking).
        in - Element is in the beam (but should not be blocking).
        block - Element is in the beam, and should be blocking the beam.
        undefined - Element is in an unexpected state.
        """
        
        state_n = caget(self._pv_main+'Pos-Sts')
        
        if state_n == 0:
            return "out"
        elif state_n == 1:
            return "block"
        else:
            return "undefined" 
        
        
    def open(self, verbosity=3):
        
        if verbosity>=3:
            print('Opening {:s}...'.format(self.name))
        
        # E.g. #XF:11BMB-VA{Slt:4-GV:1}Cmd:Opn-Cmd
        pv = self._pv_main + 'Cmd:Opn-Cmd'
        #caput(pv, 1) # TODO: Test this.
    
    def close(self, verbosity=3):
        
        if verbosity>=3:
            print('Closing {:s}...'.format(self.name))
            
        pv = self._pv_main + 'Cmd:Cls-Cmd'
        #caput(pv, 1) # TODO: Test this.

        



class GateValve(Shutter):
    
    # Example
    #  Status: XF:11BMB-VA{Slt:4-GV:1}Pos-Sts        1 for open, 0 for close
    #  Open:   XF:11BMB-VA{Slt:4-GV:1}Cmd:Opn-Cmd
    #  Close:  XF:11BMB-VA{Slt:4-GV:1}Cmd:Cls-Cmd
    
    
    def state(self):
        """
        Returns the current state of the beamline element. Common states:
        out - Element is out of the way of the beam (and should not be blocking).
        in - Element is in the beam (but should not be blocking).
        block - Element is in the beam, and should be blocking the beam.
        undefined - Element is in an unexpected state.
        """
        
        state_n = caget(self._pv_main+'Pos-Sts')
        
        if state_n == 1:
            return "out"
        elif state_n == 0:
            return "block"
        else:
            return "undefined"     
    


class ThreePoleWiggler(BeamlineElement):
    
    def __init__(self, name='3PW', zposition=0.0, description='Three-pole wiggler source of x-rays', **args):
        
        
        super().__init__(name=name, zposition=zposition, description=description, **args)
        
        # TODO: Find out the right conversion factor
        self.conversion_factor = 3e18/500.0 #(ph/s)/mA
        

    def state(self):
        """
        Returns the current state of the beamline element. Common states:
        out - Element is out of the way of the beam (and should not be blocking).
        in - Element is in the beam (but should not be blocking).
        block - Element is in the beam, and should be blocking the beam.
        undefined - Element is in an unexpected state.
        """
        
        position = caget('SR:C11-ID:G5{3PW:1}Mtr.RBV')
        
        # TODO: Instead use the 'inserted' flag?
        # caget('SR:C11-ID:G5{3PW:1}InsertedFlag')
        
        if abs(position-0)<3:
            return "in"
        
        elif abs(position - -189.0)<10:
            return "out"
        
        else:
            return "undefined"
        
        
    def reading(self, verbosity=3):
        
        if self.state() == 'in':
            
            ring_current = caget('SR:OPS-BI{DCCT:1}I:Real-I')
            if verbosity>=2:
                print('{:s} is inserted; ring current = {:.1f} mA'.format(self.name, ring_current))
                
            return ring_current
        
        else:
            if verbosity>=2:
                print('{:s} is not inserted.'.format(self.name))
                
            return 0
        

class Monitor(BeamlineElement):
    
    def quickReading(self, verbosity=3, delay=1.0):
        """
        Puts the diagnostic into the beam, takes a reading, and removes the
        diagnostic.
        """
        
        self.insert()
        time.sleep(delay)
        value = self.reading(verbosity=verbosity)
        
        self.retract()
        time.sleep(delay)
        
        return value
    
    
    
class DiagnosticScreen(Monitor):
    
    #XF:11BMB-BI{FS:4}Pos-Sts
    
    def __init__(self, name, zposition, description="", pv=None, epics_signal=None, **args):
        
        super().__init__(name=name, zposition=zposition, description=description, pv=pv, **args)
        self.epics_signal = epics_signal
        self.has_flux = False
        
    
    def state(self):
        """
        Returns the current state of the beamline element. Common states:
        out - Element is out of the way of the beam (and should not be blocking).
        in - Element is in the beam (but should not be blocking).
        block - Element is in the beam, and should be blocking the beam.
        undefined - Element is in an unexpected state.
        """
        
        state_n = caget(self._pv_main+'Pos-Sts')
        
        if state_n == 0:
            return "out"
        elif state_n == 1:
            return "block"
        else:
            return "undefined" 
            
    
    def insert(self, verbosity=3):
        
        if verbosity>=3:
            print('Inserting {:s}...'.format(self.name))
        
        # E.g. #XF:11BMB-VA{Slt:4-GV:1}Cmd:Opn-Cmd
        pv = self._pv_main + 'Cmd:In-Cmd'
        caput(pv, 1)
    
    def retract(self, verbosity=3):
        
        if verbosity>=3:
            print('Retracting {:s}...'.format(self.name))
            
        pv = self._pv_main + 'Cmd:Out-Cmd'
        caput(pv, 1)
        
        
    def reading(self, verbosity=3):
        
        value = self.epics_signal.stats1.total.value
        
        if self.state() == 'block':
            
            ring_current = caget('SR:OPS-BI{DCCT:1}I:Real-I')
            if verbosity>=2:
                print('{:s} is inserted; reading = {:.4g}'.format(self.name, value))
                
            return value
        
        else:
            if verbosity>=2:
                print('{:s} is not inserted.'.format(self.name))
                
            return 0
        
        
        
        
class PointDiode_CMS(Monitor):
    
    def __init__(self, name='bim6 point diode', zposition=59.1, description="Bar holding a point-diode, downstream of sample.", pv='XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV', epics_signal=None, **args):
        
        super().__init__(name=name, zposition=zposition, description=description, pv=pv, **args)
        self.has_flux = True
        
        if epics_signal == None:
            
            #bim6 = EpicsSignalROWait("XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV", wait_time=1, name='bim6')
            #bim6_integrating = EpicsSignalROIntegrate("XF:11BMB-BI{IM:2}EM180:Current1:MeanValue_RBV", wait_time=0.5, integrate_num=8, integrate_delay=0.1, name='bim6')
            
            self.epics_signal = bim6_integrating
            
        else:
            self.epics_signal = epics_signal
        
        
        # The beam (at the ion chamber) is roughly 0.50x0.50 mm.
        # If we slit down to 0.20x0.05 mm, we are capturing 0.4*0.25 = 0.1 of the beam.
        # bim6 reads 70000 cts (of course this depends on settings) when ion chamber reads 1.3e11 ph/s.
        # (settings: trans = 5e-4)
        # So conversion_factor is roughly:
        self.conversion_factor = 1.3e11*0.1/70000. # (ph/s)/cts
        
        self.in_position_x = 0.0
        self.in_position_y = 0.0

        self.out_position_x = 0.0
        self.out_position_y = -16.0
        
        self.position_tolerance = 0.1
        
    
    def state(self):
        """
        Returns the current state of the beamline element. Common states:
        out - Element is out of the way of the beam (and should not be blocking).
        in - Element is in the beam (but should not be blocking).
        block - Element is in the beam, and should be blocking the beam.
        undefined - Element is in an unexpected state.
        """
        
        position_x = DETx.user_readback.value
        position_y = DETy.user_readback.value
        
        if abs(position_x-self.out_position_x)<self.position_tolerance and abs(position_y-self.out_position_y)<self.position_tolerance: 
            return "out"
        if abs(position_x-self.in_position_x)<self.position_tolerance and abs(position_y-self.in_position_y)<self.position_tolerance: 
            return "block"
        else:
            return "undefined" 
                
    def insert(self, verbosity=3):
        
        if verbosity>=3:
            print('Inserting {:s}...'.format(self.name))
        
        #mov( [DETx, DETy], [self.in_position_x, self.in_position_y] )
        DETx.move = self.in_position_x
        DETy.move = self.in_position_y
    
    def retract(self, verbosity=3):
        
        if verbosity>=3:
            print('Retracting {:s}...'.format(self.name))
            
        #mov( [DETx, DETy], [self.out_position_x, self.out_position_y] )
        DETx.move = self.out_position_x
        DETy.move = self.out_position_y        
        
    def reading(self, verbosity=3):
        
        value = self.epics_signal.read()[self.epics_signal.name]['value']
        
        if self.state() == 'block':
            
            if verbosity>=2:
                print('{:s} is inserted; reading = {:.4g}'.format(self.name, value))
                
            return value
        
        else:
            if verbosity>=2:
                print('{:s} is not inserted.'.format(self.name))
                
            return value
                
        

class IonChamber_CMS(Monitor):
    
    def __init__(self, name='bim3 ionchamber', zposition=49, description="Ion chamber (FMB Oxford I404) at start of endstation hutch", pv=None, beam=None, **args):
        
        super().__init__(name=name, zposition=zposition, description=description, pv=pv, **args)
        self.has_flux = True
        
        self.beam = beam
        
        # PVs
        import epics
        self.v1 = epics.PV('XF:11BMB-BI{IM:3}:IC1_MON')
        self.v2 = epics.PV('XF:11BMB-BI{IM:3}:IC2_MON')
        self.h1 = epics.PV('XF:11BMB-BI{IM:3}:IC3_MON')
        self.h2 = epics.PV('XF:11BMB-BI{IM:3}:IC4_MON')

        
    def state(self):
        
        return "in"
    
    
    def v_position(self):
        
        total = self.v1.value+self.v2.value
        if total>0:
            return (self.v1.value-self.v2.value)/(total)
        else:
            return 0

    def h_position(self):
        
        total = self.h1.value+self.h2.value
        if total>0:
            return (self.h1.value-self.h2.value)/(total)
        else:
            return 0
    
    def reading(self, verbosity=3):
        
        total = self.h1.value + self.h2.value + self.v1.value + self.v2.value
        
        if verbosity>=3:
            print('Reading for {:s} ({:s})'.format(self.name, self.description))
            print('  Horizontal:  {:9.4g}  +  {:9.4g}  =  {:9.4g}'.format(self.h1.value, self.h2.value, self.h1.value+self.h2.value))
            print('    position: {:.3f}'.format(self.h_position()))
            print('  Vertical:    {:9.4g}  +  {:9.4g}  =  {:9.4g}'.format(self.v1.value, self.v2.value, self.v1.value+self.v2.value))
            print('    position: {:.3f}'.format(self.v_position()))

        if verbosity>=2:
            
            print('  Total:  {:9.4g}'.format(total))
            
        return total
    
    
    def current_to_flux(self, current):
        
        energy_keV = self.beam.energy(verbosity=0)
        
        V_ion = 0.036       ## ionization energy of N2 gas in [keV]
        IC_len = 6.0        ## active length of Ion Chamber in [cm]
        qe = 1.602e-19      ## electron charge in [C]

        ## Absorption length [cm] of gas N2 (1 atm, 1.131 g/L) vs E [keV]
        # based on polynomial fit to the calculated abs length data from: henke.lbl.gov/optical_constants/atten2.html 
        # see /home/xf11bm/masa/atten_len_N2* 
        abs_len = 355.21 - 112.26*energy_keV + 11.200*np.square(energy_keV) - 0.10611*np.power(energy_keV,3.0)

        N_abs = current*V_ion/(qe*energy_keV)
        flux = N_abs / (1.0 - np.exp(-IC_len/abs_len))

        return flux
    
    
    def flux(self, verbosity=3):
        
        if self.reading(verbosity=0) < 5e-10:
            return 0.0
        
        h1 = self.current_to_flux(self.h1.value)
        h2 = self.current_to_flux(self.h2.value)
        h_total = h1 + h2
        v1 = self.current_to_flux(self.v1.value)
        v2 = self.current_to_flux(self.v2.value)
        v_total = v1 + v2
        
        total = h_total + v_total
        avg = total*0.5
        
        if verbosity>=3:
            print('Flux for {:s} ({:s})'.format(self.name, self.description))
            print('  Horizontal:  {:9.4g}  +  {:9.4g}  =  {:9.4g} ph/s'.format(h1, h2, h1+h2))
            print('    position: {:.3f}'.format(self.h_position()))
            print('  Vertical:    {:9.4g}  +  {:9.4g}  =  {:9.4g} ph/s'.format(v1, v2, v1+v2))
            print('    position: {:.3f}'.format(self.v_position()))

        if verbosity>=2:
            
            print('  Average:  {:9.4g} ph/s'.format(avg))
            
        return avg 
    
    
    
#ionchamber = IonChamber_CMS(beam=beam)


class Scintillator_CMS(Monitor):
    
    def __init__(self, name='bim4 scintillator', zposition=57, description="Scintillation detector (FMB Oxford C400) between S3 and KB tank in endstation hutch. Captures scattering off of a Kapton film at 45 degrees.", pv=None, beam=None, **args):
        
        super().__init__(name=name, zposition=zposition, description=description, pv=pv, **args)
        self.has_flux = True
        
        self.beam = beam
        
        # PVs
        import epics
        self.sec = epics.PV('XF:11BMB-BI{IM:4}:GET_PERIOD')    # integration time in [sec]
        self.cts = epics.PV('XF:11BMB-BI{IM:4}:C1_1')    # raw counts


    def state(self):
        
        return "in"

    
    def reading(self, verbosity=3):
        
        if self.sec.value == 0.0:
            print('Counting time set to zero. Check CSS settings for FMB Oxford C400.')
            return 0 
        else:
            sec = self.sec.value
            cts = self.cts.value
            cps = cts/sec
        
        if verbosity>=3:
            print('Reading for {:s} ({:s})'.format(self.name, self.description))
            print('  Count time:  {:9.4g} sec'.format(sec))
            print('  Raw counts:  {:9.4g} counts'.format(cts))

        if verbosity>=2:
            print('  Count rate:  {:9.4g} counts/sec'.format(cps))
            
        return cps
    
    
    def cps_to_flux(self, cps):

        ### Ratio between estimated beam flux to raw scintillator counts 
        # (see Olog entry on July 7, 2017)
        # For unslitted, unattenuated beam at 13.5 keV, 
        # BIM4 yields 2.86E5 cts/sec for 1.85E11 ph/s at BIM3:
        # 1.85E11 / 2.86E5 = 647000 (ph/s)/(cts/sec).
        #cps_to_flux_factor = 647000.
        
        ### Ratio between estimated beam flux to raw scintillator counts (see Olog entry on January 18, 2018)
        # For unslitted beam with absorber 4 and evacuated chamber, 
        # BIM4 yields 1.978E5 cts/sec for 1.73E11 ph/s at BIM3 and 1.55e11 ph/s at Pilatus2M:
        # Scale factor = (1.545e11 ph/sec) / (1.978e+05 ph/s) = 7.786e5.
        cps_to_flux_factor = 7.786E5

        flux = cps_to_flux_factor * cps

        return flux
    
    
    def flux(self, verbosity=3):
        
        if self.reading(verbosity=0) < 5e-10:
            return 0.0

        flux = self.cps_to_flux(self.reading(verbosity=0))        
        
        
        if verbosity>=3:
            print('Flux for {:s} ({:s})'.format(self.name, self.description))

        if verbosity>=2:
            print('  Beam flux:  {:9.4g} ph/s'.format(flux))
            
        return flux 
    
    
class DiamondDiode_CMS(Monitor):
    
    def __init__(self, name='bim5 diamonddiode', zposition=58.2, description="Diamond diode BPM (Dectris RIGI via FMB Oxford F460) between KB tank and sample chamber in endstation hutch. Needs to be insered into beam via IM:5.", pv=None, beam=None, **args):
        
        super().__init__(name=name, zposition=zposition, description=description, pv=pv, **args)
        self.has_flux = True
        
        self.beam = beam
        
        # PVs
        import epics
        self.i0 = epics.PV('XF:11BMB-BI{BPM:1}Cur:I0-I')    # upper left
        self.i1 = epics.PV('XF:11BMB-BI{BPM:1}Cur:I1-I')    # upper right
        self.i2 = epics.PV('XF:11BMB-BI{BPM:1}Cur:I2-I')    # lower left
        self.i3 = epics.PV('XF:11BMB-BI{BPM:1}Cur:I3-I')    # lower right
        
    def state(self):

        # TODO: fix this so it queries state of IM:5        
        return "in"
    
    
    def v_position(self):
        
        total = self.i0.value + self.i1.value + self.i2.value + self.i3.value
        if total>0:
            return (self.i0.value + self.i1.value - self.i2.value - self.i3.value)/(total)
        else:
            return 0

    def h_position(self):
        
        total = self.i0.value + self.i1.value + self.i2.value + self.i3.value
        if total>0:
            return (self.i1.value + self.i3.value - self.i0.value - self.i2.value)/(total)
        else:
            return 0
    
    def reading(self, verbosity=3):
        
        #total = self.i0.value + self.i1.value + self.i2.value + self.i3.value
        ## 07/12/2017  Total dark current with beam off is ~9.3e-10 A.
        dark_current = 9.3e-10
        total = self.i0.value + self.i1.value + self.i2.value + self.i3.value - dark_current
        
        if verbosity>=3:
            print('Reading for {:s} ({:s})'.format(self.name, self.description))
            print('  Horizontal:')
            print('    Right:  {:9.4g}  +  {:9.4g}  =  {:9.4g} A'.format(self.i1.value, self.i3.value, self.i1.value+self.i3.value))
            print('    Left:  {:9.4g}  +  {:9.4g}  =  {:9.4g} A'.format(self.i0.value, self.i2.value, self.i0.value+self.i2.value))
            print('    Position [-1(L) to 1(R), 0 at center]: {:.3f}'.format(self.h_position()))
            print('  Vertical:')
            print('    Top:  {:9.4g}  +  {:9.4g}  =  {:9.4g} A'.format(self.i0.value, self.i1.value, self.i0.value+self.i1.value))
            print('    Bottom:  {:9.4g}  +  {:9.4g}  =  {:9.4g} A'.format(self.i2.value, self.i3.value, self.i2.value+self.i3.value))
            print('    Position [-1(B) to 1(T), 0 at center]: {:.3f}'.format(self.v_position()))

        if verbosity>=2:
            
            print('  Total current:  {:9.4g} A'.format(total))
            
        return total
    
    
    def current_to_flux(self, current):

        ### Ratio between estimated beam flux to raw TOTAL current for the 4 quadrants 
        # (see Olog entry on July 7, 2017).
        # For unslitted, unattenuated beam at 13.5 keV, 
        # BIM5 yields a TOTAL current of 4.8E-8 A at ~230 mA ring current, 
        # corresponding to 1.38E11 ph/s at BIM3:
        # 1.38E11 / 4.8E-8 = 0.29E19 (ph/s)/A.
        # With dark current (total = 9.3e-10 A = 0.093e-8 A) taken into account, 
        # 1.38E11 / 4.7E-8 = 0.294E19 (ph/s)/A.
        #current_to_flux_factor = 2.94E18

        ### Ratio between estimated beam flux to raw TOTAL current for the 4 quadrants 
        # (see Olog entry on January 18, 2018).
        # For unslitted beam with absorber 4 and evacuated chamber, 
        # BIM5 yields 5.09e-8 A for for 1.73E11 ph/s at BIM3 and 1.55e11 ph/s at Pilatus2M:
        # Scale factor = (1.545e11 ph/sec) / (5.0902e-08 A) = 3.025e+18
        current_to_flux_factor = 3.025E18

        flux = current_to_flux_factor * current

        return flux

    
    def flux(self, verbosity=3):
        
        if self.reading(verbosity=0) < 1e-11:
            return 0.0
        
        right = self.current_to_flux(self.i1.value+self.i3.value)
        left = self.current_to_flux(self.i0.value+self.i2.value)
        top = self.current_to_flux(self.i0.value+self.i1.value)
        bottom = self.current_to_flux(self.i2.value+self.i3.value)
        total = self.current_to_flux(self.reading(verbosity=0))
        
        if verbosity>=3:
            print('Flux for {:s} ({:s})'.format(self.name, self.description))
            print('  Horizontal:')
            print('    Right:  {:9.4g} ph/s'.format(right))
            print('    Left:  {:9.4g} ph/s'.format(left))
            print('    Position [-1(L) to 1(R), 0 at center]: {:.3f}'.format(self.h_position()))
            print('  Vertical:')
            print('    Top:  {:9.4g} ph/s'.format(top))
            print('    Bottom:  {:9.4g} ph/s'.format(bottom))
            print('    Position [-1(B) to 1(T), 0 at center]: {:.3f}'.format(self.v_position()))

        if verbosity>=2:
            
            print('  Total flux:  {:9.4g} ph/s'.format(total))
            
        return total 


# CMSBeam
################################################################################
class CMSBeam(object):
    """
    This class represents the 'beam' at the beamline. This collects together aspects
    of querying or changing beam properties, including the energy (or wavelength), 
    the beam intensity (or measuring flux), and so forth.
    """
    
    def __init__(self):
        
        self.mono_bragg_pv = 'XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr.RBV'
        
        # (planck constant * speed of light)/(electronic charge)
        self.hc_over_e = 1.23984197e-6 # m^3 kg s^-3 Amp^-1 = eV*m
        self.hc_over_e_keVpA = self.hc_over_e*1e7 # = 12.4 keV*Angstrom
        
        # DMM bilayer pitch in Angstroms, according to Rigaku metrology report
        self.dmm_dsp = 20.1 # Angstroms
        
        
        
        self.mono = BeamlineElement('monochromator', 26.5)
        def transmission(verbosity=0):
            return 1e-7
        self.mono.transmission = transmission

        
        self.attenuator = BeamlineElement('attenuator', 53.8, description="Attenuator/filter box")
        self.attenuator.has_flux = False
        def reading(verbosity=0):
            return self.transmission(verbosity=verbosity)
        self.attenuator.reading = reading
        self.attenuator.transmission = self.transmission
        
        self.attenuator2 = BeamlineElement('attenuator2', 58.6, description="Nb foil absorber")
        self.attenuator2.has_flux = False
        def reading(verbosity=0):
            return self.absorber(verbosity=verbosity)[1]
        self.attenuator2.reading = reading
        self.attenuator2.transmission = reading

        #def the foils
        # self.atten_filter = atten_filter
        # filters_sts = [fil.sts.get() for fil in filters.values()]
        # filters_cmd = [fil.cmd.get() for fil in filters.values()]

        #define the original position of aborber (6 Nb foils for XRR)
        #the position is defined in 'config_update'. This position is a good reference. 
        #armr_absorber_o = the center of the first edge
        self.armr_absorber_o = 1.3-3
        self.armr_absorber_out = -55.1
        self.absorber_transmission_list_13p5kev = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]    # at E = 13.5keV
        self.absorber_transmission_list_17kev = [1, 1.847e-1, 3.330e-2, 6.064e-3, 1.101e-3, 1.966e-4, 3.633e-5]    # at E = 17keV
        self.absorber_transmission_list_10kev = [1, 8.5938e-4, 6.8924e-7, 5.9232e-10, 1e-15, 1e-15, 1e-15, 1e-15]    # at E = 10.08keV
        #TODO: make this energy dependent
        
        if False:
            # self.fs1 = DiagnosticScreen( 'fs1', 27.2, pv='XF:11BMA-BI{FS:1}', epics_signal=StandardProsilica('XF:11BMA-BI{FS:1-Cam:1}', name='fs1') )
            #self.fs2 = DiagnosticScreen( 'fs2', 29.1, pv='XF:11BMA-BI{FS:2}', epics_signal=StandardProsilica('XF:11BMA-BI{FS:2-Cam:1}', name='fs2') )
            self.fs3 = DiagnosticScreen( 'fs3', 55.8, pv='XF:11BMB-BI{FS:3}', epics_signal=StandardProsilica('XF:11BMB-BI{FS:3-Cam:1}', name='fs3') )
            self.fs4 = DiagnosticScreen( 'fs4', 58.2, pv='XF:11BMB-BI{FS:4}', epics_signal=StandardProsilica('XF:11BMB-BI{FS:4-Cam:1}', name='fs4') )
            # self.fs5 = DiagnosticScreen( 'fs5', 70.0, pv='XF:11BMB-BI{FS:Test-Cam:1}', epics_signal=StandardProsilica('XF:11BMB-BI{FS:4-Cam:1}', name='fs5') )
        else:
            # Rely on the fact that these are defined in 20-area-detectors.py
            # self.fs1 = DiagnosticScreen( 'fs1', 27.2, pv='XF:11BMA-BI{FS:1}', epics_signal=fs1 )
            #self.fs2 = DiagnosticScreen( 'fs2', 29.1, pv='XF:11BMA-BI{FS:2}', epics_signal=fs2 )
            self.fs3 = DiagnosticScreen( 'fs3', 55.8, pv='XF:11BMB-BI{FS:3}', epics_signal=fs3 )
            self.fs4 = DiagnosticScreen( 'fs4', 58.2, pv='XF:11BMB-BI{FS:4}', epics_signal=fs4 )
            # self.fs5 = DiagnosticScreen( 'fs5', 70.0, pv='XF:11BMB-BI{FS:Test-Cam:1}', epics_signal=fs5 )
            
            
        self.bim3 = IonChamber_CMS(beam=self)
        self.bim4 = Scintillator_CMS()
        self.beam_defining_slit = s4
        self.bim5 = DiamondDiode_CMS()
        self.bim6 = PointDiode_CMS()
        
        self.GVdsbig = GateValve('GV ds big', 60.0, pv='XF:11BMB-VA{Chm:Det-GV:1}')
        
        
        
        self.elements = []
        
        # Front End
        self.elements.append(ThreePoleWiggler())
        #SR:C03-EPS{PLC:1}Sts:BM_BMPS_Opn-Sts BMPS
        self.elements.append(GateValve('GV1', 20.0, pv='FE:C03A-VA{GV:1}DB:'))
        self.elements.append(GateValve('GV2', 21.0, pv='FE:C03A-VA{GV:2}DB:'))
        
        
        # FOE
        self.elements.append(Shutter('FE shutter', 25.0, pv='XF:11BM-PPS{Sh:FE}'))
        self.elements.append(GateValve('GV', 26.0, pv='FE:C11B-VA{GV:2}'))
        self.elements.append(self.mono)
        # self.elements.append(self.fs1)
        # bim1
        # slit0
        # bim2
        self.elements.append(GateValve('GV', 28.0, pv='XF:11BMA-VA{Slt:0-GV:1}'))
        self.elements.append(BeamlineElement('mirror', 29.1))
        self.elements.append(GateValve('GV', 30.5, pv='XF:11BMA-VA{Mir:Tor-GV:1}'))
        self.elements.append(BeamlineElement('fs2 (manual)', 30.9)) # self.elements.append(self.fs2)
        self.elements.append(Shutter('photon shutter', 33.7, pv='XF:11BMA-PPS{PSh}'))
        self.elements.append(GateValve('GV', 34.0, pv='XF:11BMA-VA{PSh:1-GV:1}'))
        
        # Endstation
        self.elements.append(self.bim3)
        # Experimental shutter 49.5
        self.elements.append(self.attenuator)
        self.elements.append(self.fs3)
        self.elements.append(self.bim4) # scintillation detector
        self.elements.append(BeamlineElement('KB mirrors', 57.8))
        self.elements.append(self.fs4)
        self.elements.append(self.bim5) # diamond diode BPM
        # im4
        #self.elements.append(GateValve('GV us small', 58.5, pv='XF:11BMB-VA{Slt:4-GV:1}'))
        self.elements.append(self.attenuator2)
        
        self.elements.append(BeamlineElement('sample', 58.8))
        self.elements.append(self.bim6) # dsmon
        self.elements.append(BeamlineElement('WAXS detector', 59.0))
        self.elements.append(self.GVdsbig)
        self.elements.append(BeamlineElement('SAXS detector', 58.8+5))
        
        
        
        # Sort by position along the beam
        self.elements.sort(key=lambda o: o.zposition, reverse=False)
    
    
    # Monochromator
    ########################################
    
    def energy(self, verbosity=3):
        """
        Returns the current x-ray photon energy (in keV).
        """
        
        # Current angle of monochromator multilayer crystal
        Bragg_deg = caget(self.mono_bragg_pv)
        Bragg_rad = np.radians(Bragg_deg)
        
        wavelength_A = 2.*self.dmm_dsp*np.sin(Bragg_rad)
        wavelength_m = wavelength_A*1e-10

        energy_eV = self.hc_over_e/wavelength_m
        energy_keV = energy_eV/1000.
        
        if verbosity>=3:
            print('E = {:.2f} keV, wavelength = {:.4f} Å, Bragg = {:.6f} rad = {:.4f} deg'.format(energy_keV, wavelength_A, Bragg_rad, Bragg_deg))
            
        elif verbosity>=1:
            print('E = {:.3f} keV'.format(energy_keV))
        
        return energy_keV
        
        
    def wavelength(self, verbosity=3):
        """
        Returns the current x-ray photon wavelength (in Angstroms).
        """
        
        # Current angle of monochromator multilayer crystal
        Bragg_deg = caget(self.mono_bragg_pv)
        Bragg_rad = np.radians(Bragg_deg)
        
        wavelength_A = 2.*self.dmm_dsp*np.sin(Bragg_rad)
        wavelength_m = wavelength_A*1e-10

        # (planck constant * speed of light)/(electronic charge)
        
        energy_eV = self.hc_over_e/wavelength_m
        energy_keV = energy_eV/1000.
        
        if verbosity>=3:
            print('wavelength = {:.4f} Å, E = {:.2f} keV, Bragg = {:.6f} rad = {:.4f} deg'.format(wavelength_A, energy_keV, Bragg_rad, Bragg_deg))
            
        elif verbosity>=1:
            print('wavelength = {:.5f} Å'.format(wavelength_A))
        
        return wavelength_A
    
    
    def setEnergy(self, energy_keV, verbosity=3):
        """
        Set the x-ray beam to the specified energy (by changing the
        monochromator angle.
        """
        
        energy_eV = energy_keV*1000.
        wavelength_m = self.hc_over_e/energy_eV
        wavelength_A = wavelength_m*1.e10
        
        self.setWavelength(wavelength_A, verbosity=verbosity)
        
        return self.energy(verbosity=0)
    
    
    def setWavelength(self, wavelength_A, verbosity=3):
        """
        Set the x-ray beam to the specified wavelength (by changing the
        monochromator angle.
        """
        
        Bragg_deg_initial = caget(self.mono_bragg_pv)
        wavelength_m = wavelength_A*1.e-10
        Bragg_rad = np.arcsin(wavelength_A/(2.*self.dmm_dsp))
        Bragg_deg = np.degrees(Bragg_rad)
        
        print('mono_bragg will move to {:.4f}g deg'.format(Bragg_deg))
        response = input('    Are you sure? (y/[n]) ')
        if response == 'y' or response == 'Y':
            

            #mov(mono_bragg, Bragg_deg)
            #mono_bragg.move = Bragg_deg
            mono_bragg.move(Bragg_deg)
            
            if verbosity>=1:
                print('mono_bragg moved from {:.4f} deg to {:.4f} deg'.format(Bragg_deg_initial, Bragg_deg))
        
        elif verbosity>=1:
            print('No move was made.')
            
        return self.wavelength(verbosity=verbosity)

    
    # Slits
    ########################################
    
    def size(self, verbosity=3):
        """
        Returns the current beam size (rough estimate).
        The return is (size_horizontal, size_vertical) (in mm).
        """
        size_h = self.beam_defining_slit.xg.user_readback.value
        size_v = self.beam_defining_slit.yg.user_readback.value
        
        if verbosity>=3:
            print('Beam size:')
            print('  horizontal = {:.3f} mm'.format(size_h))
            print('  vertical   = {:.3f} mm'.format(size_v))
        
        return size_h, size_v

    
    def setSize(self, horizontal, vertical, verbosity=3):
        """
        Sets the beam size.
        """
        
        h, v = self.size(verbosity=0)
        
        if verbosity>=3:
            print('Changing horizontal beam size from {:.3f} mm to {:.3f} mm'.format(h, horizontal))
        self.beam_defining_slit.xg.user_setpoint.value = horizontal
        
        if verbosity>=3:
            print('Changing vertical beam size from {:.3f} mm to {:.3f} mm'.format(v, vertical))
        
        self.beam_defining_slit.yg.user_setpoint.value = vertical
    
    
    def divergence(self, verbosity=3):
        """
        Returns the beamline divergence.
        This is based on the Front End (FE) slits. The return is
        (horizontal, vertical) (in mrad).
        """
        
        distance_m = 10.0 # distance from source to slits
        
        horizontal_mm = caget('FE:C11B-OP{Slt:12-Ax:X}t2.C')
        vertical_mm = caget('FE:C11B-OP{Slt:12-Ax:Y}t2.C')
        
        horizontal_mrad = horizontal_mm/distance_m
        vertical_mrad = vertical_mm/distance_m
        
        if verbosity>=3:
            print('Beam divergence:')
            print('  horizontal = {:.3f} mrad'.format(horizontal_mrad))
            print('  vertical   = {:.3f} mrad'.format(vertical_mrad))
        
        return horizontal_mrad, vertical_mrad
        
    
    def setDivergence(self, horizontal, vertical, verbosity=3):
        """
        Set beamline divergence (in mrad).
        This is controlled using the Front End (FE) slits.
        """
        
        h, v = self.divergence(verbosity=0)

        distance_m = 10.0 # distance from source to slits
        
        horizontal_mm = horizontal*distance_m
        vertical_mm = vertical*distance_m
        
        if horizontal<0:
            if verbosity>=1:
                print("Horizontal divergence less than zero ({}) doesn't make sense.".format(horizontal))
            
        elif horizontal>1.5:
            if verbosity>=1:
                print("Horizontal divergence should be less than 1.5 mrad.")
                
        else:
            if verbosity>=3:
                print('Changing horizontal divergence from {:.3f} mrad to {:.3f} mrad.'.format(h, horizontal))
            caput('FE:C11B-OP{Slt:12-Ax:X}size', horizontal_mm)
        
        
        if vertical<0:
            if verbosity>=1:
                print("Vertical divergence less than zero ({}) doesn't make sense.".format(vertical))
            
        elif vertical>0.15:
            if verbosity>=1:
                print("Vertical divergence should be less than 0.15 mrad.")
                
        else:
            if verbosity>=3:
                print('Changing vertical divergence from {:.3f} mrad to {:.3f} mrad.'.format(v, vertical))
            caput('FE:C11B-OP{Slt:12-Ax:Y}size', vertical_mm)
        

    
    # Experimental Shutter
    ########################################
    
    # def _old_is_on(self, verbosity=3):
    #     '''Returns true if the beam is on (experimental shutter open).'''
        
    #     blade1 = caget('XF:11BMB-OP{PSh:2}Pos:1-Sts')
    #     blade2 = caget('XF:11BMB-OP{PSh:2}Pos:2-Sts')
        
    #     if blade1==1 and blade2==1:
    #         if verbosity>=4:
    #             print('Beam on (shutter open).')
            
    #         return True
        
    #     else:
    #         if verbosity>=4:
    #             print('Beam off (shutter closed).')
            
    #         return False
    
    
    # def _old_on(self, verbosity=3, wait_time=0.1, poling_period=0.10, retry_time=2.0, max_retries=5):
    #     '''Turn on the beam (open experimental shutter).
    #     update: 090517, RL: change the wait_time from 0.005 to 0.1, change sleep to time.sleep'''
        
    #     if self.is_on(verbosity=0):
    #         if verbosity>=4:
    #             print('Beam on (shutter already open.)')
                
    #     else:
            
    #         itry = 0
    #         while (not self.is_on(verbosity=0)) and itry<max_retries:
            
    #             # Trigger the shutter to toggle state
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M112=1')
    #             time.sleep(wait_time)
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M111=1')
    #             time.sleep(wait_time)
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M112=0')
    #             time.sleep(wait_time)
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M111=1')
    #             time.sleep(wait_time)
                
    #             # Give the system a chance to update
    #             start_time = time.time()
    #             while (not self.is_on(verbosity=0)) and (time.time()-start_time)<retry_time:
    #                 if verbosity>=5:
    #                     print('  try {:d}, t = {:02.2f} s, state = {:s}'.format(itry+1, (time.time()-start_time), 'OPEN_____' if self.is_on(verbosity=0) else 'CLOSE===='))
    #                 time.sleep(poling_period)
                
    #             itry += 1
                

    #         if verbosity>=4:
    #             if self.is_on(verbosity=0):
    #                 print('Beam on (shutter opened).')
    #             else:
    #                 print("Beam off (shutter didn't open).")


    # def _old_off(self, verbosity=3, wait_time=0.1, poling_period=0.10, retry_time=2.0, max_retries=5):
    #     '''Turn off the beam (close experimental shutter).
    #     update: 090517, RL: change the wait_time from 0.005 to 0.1, change sleep to time.sleep'''
        
    #     if self.is_on(verbosity=0):
            
    #         itry = 0
    #         while self.is_on(verbosity=0) and itry<max_retries:
    #             # Trigger the shutter to toggle state
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M112=1')
    #             time.sleep(wait_time)
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M111=1')
    #             time.sleep(wait_time)
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M112=0')
    #             time.sleep(wait_time)
    #             caput('XF:11BMB-CT{MC:06}Asyn.AOUT','M111=1')
    #             time.sleep(wait_time)

    #             # Give the system a chance to update
    #             start_time = time.time()
    #             while self.is_on(verbosity=0) and (time.time()-start_time)<retry_time:
    #                 if verbosity>=5:
    #                     print('  try {:d}, t = {:02.2f} s, state = {:s}'.format(itry+1, (time.time()-start_time), 'OPEN_____' if self.is_on(verbosity=0) else 'CLOSE===='))
    #                 time.sleep(poling_period)
                
    #             itry += 1



    #         if verbosity>=4:
    #             if self.is_on(verbosity=0):
    #                 print("Beam on (shutter didn't close).")
    #             else:
    #                 print('Beam off (shutter closed).')
                
    #     else:
    #         if verbosity>=4:
    #             print('Beam off (shutter already closed).')
                

    def is_on(self, verbosity=3):
        '''Returns 1 if the beam is on (experimental shutter open).'''
        if verbosity>=3:
            shutter_state(verbosity=verbosity)
        return shutter_state(verbosity=0)

    def on(self, verbosity=3, wait_time=0.1, poling_period=0.10, retry_time=2.0, max_retries=5):
        '''Turn on the beam (open experimental shutter).
        update: 090517, RL: change the wait_time from 0.005 to 0.1, change sleep to time.sleep'''
        
        if self.is_on(verbosity=0):
            if verbosity>=4:
                print('Beam on (shutter already open.)')
                
        else:
            
            RE(shutter_on(verbosity=0))
            if verbosity>=4:
                if self.is_on(verbosity=0):
                    print('Beam on (shutter opened).')
                else:
                    print("Beam off (shutter didn't open).")
    
    def off(self, verbosity=3, wait_time=0.1, poling_period=0.10, retry_time=2.0, max_retries=5):
        '''Turn off the beam (close experimental shutter).
        update: 090517, RL: change the wait_time from 0.005 to 0.1, change sleep to time.sleep'''
        
        if self.is_on(verbosity=0):
            
            RE(shutter_off(verbosity=0))

            if verbosity>=4:
                if self.is_on(verbosity=0):
                    print("Beam on (shutter didn't close).")
                else:
                    print('Beam off (shutter closed).')
                
        else:
            if verbosity>=4:
                print('Beam off (shutter already closed).')
                
    def blade1_is_on(self, verbosity=3):
        '''Returns true if the beam is on (experimental shutter open).'''
        
        blade1 = caget('XF:11BMB-OP{PSh:2}Pos:1-Sts')
        
        if blade1==1:
            if verbosity>=4:
                print('Beam on (shutter open).')
            
            return True
        
        else:
            if verbosity>=4:
                print('Beam off (shutter closed).')
            
            return False

    def blade2_is_on(self, verbosity=3):
        '''Returns true if the beam is on (experimental shutter open).'''
        
        blade2 = caget('XF:11BMB-OP{PSh:2}Pos:2-Sts')
        
        if blade2==1:
            if verbosity>=4:
                print('Beam on (shutter open).')
            
            return True
        
        else:
            if verbosity>=4:
                print('Beam off (shutter closed).')
            
            return False
                


    # Attenuator/Filter Box
    ########################################

    def transmission(self, verbosity=3):
        """
        Returns the current beam transmission through the attenuator/filter box.
        To change the transmission, use 'setTransmission'.
        """
        
        energy_keV = self.energy(verbosity=0)
        
        if energy_keV < 6.0 or energy_keV > 18.0:
            print('Transmission data not available at the current X-ray energy ({.2f} keV).'.format(energy_keV))
            
        else:
            
            # The states of the foils in the filter box
            N = [ caget('XF:11BMB-OP{{Fltr:{:d}}}Pos-Sts'.format(ifoil)) for ifoil in range(1, 8+1) ]
            # N = [fil.sts.get() for fil in self.atten_filter.values()]
            tr_tot = self.calc_transmission_filters(N, verbosity=verbosity)
                    
            return tr_tot


    def calc_transmission_filters(self, filter_settings, energy_keV=None, verbosity=3):
        """
        Returns the computed transmission value for the given configuration of
        foils. Note that the foils are not actually moved. This is just a
        calculation.
        
        Parameters
        ----------
        filter_settings : array of length 8
            Each element must be either a zero (foil removed) or a 1 (foil blocking 
            beam)
        energy_keV : float
            If 'None', the current energy is used. If specified, the calculation 
            is performed for the requested energy.
            
        Returns                
                

        -------
        transmission : float
            The computed transmission value of the x-ray beam through the filter box.
        """
        
        if energy_keV == None:
            energy_keV = self.energy(verbosity=0)
            
        if len(filter_settings) != 8:
            print('States for all eight foils must be specified.')

        else:
            N = filter_settings
            
            E = energy_keV
            E2 = np.square(E)
            E3 = np.power(E, 3)
                        

            # foil thickness blocking the beam
            N_Al = N[0] + 2*N[1] + 4*N[2] + 8*N[3]
            N_Nb = N[4] + 2*N[5] + 4*N[6] + 8*N[7]

            d_Nb = 0.1      # Thickness [mm] of one Nb foil 
            d_Al = 0.25     # Thickness [mm] of one Al foil 

            # Absorption length [mm] based on fits to LBL CXRO data for 6 < E < 19 keV
            l_Nb = 1.4476e-3 - 5.6011e-4 * E + 1.0401e-4 * E2 + 8.7961e-6 * E3
            l_Al = 5.2293e-3 - 1.3491e-3 * E + 1.7833e-4 * E2 + 1.4001e-4 * E3

            # transmission factors
            tr_Nb = np.exp(-N_Nb*d_Nb/l_Nb)
            tr_Al = np.exp(-N_Al*d_Al/l_Al)
            tr_tot = tr_Nb*tr_Al
                
            if verbosity>=5:
                print('  state:      {} T = {:.6g}'.format(filter_settings, tr_tot))
            if verbosity>=4:
                print('{:d} × 0.25 mm Al ({:.4g}) and {:d} × 0.10 mm Nb ({:.4g})'.format(N_Al, tr_Al, N_Nb, tr_Nb) )
            if verbosity>=1:
                print('transmission = {:.6g}'.format(tr_tot))
                
            return tr_tot
            
        

    def set_attenuation_filters(self, filter_settings, verbosity=3):
        """
        Sets the positions (in/out) for each of the foils in the attenuator/
        filter box. The input 'filter_settings' should be an array of length
        8, where each element is either a zero (foil removed) or a 1 (foil
        blocking beam).
        """
        
        if verbosity>=4:
            print('Filters:')
            # The states of the foils in the filter box
            filters_initial = [ caget('XF:11BMB-OP{{Fltr:{:d}}}Pos-Sts'.format(ifoil)) for ifoil in range(1, 8+1) ]
            print('  initial:    {} T = {:.6g}'.format(filters_initial, self.calc_transmission_filters(filters_initial, verbosity=0)))
            print('  requested:  {} T = {:.6g}'.format(filter_settings, self.calc_transmission_filters(filter_settings, verbosity=0)))
        
        if len(filter_settings) != 8:
            print('States for all eight foils must be specified.')
            
        else:
            
            for i, state in enumerate(filter_settings):
                
                ifoil = i+1
                
                if state==1:
                    # Put foil #ifoil into the beam
                    caput( 'XF:11BMB-OP{{Fltr:{:d}}}Cmd:In-Cmd'.format(ifoil) , 1 )
                    
                elif state==0:
                    # Remove foil #ifoil
                    caput( 'XF:11BMB-OP{{Fltr:{:d}}}Cmd:Out-Cmd'.format(ifoil) , 1 )
                    
                else:
                    if verbosity>=3:
                        state_actual = caget( 'XF:11BMB-OP{{Fltr:{:d}}}Pos-Sts'.format(ifoil) )
                        state_actual_str = 'IN' if state_actual == 1 else 'OUT'
                        print('WARNING: Filter state {} not recognized. Filter {:d} is {:s}.'.format(state, ifoil, state_actual_str))
                    

        
            time.sleep(1.) # Wait for filter box to settle
            
        if verbosity>=4:
            filters_final = [ caget('XF:11BMB-OP{{Fltr:{:d}}}Pos-Sts'.format(ifoil)) for ifoil in range(1, 8+1) ]
            print('  final:      {} T = {:.6g}'.format(filters_final, self.calc_transmission_filters(filters_final, verbosity=0)))

        
    def setTransmission(self, transmission, retries=3, tolerance=0.7, verbosity=3):
        """
        Sets the transmission through the attenuator/filter box.
        Because the filter box has a discrete set of foils, it is impossible to
        exactly match a given transmission value. A nearby value will be
        selected.
        """
        
        energy_keV = self.energy(verbosity=0)
        
        if energy_keV < 6.0 or energy_keV > 18.0:
            print('Transmission data not available at the current X-ray energy ({.2f} keV).'.format(energy_keV))
            
        elif transmission > 1.0:
            print('A transmission above 1.0 is not possible.')
            
        elif transmission < 1e-10:
            print('A transmission this low ({:g}) cannot be reliably achieved.'.format(transmission))
            
        else:
            
            E = energy_keV
            E2 = np.square(E)
            E3 = np.power(E, 3)
            
            d_Nb = 0.1      # Thickness [mm] of one Nb foil 
            d_Al = 0.25     # Thickness [mm] of one Al foil 

            # Absorption length [mm] based on fits to LBL CXRO data for 6 < E < 19 keV
            l_Nb = 1.4476e-3 - 5.6011e-4 * E + 1.0401e-4 * E2 + 8.7961e-6 * E3
            l_Al = 5.2293e-3 - 1.3491e-3 * E + 1.7833e-4 * E2 + 1.4001e-4 * E3

            d_l_Nb = d_Nb/l_Nb
            d_l_Al = d_Al/l_Al

            # Number of foils to be inserted (equivalent to "XIA_attn.mac" from X9) 
            #N_Nb = int(-log(transmission)/d_l_Nb)
            ##N_Al = int((-log(transmission) - N_Nb*d_l_Nb)/(d_l_Al-0.5))
            #N_Al = int((-log(transmission) - N_Nb*d_l_Nb)/d_l_Al)

            # Number of foils to be inserted (picks a set that gives smallest deviation from requested transmission)
            dev = []
            for i in np.arange(16):
                for j in np.arange(16):
                    dev_ij = abs(transmission - exp(-i*d_l_Nb)*exp(-j*d_l_Al))
                    dev.append(dev_ij)
                    if (dev_ij == min(dev)):
                        N_Nb = i                    # number of Nb foils selected
                        N_Al = j                    # number of Al foils selected
                
                


            N = []
            state = N_Al
            for i in np.arange(4):
                N.append(state % 2)
                state = int(state/2)

            state = N_Nb
            for i in np.arange(4):
                N.append(state % 2)
                state = int(state/2)

            self.set_attenuation_filters(N, verbosity=verbosity)
            
        
        # Check that transmission was actually correctly changed
        if abs(self.transmission(verbosity=0)-transmission)/transmission > tolerance:
            if retries>0:
                #time.sleep(0.5)
                # Try again
                return self.setTransmission(transmission, retries=retries-1, tolerance=tolerance, verbosity=verbosity)
            
            else:
                print("WARNING: transmission didn't update correctly (request: {}; actual: {})".format(transmission, self.transmission(verbosity=0)))

        
        return self.transmission(verbosity=verbosity)


    
    ## Nb foil absorber, before slit s5
    ########################################
    
    def absorber(self, verbosity=3):
        """
        Returns the current absorber position and absorption transmission.
        To change the absorption for XRR, use 'setabsorber'.
        """
        
        energy_keV = self.energy(verbosity=0)
        
        if energy_keV < 6.0 or energy_keV > 18.0:
            print('Transmission data not available at the current X-ray energy ({.2f} keV).'.format(energy_keV))
            
        else:
            
            # The foil layers 
            slot = np.floor((armr.position - self.armr_absorber_o+3-.1)/6)
            if slot >6 or slot<0:
                return print('Absorber slot should in the range of [0, 6]')
            
            return self.absorberCalcTransmission(slot, verbosity=verbosity)

    def absorber_out(self, verbosity=3):
        """
        Returns the current absorber position and absorption transmission.
        To change the absorption for XRR, use 'setabsorber'.
        """
        
        energy_keV = self.energy(verbosity=0)
        
        armr.move(self.armr_absorber_out)
        print('The absorber is completely out of the beam')
        
    def absorberCalcTransmission(self, slot, verbosity=3):
        
        energy_keV = self.energy(verbosity=0)
        
        E = energy_keV
        E2 = np.square(E)
        E3 = np.power(E, 3)
            
        d_Nb = 0.110      # Thickness [mm] of one Nb foil (nominally 0.1 mm); this yields one-foil transmission of 0.041 at 13.5 keV, close to measured value 

        # Absorption length [mm] based on fits to LBL CXRO data for 6 < E < 19 keV
        l_Nb = 1.4476e-3 - 5.6011e-4 * E + 1.0401e-4 * E2 + 8.7961e-6 * E3
        d_l_Nb = d_Nb/l_Nb

        absorber_transmission = exp(-slot*d_l_Nb)
        
        if abs(E - 13.5) < 0.01:
            self.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]    # at E = 13.5keV
        elif abs(E - 17) < 0.01:
            self.absorber_transmission_list = self.absorber_transmission_list_17kev
        elif abs(E - 10) < 0.1:
            self.absorber_transmission_list = self.absorber_transmission_list_10kev
            
        else:
            tmp_list = []
            for i in np.arange(6+1):
                tmp_list.append(exp(-i*d_l_Nb))
            self.absorber_transmission_list = tmp_list

        if verbosity>=1:
            print('transmission = {:.6g}'.format(absorber_transmission))
        
        return slot, absorber_transmission
        
    def setAbsorber(self, slot, retries=3, tolerance=0.5, verbosity=3):
        """
        Set the aborber of Nb foils for XRR measurements.
        There are 6 layers of foil which gives the attenuation rate ~5-6% at 13.5kev.
        """
        
        energy_keV = self.energy(verbosity=0)
        
        if energy_keV < 6.0 or energy_keV > 18.0:
            print('Transmission data not available at the current X-ray energy ({.2f} keV).'.format(energy_keV))
        elif slot < 0 or slot > 6:
            print('Absorber cannot move beyond [0, 6]')
                          
        else:
            
            #move to slot # for correct attenuation.
            armr.move(self.armr_absorber_o+slot*6)  # 6 mm wide per slot
                
        # Check that absorber was actually correctly moved
        if abs(armr.position-(self.armr_absorber_o+slot*6)) > tolerance:
            if retries>0:
                #time.sleep(0.5)
                # Try again
                return self.absorberCalcTransmission(slot), self.setAbsorber(slot, retries=retries-1, tolerance=tolerance, verbosity=verbosity)
            
            else:
                print("WARNING: transmission didn't update correctly (request: {}; actual: {})".format(slot, self.transmission(verbosity=0)))        

        else:
            return self.absorberCalcTransmission(slot)
        
        
    # Flux estimates at various points along the beam
    ########################################
    
    # TBD
    
    
    # Flux diagnostics
    ########################################
    
    def fluxes(self, verbosity=3):
        """
        Outputs a list of fluxes at various points along the beam. Also checks 
        the state (in or out of the beam) of various components, to help identify
        if anything could be blocking the beam.
        """
        
        if verbosity>=1:
            print('+--------+------------------+-----+-------------+-------------+-------------+')
            print('| pos    | name             |path | reading     | flux (ph/s) | expected    |')
            print('|--------|------------------|-----|-------------|-------------|-------------|')
            
        
        last_z = -100
        beam = True
        
        flux_expected = None
        
        for element in self.elements:
            
            state = element.state()
            if state == 'block':
                beam = False
            
            if verbosity>=4:
                if element.zposition >= 0 and last_z < 0:
                    print('| Front End                 |     |             |             |             |')
                if element.zposition > 25 and last_z < 25:
                    print('| FOE                       |     |             |             |             |')
                if element.zposition > 50 and last_z < 50:
                    print('| Endstation                |     |             |             |             |')
            last_z = element.zposition
            flux_expected
            if verbosity>=1:
                
                
                if state == 'in':
                    if beam:
                        path = '(|)'
                    else:
                        path = '(-)'
                elif state == 'out':                
                

                    if beam:
                        path = ' | '
                    else:
                        path = '---'
                elif state == 'block':
                    path = '[X]'
                    beam = False
                
                elif state == 'undefined':
                    if beam:
                        path = '?|?'
                    else:
                        path = '?-?'
                
                else:
                    path = '???'
                    


                
                
                if flux_expected == None or not beam:
                    flux_expected_str = ''
                else:
                    flux_expected_str = '{:11.3g}'.format(flux_expected)
                    flux_expected *= element.transmission(verbosity=0)


                
                
                if callable(getattr(element, 'reading', None)):
                    reading_str = '{:11.3g}'.format(element.reading(verbosity=0))
                    state = element.state()
                    if element.has_flux and (state=='in' or state=='block'):
                        flux_cur = element.flux(verbosity=0)
                        flux_expected = flux_cur
                        flux_str = '{:11.3g}'.format(flux_cur)
                    else:
                        flux_str = ''
                    
                else:
                    reading_str = ''
                    flux_str = ''
                    
            
                
                print('|{:5.1f} m | {:16.16} | {:s} | {:11.11} | {:11.11} | {:11.11} |'.format(element.zposition, element.name, path, reading_str, flux_str, flux_expected_str))
                
                
            #beam = True # For testing
                
                
        if verbosity>=1:
            print('+--------+------------------+-----+-------------+-------------+-------------+')

            
            


    # End class CMSBeam(object)
    ########################################
    


beam = CMSBeam()


class Beamline(object):
    '''Generic class that encapsulates different aspects of the beamline.
    The intention for this object is to have methods that activate various 'standard'
    protocols or sequences of actions.'''

    def __init__(self, **kwargs):
        
        self.md = {}
        self.current_mode = 'undefined'
        
        
    def mode(self, new_mode):
        '''Tells the instrument to switch into the requested mode. This may involve
        moving detectors, moving the sample, enabling/disabling detectors, and so
        on.'''
        
        getattr(self, 'mode'+new_mode)()
        
        
    def get_md(self, prefix=None, **md):
        '''Returns a dictionary of the current metadata.
        The 'prefix' argument is prepended to all the md keys, which allows the
        metadata to be grouped with other metadata in a clear way. (Especially,
        to make it explicit that this metadata came from the beamline.)'''
        
        # Update internal md
        #self.md['key'] = value

        md_return = self.md.copy()
    
        # Add md that may change
        md_return['mode'] = self.current_mode
    
        # Include the user-specified metadata
        md_return.update(md)

        # Add an optional prefix
        if prefix is not None:
            md_return = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_return.items() }
    
        return md_return
            
        
    def comment(self, text, logbooks=None, tags=None, append_md=True, **md):
        
        text += '\n\n[comment for beamline: {}]'.format(self.__class__.__name__)
        
        if append_md:
        
            # Global md
            md_current = { k : v for k, v in RE.md.items() }
            
            # Beamline md
            md_current.update(self.get_md())
            
            # Specified md
            md_current.update(md)
            
            text += '\n\n\nMetadata\n----------------------------------------'
            for key, value in sorted(md_current.items()):
                text += '\n{}: {}'.format(key, value)
        
        logbook.log(text, logbooks=logbooks, tags=tags)
        
        
    def log_motors(self, motors, verbosity=3, **md):
      
        log_text = 'Motors\n----------------------------------------\nname | position | offset | direction |\n'
      
        for motor in motors:
            offset = float(caget(motor.prefix+'.OFF'))
            direction = int(caget(motor.prefix+'.DIR'))
            log_text += '{} | {} | {} | {} |\n'.format(motor.name, motor.user_readback.value, offset, direction)
      
      
        md_current = { k : v for k, v in RE.md.items() }
        md_current.update(md)
        log_text += '\nMetadata\n----------------------------------------\n'
        for k, v in sorted(md_current.items()):
            log_text += '{}: {}\n'.format(k, v)
            
        if verbosity>=3:
            print(log_text)
            
        self.comment(log_text)
            

                

#from nslsii.devices.devices import TwoButtonShutter

class CMS_Beamline(Beamline):
    '''This object collects together various standard protocols and sequences
    of action used on the CMS (11-BM) beamline at NSLS-II.'''
    
    
    def __init__(self, **kwargs):
        
        super().__init__(**kwargs)
        
        self.beam = beam
        #self.SAXS = CMS_SAXS_Detector(pilatus300)
        self.SAXS = CMS_SAXS_Detector(pilatus2M)
        self.WAXS = CMS_WAXS_Detector(pilatus800)
        self.MAXS = CMS_SAXS_Detector(pilatus300)
        
        from epics import PV
        
        self._chamber_pressure_pv = PV('XF:11BMB-VA{Chm:Det-TCG:1}P-I')
        self._PV_Smpl_pressure = PV('XF:11BMB-VA{Chm:Smpl-TCG:1}P-I')
        self._PV_Det_pressure = PV('XF:11BMB-VA{Chm:Det-TCG:1}P-I')
        self._PV_SAXS_pressure = PV('XF:11BMB-VA{BS:SAXS-TCG:1}P-I')
        
        self.detector = [] 
        self.PLOT_Y = []
        self.TABLE_COLS = []
        #self.bsx_pos = []
        self.FM_donefiles = []

        #PV list before changes: 
        #sample vent:  XF:11BMB-VA{Chm:Smpl-VV:1}
        #sample soft vent:  XF:11BMB-VA{Chm:Smpl-VV_Soft:1}
        #detector vent: XF:11BMB-VA{Chm:Det-VV:1}
        #detector soft vent: XF:11BMB-VA{Chm:Det-VV:1_Soft}
        #detector pump: XF:11BMB-VA{Chm:Det-IV:1}
        #detector soft pump: XF:11BMB-VA{Chm:Det-IV:1_Soft}
        
        #PV list in future
        #sample vent:  XF:11BMB-VA{Chm:Smpl-VV:1}
        #sample soft vent:  XF:11BMB-VA{Chm:Smpl-VV_Soft:1}
        #sample pump : XF:11BMB-VA{Chm:Smpl-VV:1}   --------------NEW
        #sample soft pump: XF:11BMB-VA{Chm:Smpl-VV:1_Soft}    ------------NEW
        #detector pump: XF:11BMB-VA{Chm:Det-IV:1}
        #detector soft pump: XF:11BMB-VA{Chm:Det-IV:1_Soft}
        
        self._PV_Smpl_vent = 'XF:11BMB-VA{Chm:Smpl-VV:1}'
        self._PV_Smpl_vent_soft = 'XF:11BMB-VA{Chm:Smpl-VV_Soft:1}'
        self._PV_Smpl_pump = 'XF:11BMB-VA{Chm:Smpl-IV:1}' # --------------NEW
        self._PV_Smpl_pump_soft = 'XF:11BMB-VA{Chm:Smpl-IV:1_Soft}'   # ------------NEW
        self._PV_Det_pump = 'XF:11BMB-VA{Chm:Det-IV:1}'
        self._PV_Det_pump_soft = 'XF:11BMB-VA{Chm:Det-IV:1_Soft}'
        self._PV_SAXS_GV = 'XF:11BMB-VA{Chm:Det-GV:1}'
        self._PV_SAXS_pump = 'XF:11BMB-VA{BT:SAXS-IV:1}'
        self._PV_FS4_pump = 'XF:11BMB-VA{FS:4-IV:1_Soft}'
 
        self._vent_Smpl = TriState('XF:11BMB-VA{Chm:Smpl-V', name='vent_Smpl')
        self._pump_Smpl = TriState('XF:11BMB-VA{Chm:Smpl-I', name='pump_Smpl')
        self._pump_Det = TriState('XF:11BMB-VA{Chm:Det-I', name='pump_Det')
        self._pump_Pipe = TriState('XF:11BMB-VA{BT:SAXS-IV', name='pump_Pipe')
        self._pump_FS4 = TriState('XF:11BMB-VA{FS:4-IV', name='pump_FS4')
        self._GV_SAXS = TwoButtonShutterNC('XF:11BMB-VA{Chm:Det-GV:1}', name='GV_SAXS')
        self._pump1_toggle = EpicsSignal('XF:11BMB-VA{BT:SAXS-Pmp:1}Cmd:Enbl-Cmd', name='pump1_toggle')
        self._pump1_state = EpicsSignal('XF:11BMB-VA{BT:SAXS-Pmp:1}Sts:Enbl-Sts', name='pump1_state')
        self._pump2_toggle = EpicsSignal('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', name='pump1_toggle')
        self._pump2_state = EpicsSignal('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts', name='pump1_state')
        
        self._WAXS_outlet_sts = EpicsSignal('XF:11BMB-VA{Chm:Det}UserCmd-Sts', name='WAXS_outlet_sts')
        self._WAXS_outlet_toggle = EpicsSignal('XF:11BMB-VA{Chm:Det}UserButton', name='WAXS_outlet_toggle')
        
    def modeAlignment_bim6(self, verbosity=3):
        
        self.current_mode = 'undefined'
        
        # TODO: Check what mode (TSAXS, GISAXS) and respond accordingly
        # TODO: Check if gate valves are open and flux is okay (warn user)
        
        
        self.beam.off()
        #self.beam.setTransmission(1e-4)
        self.beam.setTransmission(5e-4)
        
        #mov( [DETx, DETy], [0, 0] )
        self.beam.bim6.insert()
        
        caput('XF:11BMB-BI{IM:2}EM180:Acquire', 1) # Turn on bim6
        detselect(bim6, suffix='')
        
        self.current_mode = 'alignment'
        
        self.beam.bim6.reading()

    def modeMeasurement_bim6(self, verbosity=3):
        
        self.current_mode = 'undefined'
        
        self.beam.off()
        self.beam.setTransmission(1)
        
        #mov(DETy, -16)
        self.beam.bim6.retract()
        
        caput('XF:11BMB-BI{IM:2}EM180:Acquire', 0) # Turn off bim6
        #detselect(pilatus300)
        detselect(pilatus_name)
        
        #if RE.state is not 'idle':
        #    RE.abort()
        
        self.current_mode = 'measurement'
        
        # Check if gate valves are open
        if self.beam.GVdsbig.state() != 'out' and verbosity>=1:
            print('Warning: Sample chamber gate valve (large, downstream) is not open.')
            

    def modeAlignment(self, verbosity=3):
        
        self.current_mode = 'undefined'
        
        # TODO: Check what mode (TSAXS, GISAXS) and respond accordingly
        # TODO: Check if gate valves are open and flux is okay (warn user)
        # TODO: Check list: change attenuator for different energy, change the bsx position with beamcenter accordingly
        
        
        self.beam.off()
        self.beam.setTransmission(1e-8)  #1e-6 for 13.5kev, 1e-8 for 17kev
        while beam.transmission() > 3e-8:
            time.sleep(0.5)
            self.beam.setTransmission(1e-8)
            
        #mov(bsx, -10.95)
        bsx.move(self.bsx_pos+5)
            
        #detselect(pilatus300, suffix='_stats4_total')
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', 0.5)
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', 0.6)

        detselect(pilatus_name, suffix='_stats4_total')
        RE(pilatus_name.setExposureTime(0.5))
        #Comment out by RL, 071617
        #caput('XF:11BMB-ES{}:cam1:AcquireTime'.format(pilatus_Epicsname), 0.5)
        #caput('XF:11BMB-ES{}:cam1:AcquirePeriod'.format(pilatus_Epicsname), 0.6)
        #caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquirePeriod', 0.6)
       
        #TODO: Update ROI based on current SAXSx, SAXSy and the md in cms ob'XF:11BMB-VA{Chm:Smpl-VV:1_Soft}'ject
        
        self.current_mode = 'alignment'
        
        #self.beam.bim6.reading()


    def modeMeasurement(self, verbosity=3):   
        
        self.current_mode = 'undefined'
        
        self.beam.off()
        
        #mov(bsx, -15.95)
        bsx.move(self.bsx_pos)

        if abs(bsx.user_readback.value - self.bsx_pos)>0.1:
            print('WARNING: Beamstop did not return to correct position!')
            return
        
        self.beam.setTransmission(1)
        
        #detselect(pilatus300)
        #detselect([pilatus300, psccd])
        detselect(pilatus_name)
        #detselect(psccd)
        
        #if RE.state is not 'idle':
        #    RE.abort()

       
        self.current_mode = 'measurement'
        
        # Check if gate valves are open
        if self.beam.GVdsbig.state() != 'out' and verbosity>=1:
            print('Warning: Sample chamber gate valve (large, downstream) is not open.')
            
    def modeBeamstopAlignment(self, verbosity=3):
        '''Places bim6 (dsmon) as a temporary beamstop.'''
        
        DETy.move(-6.1)
        
        
        
    def beamstopCircular(self, verbosity=3):
        
        self.beam.setTransmission(1e-6)
        
        bsx.move(0)
        bsy.move(0)
        bsphi.move(-12.0)
        bsx.move(self.bsx_pos)
        bsy.move(-15.47)
        
        # TODO: Capture image and confirm that it's okay?
        if verbosity>=1:
            print("WARNING: This routine merely puts the beamstop in the ~approximately~ correct position. You must confirm that the beam is being blocked correctly.")
            
        self.beam.transmission(verbosity=verbosity)


    def beamstopLinear(self, verbosity=3):
        
        self.beam.setTransmission(1e-6)
        
        bsx.move(0)
        bsy.move(0)
        bsphi.move(-223.4)
        bsx.move(self.bsx_pos)
        bsy.move(17)
        
        # TODO: Capture image and confirm that it's okay?
        if verbosity>=1:
            print("WARNING: This routine merely puts the beamstop in the ~approximately~ correct position. You must confirm that the beam is being blocked correctly.")
            
        self.beam.transmission(verbosity=verbosity)
            
        
        
    def _actuate_open(self, pv, max_tries=5, wait_time=1.0, verbosity=2):
        
        tries = 1
        if verbosity>=4:
            print('  Opening {} (try # {:d})'.format(pv, tries))
        caput(pv+'Cmd:Opn-Cmd', 1)
        time.sleep(wait_time)
        
        
        while caget(pv+'Pos-Sts')!= 1 and tries<max_tries:
            tries += 1
            if verbosity>=4:
                print('  Opening {} (try # {:d})'.format(pv, tries))
            caput(pv+'Cmd:Opn-Cmd', 1)
            time.sleep(wait_time)
            
        if verbosity>=1 and caget(pv+'Pos-Sts')!= 1:
            print('ERROR, valve did not open ({})'.format(pv))

    def _actuate_close(self, pv, max_tries=5, wait_time=1.0, verbosity=2):
        
        tries = 1
        if verbosity>=4:
            print('  Closing {} (try # {:d})'.format(pv, tries))
        caput(pv+'Cmd:Cls-Cmd', 1)
        time.sleep(wait_time)
        
        
        while caget(pv+'Pos-Sts')!= 0 and tries<max_tries:
            tries += 1
            if verbosity>=4:
                print('  Closing {} (try # {:d})'.format(pv, tries))
            caput(pv+'Cmd:Cls-Cmd', 1)
            time.sleep(wait_time)
            
        if verbosity>=1 and caget(pv+'Pos-Sts')!= 0:
            print('ERROR, valve did not close ({})'.format(pv))

    def _actuate_state(self, pv, wait_time=0, verbosity=2):
        
        tries = 1
        if verbosity>=4:
            print('  Checking state of PV ::: {} '.format(pv))
        time.sleep(wait_time)
        return caget(pv+'Pos-Sts')

    #020620, define the gate for vacuum
    #TODO:homeF and homeR
    #def gateIn(self):
        #gatex.move(0)
        ##home
        ##caput('XF:11BMB-ES{Chm:Gate-Ax:X}Start:Home-Cmd',1)

    #def gateOut(self):
        #gatex.move(-95)
        #

    def _gateIn(self):
        yield from  bps.mov(gatex, 0)
        #home
        #caput('XF:11BMB-ES{Chm:Gate-Ax:X}Start:Home-Cmd',1)

    def _gateOut(self):
        yield from  bps.mov(gatex, -95)

    def _gateHome(self):
        gatex.move(-5)
        caput('XF:11BMB-ES{Chm:Gate-Ax:X}Start:Home-Cmd', 1)
        #yield from  bps.mov(gatex, -95)

    def _gateState(self, verbosity=3):
        if abs(gatex.position-0)<0.1:
            state = True
            if verbosity>=3:
                print(' The gate is closed')
        else:
            state = False
            if verbosity>=3:
                print(' The gate is open')
        return state

    ##=====================================================================================================
    ##=====================================================================================================
    ##071617, RL, modify the pump/vent procedure for sample/WAXS area.
    ##the change is to vent the WAXS area manually and change the WAXS vent to sample pump
    ##the new detector pump and sample pump will still use the same pump2 
    ##New commands are listed in : http://gisaxs.com/CS/index.php/Beamline_vacuum
    
    ##PV list before changes: 
    ##sample vent:  XF:11BMB-VA{Chm:Smpl-VV:1}
    ##sample soft vent:  XF:11BMB-VA{Chm:Smpl-VV_Soft:1}
    ##detector vent: XF:11BMB-VA{Chm:Det-VV:1}
    ##detector soft vent: XF:11BMB-VA{Chm:Det-VV:1_Soft}
    ##detector pump: XF:11BMB-VA{Chm:Det-IV:1}
    ##detector soft pump: XF:11BMB-VA{Chm:Det-IV:1_Soft}
    ##KB mirror pressure gauge: 'XF:11BMB-VA{Mir:KB-IV:1}' 
    
    ##PV list in future
    ##sample vent:  XF:11BMB-VA{Chm:Smpl-VV:1}
    ##sample soft vent:  XF:11BMB-VA{Chm:Smpl-VV_Soft:1}
    ##sample pump : XF:11BMB-VA{Chm:Smpl-VV:1}   --------------NEW
    ##sample soft pump: XF:11BMB-VA{Chm:Smpl-VV:1_Soft}    ------------NEW
    ##detector pump: XF:11BMB-VA{Chm:Det-IV:1}
    ##detector soft pump: XF:11BMB-VA{Chm:Det-IV:1_Soft}
    ##FS4 pressure gauge: 'XF:11BMB-VA{FS:4-IV:1}'
    
    #RE version of pumpSample
    def _pumpSample(self, threshold=0.7): 
        
        #check the difference of pressures
        start_time = time.time()
        if self.diffPressure(verbosity=0) != 1:
            return print('Check the system. Vacuum may be not necessary for the sample.')
        # close 2s vent valve
        yield from bps.mov(self._vent_Smpl, 'Close') 
        # close 2d pump valve -- protect WAXS detector
        yield from bps.mov(self._pump_Det, 'Close') 
        # open 2s pump 
        yield from bps.mov(self._pump_Smpl, 'Soft') 
        # start pump2 
        #yield from bps.mov(self._pump2_toggle, 1) 
        ## Check pump again
        yield from bps.sleep(10) 
        while self._pump2_state.get()!=1:
            yield from bps.mov(self._pump2_toggle, 0)
            yield from bps.sleep(1)
            yield from bps.mov(self._pump2_toggle, 1) 
            yield from bps.sleep(1)
        # Fully open valve to pump
        while self._PV_Smpl_pressure.get()>500:
            yield from bps.sleep(3) 
        yield from bps.mov(self._pump_Smpl, 'Open') 
        while self._PV_Smpl_pressure.get()>threshold: #gate cannot be open >0.5mbar
        #while self._PV_Smpl_pressure.get()>1: #gate cannot be open >0.5mbar
            print('waiting to complete pumping.')
            yield from bps.sleep(3) 
        yield from bps.mov(self._pump_Det, 'Open') 
        print('The pumping is completed after {}s.'.format(time.time()-start_time))
            
        #open window
        yield from self._gateOut()
        ###
        
    def _ventSample(self): 

        #close the Gate valve of SAXS pipe
        yield from bps.mov(self._GV_SAXS, 'Close')
        #turn off the outlet power of WAXS detector
        while self._WAXS_outlet_sts.get()==1: #if the outlet is on, close it
            yield from bps.mov(self._WAXS_outlet_toggle, 0) 
            time.sleep(.5)
        #close window
        yield from self._gateIn()
        ###
        start_time = time.time()
        start_p = self._PV_Det_pressure.get()
        #close 2s pump valve
        yield from bps.mov(self._pump_Smpl, 'Close') 
        yield from bps.sleep(5)
        #open 2s vent valve
        yield from bps.mov(self._vent_Smpl, 'Soft') 
        #yield from bps.sleep(1)
        #yield from bps.mov(self._vent_Smpl, 'Close') 
        #while self._PV_Det_pressure.get()<0.35:
            #yield from bps.sleep(5)
            #if self._PV_Det_pressure.get()<0.35:
                #yield from bps.mov(self._vent_Smpl, 'Soft') 
                #break
        #else :
            #yield from bps.mov(self._vent_Smpl, 'Close') 
            #yield from bps.sleep(10)
            #while self._PV_Det_pressure.get()>0.35:
                #yield from bps.sleep(10)
            #yield from bps.mov(self._vent_Smpl, 'Soft') 
        while self._PV_Smpl_pressure.get()<100:
            yield from bps.sleep(3)
        yield from bps.mov(self._vent_Smpl, 'Open')         
        while self._PV_Smpl_pressure.get()<980:
            print('waiting to complete venting.')
            yield from bps.sleep(3)
        print('The venting is completed after {}s.'.format(time.time()-start_time))
        
    def _changePipe(self):
        #close SAXS GV
        yield from bps.mov(self._GV_SAXS, 'Close')
        yield from bps.mov(self._pump_FS4, 'Close') 
        yield from bps.mov(self._pump_Pipe, 'Close') 
        while self._pump1_state.get()!=0:
            yield from bps.mov(self._pump2_toggle, 1) 
            yield from bps.sleep(1)
            yield from bps.mov(self._pump2_toggle, 0)
            yield from bps.sleep(1)
        

    def pumpSample(self, threshold=0.7):
        RE(self._pumpSample(threshold=threshold))
    def ventSample(self):
        RE(self._ventSample())
    def changePipe(self):
        RE(self.changePipe())

    #def pumpSample(self, max_tries=8, verbosity=3):
        ##check the difference of pressures
        #print('step 1')
        #if self.diffPressure(verbosity=0) != 1:
            #return print('Check the system. Vacuum may be not necessary for the sample.')
        
        ## close 2d pump valve -- protect WAXS detector
        ## close 2s vent valve
        #self._actuate_close(self._PV_Smpl_vent, verbosity=verbosity)
        #self._actuate_close(self._PV_Det_pump, verbosity=verbosity)
        
        #print('step 2')
        ## --checkpoint: the valves are closed
        #tries = 1
        #while self._actuate_state(self._PV_Det_pump)==1 or self._actuate_state(self._PV_Smpl_vent)==1:
            #if tries<=max_tries:
                #time.sleep(2.0)
                #tries += 1
            #else:
                #return print('Error: valve (Det_pump or Smpl_vent) is NOT closed')

        #print('step 3')
                 
        ## pump 2s 
        ## Soft-open valve to pump
        #self._actuate_close(self._PV_Smpl_pump, verbosity=verbosity)
        #time.sleep(0.5)
        #self._actuate_open(self._PV_Smpl_pump_soft, verbosity=verbosity)
        #time.sleep(1.0)
        ## Check pump 
        #print('step 4')

        #tries = 1
        #while caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0 and tries<=max_tries:
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            #time.sleep(1.0)
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
            #time.sleep(3.0)
            #tries += 1
        
        #time.sleep(10.0)
        ## Check pump again
        #tries = 1
        #while caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0 and tries<=max_tries:
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            #time.sleep(1.0)
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
            #time.sleep(3.0)
            #tries += 1        
        
        #print('step 5')

        #self.checkPressure(PV=self._PV_Smpl_pressure, range_low=500)

        ## Fully open valve to pump
        #self._actuate_close(self._PV_Smpl_pump_soft, verbosity=verbosity)
        #time.sleep(0.5)
        #self._actuate_open(self._PV_Smpl_pump, verbosity=verbosity)
        #print('step 6')
        
        #self.checkPressure(PV=self._PV_Smpl_pressure, range_low=5)
        #self._actuate_open(self._PV_Det_pump, verbosity=verbosity)

        ##open window
        #self.gateOut()
        ####


            
    #def ventSample(self, verbosity=3):
        ##close window
        #self.gateIn()
        ##self.closeKaptonWindow(verbosity=verbosity)
        ##close 2s pump valve
        #self._actuate_close(self._PV_Smpl_pump)
        ##--checkpoint: the valve/window are closed
        #tries=1
        #while self._actuate_state(self._PV_Smpl_pump)==1 or self.stateKaptonWindow==1:
            #if tries<=max_tries:
                #time.sleep(2.0)
                #tries += 1
            #else:
                #return print('sample pump valve or Kapton window is not closed') 
        
        #if verbosity>=3:
            #print('The valves are closed properly and venting is ready to start.')
            #time.sleep(3.0)
            
        ##open 2s vent valve
        ##--checkpoint: 2s pressure
        #self._actuate_close('XF:11BMB-VA{Chm:Smpl-VV:1}', verbosity=verbosity)
        #time.sleep(1.0)
        #self._actuate_open('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}', verbosity=verbosity)
        
        #self.checkPressure(PV=self._PV_Smpl_pressure, range_high=100)
        
        ## Fully open the upstream vent-vale
        #self._actuate_close('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}', verbosity=verbosity)
        #time.sleep(1.0)
        #self._actuate_open('XF:11BMB-VA{Chm:Smpl-VV:1}', verbosity=verbosity)

        #self.checkPressure(PV=self._PV_Smpl_pressure, range_high=990)
        
        ##close the GN2 valve and switch to air 
        #ioL.setOff(Relay[6])        
        #while ioL.read(Relay[6]) ==1:
            #time.sleep(1)
            #ioL.setOff(Relay[6])
                       
        #if verbosity>=1:
            #print('Sample chamber is ready to be opened.')
            
            
    
    def changePipe(self, max_tries=8, verbosity=3):
        #close GV for SAXS
        self._actuate_close(self._PV_SAXS_GV)
        #--checkpoint: the valves are closed
        tries=1
        while self._actuate_state(self._PV_SAXS_GV)==1:
            if tries<=max_tries:
                time.sleep(2.0)
                tries += 1
            else:
                return print('SAXS gate valve is not closed')
            
        #close pump valve for section 1 and 3
        self._actuate_close('XF:11BMB-VA{BT:SAXS-IV:1}')
        self._actuate_close('XF:11BMB-VA{Mir:KB-IV:1}')
        tries=1
        while self._actuate_state('XF:11BMB-VA{BT:SAXS-IV:1}')==1 or self._actuate_state('XF:11BMB-VA{Mir:KB-IV:1}')==1:
            if tries<=max_tries:
                time.sleep(2.0)
                tries += 1
            else:
                return print('Error: valves for pump1 are NOT closed properly.')
            
        #turn off pump1 
        while caget('XF:11BMB-VA{BT:SAXS-Pmp:1}Sts:Enbl-Sts')==1 and tries<=max_tries:
            caput('XF:11BMB-VA{BT:SAXS-Pmp:1}Cmd:Enbl-Cmd', 0)
            time.sleep(1.0)
    
    #def ventChamber(self, verbosity=3):
        #self.ventSample(verbosity=verbosity)
        #self.openKaptonWindow(verbosity=verbosity)

    #def pumpChamber(self, verbosity=3):
        #self.pumpSample(verbosity=verbosity)
        #self._actuate_open(self.PV_SAXS_GV)
        
    def checkPressure(self, PV, range_low=None, range_high=None, readout_period=1.0, verbosity=3):
        '''Monitors the pressure in the sample/WAXS chamber, printing the current value.
        If range arguments are provided, the monitoring will end once the pressure
        is outside the range.
        '''
        monitor = True
        while monitor:
            
            try:
            
                if range_low != None and PV.get()<range_low:
                    monitor = False
                    
                if range_high != None and PV.get()>range_high:
                    monitor = False

                P_mbar = PV.get()
                P_atm = P_mbar*0.000986923
                P_torr = P_mbar*0.750062
                P_kPa = P_mbar*0.1
                P_psi = 0.0145038
                
                if verbosity>=4:
                    print('Sample chamber pressure: {:8.2f} mbar = {:5.3f} atm = {:7.3f} torr = {:4.1g} kPa     \r'.format(P_mbar, P_atm, P_torr, P_kPa), end='', flush=True)
                elif verbosity>=2:
                    print('Sample chamber pressure: {:8.2f} mbar ({:5.3f} atm)    \r'.format(P_mbar, P_atm), end='', flush=True)
                    
                time.sleep(readout_period)
                
                
            except KeyboardInterrupt:
                monitor = False
    
    def diffPressure(self, verbosity=3):
        '''check the difference of pressures in the sample and WAXS chamber. 
        '''
        Smpl_pressure = self._PV_Smpl_pressure.get()
        Det_pressure = self._PV_Det_pressure.get()
        
        if Smpl_pressure < 1 and Det_pressure < 1:
            if verbosity>=3:
                print('Both Sample and WAXS are in vacuum.')
            return 0
        
        elif Smpl_pressure >950 and Det_pressure > 950:
            if verbosity>=3:
                print('Both Sample and WAXS are in air.')
            return 3
        
        elif Smpl_pressure > Det_pressure:
            if verbosity>=3:
                print('Sample pressure > WAXS pressure.')
            return 1
        
        elif Smpl_pressure < Det_pressure:
            if verbosity>=3:
                print('Sample pressure < WAXS pressure.')
            return 2
    ##=====================================================================================================
    ##=====================================================================================================
    
    
    #def ventChamber(self, verbosity=3):
        
        ##TODO: Remove the old (commented-out) caput lines
        
        ##open the GN2 valve and close the air valve
        #ioL.setOn(Relay[6])
        #while ioL.read(Relay[6]) ==0:
            #time.sleep(1)
            #ioL.setOn(Relay[6])
        
        ## Close large gate valve (downstream side of sample chamber)
        ##caput('XF:11BMB-VA{Chm:Det-GV:1}Cmd:Cls-Cmd',1)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-GV:1}', verbosity=verbosity)

        ## Close small gate valve (upstream side of sample chamber)
        ##caput('XF:11BMB-VA{Slt:4-GV:1}Cmd:Cls-Cmd',1)
        #self._actuate_close('XF:11BMB-VA{Slt:4-GV:1}', verbosity=verbosity)

        ## Close valve connecting sample chamber to vacuum pump
        ##caput('XF:11BMB-VA{Chm:Det-IV:1}Cmd:Cls-Cmd',1)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-IV:1}', verbosity=verbosity)
        
        ## Soft-open the upstream vent-valve
        ##caput('XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Smpl-VV:1}', verbosity=verbosity)
        #time.sleep(1.0)
        ##caput('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Opn-Cmd', 1)
        #self._actuate_open('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}', verbosity=verbosity)
        ## Soft-open the downstream vent-vale
        ##caput('XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-VV:1}', verbosity=verbosity)
        #time.sleep(1.0)
        ##caput('XF:11BMB-VA{Chm:Det-VV:1}Cmd:Opn-Cmd', 1)
        #self._actuate_open('XF:11BMB-VA{Chm:Det-VV:1_Soft}', verbosity=verbosity)
        
        #self.chamberPressure(range_high=100)
        
        ## Fully open the upstream vent-vale
        ##caput('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}', verbosity=verbosity)
        #time.sleep(1.0)
        ##caput('XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Opn-Cmd', 1)
        #self._actuate_open('XF:11BMB-VA{Chm:Smpl-VV:1}', verbosity=verbosity)

        ## Fully open the downstream vent-vale
        ##caput('XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Det  -VV:1_Soft}', verbosity=verbosity)
        #time.sleep(1.0)
        ##caput('XF:11BMB-VA{Chm:Det-VV:1}Cmd:Opn-Cmd', 1)
        #self._actuate_open('XF:11BMB-VA{Chm:Det-VV:1}', verbosity=verbosity)
        
        #self.chamberPressure(range_high=990)
        
        ##close the GN2 valve and switch to air 
        #ioL.setOff(Relay[6])        
        #while ioL.read(Relay[6]) ==1:
            #time.sleep(1)
            #ioL.setOff(Relay[6])
                       
        #if verbosity>=1:
            #print('Sample chamber is ready to be opened.')
        
            
        
    def _old_ventChamber(self, verbosity=3):
        # TODO: deprecate and delete
        
        
        # Close large gate valve (downstream side of sample chamber)
        caput('XF:11BMB-VA{Chm:Det-GV:1}Cmd:Cls-Cmd',1)

        # Close small gate valve (upstream side of sample chamber)
        #caput('XF:11BMB-VA{Slt:4-GV:1}Cmd:Cls-Cmd',1)

        # Close valve connecting sample chamber to vacuum pump
        caput('XF:11BMB-VA{Chm:Det-IV:1}Cmd:Cls-Cmd',1)
        
        time.sleep(0.5)
        
        # Soft-open the upstream vent-valve
        caput('XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Cls-Cmd', 1)
        time.sleep(1.0)
        caput('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Opn-Cmd', 1)
        
        
        
        self.chamberPressure(range_high=100)
        
        # Fully open the upstream vent-vale
        caput('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Cls-Cmd', 1)
        time.sleep(1.0)
        caput('XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Opn-Cmd', 1)

        # Fully open the downstream vent-vale
        caput('XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Cls-Cmd', 1)
        time.sleep(1.0)
        caput('XF:11BMB-VA{Chm:Det-VV:1}Cmd:Opn-Cmd', 1)
        
        self.chamberPressure(range_high=1000)
        
        if verbosity>=1:
            print('Sample chamber is ready to be opened.')
        
    
        
    def chamberPressure(self, range_low=None, range_high=None, readout_period=1.0, verbosity=3):
        '''Monitors the pressure in the sample chamber, printing the current value.
        If range arguments are provided, the monitoring will end once the pressure
        is outside the range.
        '''
        
        monitor = True
        while monitor:
            
            try:
            
                if range_low != None and self._chamber_pressure_pv.get()<range_low:
                    monitor = False
                    
                if range_high != None and self._chamber_pressure_pv.get()>range_high:
                    monitor = False

                P_mbar = self._chamber_pressure_pv.get()
                P_atm = P_mbar*0.000986923
                P_torr = P_mbar*0.750062
                P_kPa = P_mbar*0.1
                P_psi = 0.0145038
                
                if verbosity>=4:
                    print('Sample chamber pressure: {:8.2f} mbar = {:5.3f} atm = {:7.3f} torr = {:4.1g} kPa     \r'.format(P_mbar, P_atm, P_torr, P_kPa), end='', flush=True)
                elif verbosity>=2:
                    print('Sample chamber pressure: {:8.2f} mbar ({:5.3f} atm)    \r'.format(P_mbar, P_atm), end='', flush=True)
                    
                time.sleep(readout_period)
                
                
            except KeyboardInterrupt:
                monitor = False
                

        
        
    #def pumpChamber(self, max_tries=8, verbosity=3):
        
        ##close the GN2 valve and switch to air 
        #if ioL.read(Relay[6]) ==1:
            #ioL.setOff(Relay[6])        
            
        ## Close vent-valves
        ##caput('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Cls-Cmd', 1)
        ##caput('XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Cls-Cmd', 1)
        ##caput('XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Cls-Cmd', 1)
        ##caput('XF:11BMB-VA{Chm:Det-VV:1}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}', verbosity=verbosity)
        #self._actuate_close('XF:11BMB-VA{Chm:Smpl-VV:1}', verbosity=verbosity)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-VV:1_Soft}', verbosity=verbosity)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-VV:1}', verbosity=verbosity)
        
        ## Turn on pump (if necessary)
        #tries = 1
        #while caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0 and tries<=max_tries:
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            #time.sleep(0.2)
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
            #time.sleep(2.0)
            #tries += 1
        
        ## Soft-open valve to pump
        ##caput('XF:11BMB-VA{Chm:Det-IV:1}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-IV:1}', verbosity=verbosity)
        #time.sleep(0.5)
        ##caput('XF:11BMB-VA{Chm:Det-IV:1_Soft}Cmd:Opn-Cmd', 1)
        #self._actuate_open('XF:11BMB-VA{Chm:Det-IV:1_Soft}', verbosity=verbosity)
        
        #time.sleep(5.0)
        ## Check pump again
        #tries = 1
        #while caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0 and tries<=max_tries:
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            #time.sleep(1.0)
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
            #time.sleep(3.0)
            #tries += 1
        
        #time.sleep(10.0)
        ## Check pump again
        #tries = 1
        #while caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0 and tries<=max_tries:
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            #time.sleep(1.0)
            #caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
            #time.sleep(3.0)
            #tries += 1        
        
        #self.chamberPressure(range_low=500)

        ## Fully open valve to pump
        ##caput('XF:11BMB-VA{Chm:Det-IV:1_Soft}Cmd:Cls-Cmd', 1)
        #self._actuate_close('XF:11BMB-VA{Chm:Det-IV:1_Soft}', verbosity=verbosity)
        #time.sleep(0.5)
        ##caput('XF:11BMB-VA{Chm:Det-IV:1}Cmd:Opn-Cmd', 1)
        #self._actuate_open('XF:11BMB-VA{Chm:Det-IV:1}', verbosity=verbosity)
        
        #self.chamberPressure(range_low=200)
                
        
    def _old_pumpChamber(self, readout_delay=0.2):
        # TODO: deprecate and delete
        
        
        # Close vent-valves
        caput('XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Cls-Cmd', 1)
        time.sleep(0.5)
        caput('XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Cls-Cmd', 1)
        time.sleep(0.5)
        caput('XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Cls-Cmd', 1)
        time.sleep(0.5)
        caput('XF:11BMB-VA{Chm:Det-VV:1}Cmd:Cls-Cmd', 1)
        time.sleep(0.2)
        
        # Turn on pump (if necessary)
        if caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0:
            caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            time.sleep(0.2)
            caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
        
        # Soft-open valve to pump
        caput('XF:11BMB-VA{Chm:Det-IV:1}Cmd:Cls-Cmd', 1)
        time.sleep(1.0)
        caput('XF:11BMB-VA{Chm:Det-IV:1_Soft}Cmd:Opn-Cmd', 1)
        time.sleep(0.2)
        
        sleep(5.0)
        # Check pump again
        if caget('XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts')==0:
            caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 0)
            time.sleep(0.2)
            caput('XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd', 1)
        
        
        self.chamberPressure(range_low=500)

        # Fully open valve to pump
        caput('XF:11BMB-VA{Chm:Det-IV:1_Soft}Cmd:Cls-Cmd', 1)
        time.sleep(1.0)
        caput('XF:11BMB-VA{Chm:Det-IV:1}Cmd:Opn-Cmd', 1)
        time.sleep(0.2)
        
        self.chamberPressure(range_low=200)
        
        
    def openChamberGateValve(self):
        
        caput('XF:11BMB-VA{Chm:Det-GV:1}Cmd:Opn-Cmd', 1) # Large (downstream)
        #caput('XF:11BMB-VA{Slt:4-GV:1}Cmd:Opn-Cmd',1) # Small (upstream)


    def closeChamberGateValve(self):
        
        caput('XF:11BMB-VA{Chm:Det-GV:1}Cmd:Cls-Cmd', 1) # Large (downstream)
        #caput('XF:11BMB-VA{Slt:4-GV:1}Cmd:Cls-Cmd',1) # Small (upstream)
        
        
    # Metatdata methods
    ########################################
    
    def get_md(self, prefix=None, **md):
        
        md_current = self.md.copy()
        md_current['calibration_energy_keV'] = round(self.beam.energy(verbosity=0), 3)
        md_current['calibration_wavelength_A'] = round(self.beam.wavelength(verbosity=0), 5)
        
        h, v = self.beam.size(verbosity=0)
        md_current['beam_size_x_mm'] = h
        md_current['beam_size_y_mm'] = v
        
        #temperarily block it for bad communication. 17:30, 071617
        #h, v = self.beam.divergence(verbosity=0)
        #md_current['beam_divergence_x_mrad'] = h
        #md_current['beam_divergence_y_mrad'] = v
        
        md_current['beamline_mode'] = self.current_mode
        
        #md_current['detector'] = self.detector
        
        md_current['motor_SAXSx'] = SAXSx.user_readback.value
        md_current['motor_SAXSy'] = SAXSy.user_readback.value
        md_current['motor_WAXSx'] = WAXSx.user_readback.value
        md_current['motor_WAXSy'] = WAXSy.user_readback.value
        md_current['motor_WAXSz'] = WAXSz.user_readback.value
        md_current['motor_smx'] = smx.user_readback.value
        md_current['motor_smy'] = smy.user_readback.value
        md_current['motor_sth'] = sth.user_readback.value

        md_current['motor_bsx'] = bsx.user_readback.value
        md_current['motor_bsy'] = bsy.user_readback.value
        md_current['motor_bsphi'] = bsphi.user_readback.value
        
        # md_current.update(self.SAXS.get_md(prefix='detector_SAXS_'))
        
        md_current.update(md)
        
        # Add an optional prefix
        if prefix is not None:
            md_current = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_current.items() }
        
        return md_current
    

    def setMetadata(self, verbosity=3):
        '''Guides the user through setting some of the required and recommended
        meta-data fields.'''
        
        if verbosity>=3:
            print('This will guide you through adding some meta-data for the upcoming experiment.')
        if verbosity>=4:
            print('You can accept default values (shown in square [] brackets) by pressing enter. You can leave a value blank (or put a space) to skip that entry.')


        # Set some values automatically
        month = int(time.strftime('%m'))
        if month<=4:
            cycle = 1
        elif month<=8:
            cycle = 2
        else:
            cycle = 3    
        RE.md['experiment_cycle'] = '{:s}_{:d}'.format( time.strftime('%Y'), cycle )
        
        RE.md['calibration_energy_keV'] = round(self.beam.energy(verbosity=0), 3)
        RE.md['calibration_wavelength_A'] = round(self.beam.wavelength(verbosity=0), 5)
        
        # TODO:
        # RE.md['calibration_detector_distance_m'] =
        # RE.md['calibration_detector_x0'] =
        # RE.md['calibration_detector_y0'] = 
        
            
        
        # Ask the user some questions
        
        questions = [
            ['experiment_proposal_number', 'Proposal number'] ,
            ['experiment_SAF_number', 'SAF number'] ,
            ['experiment_group', 'User group (e.g. PI)'] ,
            ['experiment_user', 'The specific user/person running the experiment'] ,
            ['experiment_project', 'Project name/code'] ,
            ['experiment_alias_directory', 'Alias directory'] ,
            ['experiment_type', 'Type of experiments/measurements (SAXS, GIWAXS, etc.)'] ,
            ]
        
        
        # TBD:
        # Path where data will be stored?

        self._dialog_total_questions = len(questions)
        self._dialog_question_number = 1
        
        for key, text in questions:
            try:
                self._ask_question(key, text)
            except KeyboardInterrupt:
                return
            
        if verbosity>=4:
            print('You can also add/edit metadata directly using the RE.md object.')
            
        if os.path.exists(RE.md['experiment_alias_directory']):
            print('/n The folder has existed. Please change folder name if necessary./n')
        else:
            os.makedirs(RE.md['experiment_alias_directory'], exist_ok=True)
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'waxs'), exist_ok=True)
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'waxs/raw'), exist_ok=True)
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'waxs/analysis'), exist_ok=True)
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'saxs'), exist_ok=True)
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'saxs/raw'), exist_ok=True)            
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'saxs/analysis'), exist_ok=True)            
            os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'data'), exist_ok=True)
            #os.makedirs(os.path.join(RE.md['experiment_alias_directory'], 'saxs'), exist_ok=True)            
            print('/n The folder ::: {} ::: has been made for users. /n'.format(RE.md['experiment_alias_directory']))
      

    def _ask_question(self, key, text, default=None):

        if default is None and key in RE.md:
                default = RE.md[key]
        
        if default is None:
            ret = input('  Q{:d}/{:d}. {:s}: '.format(self._dialog_question_number, self._dialog_total_questions, text) )
        
        else:
            ret = input('  Q{:d}/{:d}. {:s} [{}]: '.format(self._dialog_question_number, self._dialog_total_questions, text, default) )
            if ret=='':
                ret = default
                
            
        if ret!='' and ret!=' ':
            RE.md[key] = ret
            
        self._dialog_question_number += 1
            
        
    # Logging methods
    ########################################
        
    def logAllMotors(self, verbosity=3, **md):
        log_pos()
        
        motor_list = [
                    mono_bragg ,
                    mono_pitch2 ,
                    mono_roll2 ,
                    mono_perp2 ,
                    mir_usx ,
                    mir_dsx ,
                    mir_usy ,
                    mir_dsyi ,
                    mir_dsyo ,
                    mir_bend ,
                    s0.tp ,
                    s0.bt ,
                    s0.ob ,
                    s0.ib ,
                    s1.xc ,
                    s1.xg ,
                    s1.yc ,
                    s1.yg ,
                    s2.xc ,
                    s2.xg ,
                    s2.yc ,
                    s2.yg ,
                    s3.xc ,
                    s3.xg ,
                    s3.yc ,
                    s3.yg ,
                    s4.xc ,
                    s4.xg ,
                    s4.yc ,
                    s4.yg ,
                    s5.xc ,
                    s5.xg ,
                    s5.yc ,
                    s5.yg ,
                    bim3y ,
                    fs3y ,
                    bim4y ,
                    bim5y ,
                    smx ,
                    smy ,
                    sth ,
                    schi ,
                    sphi ,
                    srot ,
                    strans ,
                    camx ,
                    camy ,
                    cam2x ,
                    cam2z ,
                    WAXSx ,
                    WAXSy ,
                    WAXSz ,
                    SAXSx ,
                    SAXSy ,
                    bsx , 
                    bsy ,
                    bsphi ,
                    armz ,
                    armx ,
                    armphi ,
                    army ,
                    armr ,
                    ]
        
        self.log_motors(motor_list, verbosity=verbosity, **md)
        
       
    # End class CMS_Beamline(Beamline)
    ########################################
        

class CMS_Beamline_GISAXS(CMS_Beamline):

    def __init__(self, **kwargs):
        
        super().__init__(**kwargs)    
    
    def modeAlignment(self, verbosity=3):
        
        if RE.state!='idle':
            RE.abort()
        
        self.current_mode = 'undefined'
        
        # TODO: Check what mode (TSAXS, GISAXS) and respond accordingly
        # TODO: Check if gate valves are open and flux is okay (warn user)
        
        self.beam.off()
        self.beam.setTransmission(1e-6)
        while beam.transmission() > 2e-6:
            time.sleep(0.5)
            self.beam.setTransmission(1e-6)
            
        # pilatus_name = pilatus2M
        # pilatus_Epicsname = '{Det:PIL2M}'        

        #mov(bsx, -11.55)
        #mov(bsx, -11.55+2) # changed at 06/02/17, Osuji beam time
        #mov(bsx, -14.73+2) # changed at 06/04/17, SAXS, 3m, Osuji beam time
        #mov(bsx, -15.23+2) # changed at 06/04/17, GISAXS, 3m, Osuji beam time
        #mov(bsx, -17.03+3) # changed at 06/04/17, GISAXS, 3m, Osuji beam time
        #mov(bsx, -16.0+3) #change it at 07/10/17, GISAXS, 2m, LSita Beam time
        #mov(bsx, -16.53+3) # 07/20/17, GISAXS, 5m, CRoss
        #mov(bsx, self.bsx_pos+3)
        
        bsx.move(self.bsx_pos+3)
        
        self.setReflectedBeamROI()
        self.setDirectBeamROI()

        #detselect(pilatus300, suffix='_stats4_total')
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', 0.5)
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', 0.6)

        #self.setMonitor(monitor=['stats3', 'stats4'])        
        detselect(pilatus_name, suffix='_stats4_total')
        caput('XF:11BMB-ES{}:cam1:AcquireTime'.format(pilatus_Epicsname), 0.1)
        # caput('XF:11BMB-ES{}:cam1:AcquirePeriod'.format(pilatus_Epicsname), 0.6)


        #TODO: Update ROI based on current SAXSx, SAXSy and the md in cms object
        
        self.current_mode = 'alignment'
        
        #self.beam.bim6.reading()


    def modeMeasurement(self, verbosity=3):   

        if RE.state!='idle':
            RE.abort()
        
        self.current_mode = 'undefined'
        
        self.beam.off()

        # pilatus_name = pilatus2M
        # pilatus_Epicsname = '{Det:PIL2M}'        
        #bsx_pos=-16.74
        #mov(bsx, -16.55)
        #mov(bsx, -13.83) #change it at 06/02/17, Osuji Beam time
        #mov(bsx, -14.73) #change it at 06/04/17, SAXS, 3m, Osuji Beam time
        #mov(bsx, -15.03) #change it at 06/04/17, GISAXS, 3m, Osuji Beam time
        #mov(bsx, -16.43) #change it at 06/12/17, GISAXS, 3m, LZhu Beam time
        #mov(bsx, -16.53) #change it at 06/19/17, GISAXS, 5m, AHexemer Beam time
        #mov(bsx, -16.2) #change it at 07/07/17, GISAXS, 3m, TKoga Beam time
        #mov(bsx, -16.43) #change it at 07/10/17, GISAXS, 2m, LSita Beam time
        #mov(bsx, -16.53) # 07/20/17, GISAXS, 5m, CRoss Beam time
        #mov(bsx, -15.84) # 07/26/17, SAXS/WAXS, 2m, BVogt Beam time
        #mov(bsx, -16.34) # 08/02/17, TOMO GISAXS, 5m, LRichter Beam time
        #mov(bsx, -16.74) # 08/02/17, TOMO GISAXS, 5m, LRichter Beam time
        #mov(bsx, self.bsx_pos)
        
        bsx.move(self.bsx_pos)

        #if abs(bsx.user_readback.value - -16.74)>0.1:
        if abs(bsx.user_readback.value - self.bsx_pos)>0.1:
            print('WARNING: Beamstop did not return to correct position!')
            return
        
        self.beam.setTransmission(1)
        
        
        #mov(DETy, -16)
        #self.beam.bim6.retract()

        
        #caput('XF:11BMB-BI{IM:2}EM180:Acquire', 0) # Turn off bim6
        #detselect(pilatus300)
        #detselect([pilatus300, psccd]) 
        detselect(pilatus_name)
        #detselect(psccd)
        
        #self.setMonitor(monitor=None)
                
        self.current_mode = 'measurement'
        
        # Check if gate valves are open
        if self.beam.GVdsbig.state() is not 'out' and verbosity>=1:
            print('Warning: Sample chamber gate valve (large, downstream) is not open.')

    def setDirectBeamROI(self, size=[10,4], verbosity=3):
        '''Update the ROI (stats4) for the direct beam on the Pilatus
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). A size=[6,4] is reasonable.
        The size is changed to [10, 4] for possible beam drift during a user run (changed at 08/16/17)'''
        
        if pilatus_name.name == 'pilatus2M':
            detector = self.SAXS
            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_SAXS_x0_pix']
            y0 = det_md['detector_SAXS_y0_pix']        
        if pilatus_name.name == 'pilatus800':
            detector = self.WAXS

            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_WAXS_x0_pix']
            y0 = det_md['detector_WAXS_y0_pix']
        
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:MinX', int(x0-size[0]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:SizeX', int(size[0]))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:MinY', int(y0-size[1]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:SizeY', int(size[1]))
        
        #detselect(pilatus300, suffix='_stats4_total')

        caput('XF:11BMB-ES{}:ROI4:MinX'.format(pilatus_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI4:SizeX'.format(pilatus_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI4:MinY'.format(pilatus_Epicsname), int(y0-size[1]/2))
        caput('XF:11BMB-ES{}:ROI4:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        detselect(pilatus_name, suffix='_stats4_total')        
        
    def setReflectedBeamROI(self, total_angle=0.16, size=[10,2], verbosity=3):
        '''Update the ROI (stats3) for the reflected beam on the Pilatus300k
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). A size=[6,2] is reasonable.'''
        
        if pilatus_name.name == 'pilatus2M':
            detector = self.SAXS
            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_SAXS_x0_pix']
            y0 = det_md['detector_SAXS_y0_pix']        
        if pilatus_name.name == 'pilatus800':
            detector = self.WAXS

            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_WAXS_x0_pix']
            y0 = det_md['detector_WAXS_y0_pix']
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus800k
        # if pilatus_name = pilatus800:
        #     y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #for pilatus2M, placed up-side down
        #y_pos = int( y0 - size[1]/2 + y_offset_pix )

        #for pilatus2M, with pattern rotated 180deg. changed at 052918
        # if pilatus_name = pilatus2m:
        #     y_pos = int( y0 - size[1]/2 - y_offset_pix )
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:MinX', int(x0-size[0]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:SizeX', int(size[0]))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:MinY', y_pos)
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:SizeY', int(size[1]))
        
        #detselect(pilatus300, suffix='_stats3_total')
            
        caput('XF:11BMB-ES{}:ROI3:MinX'.format(pilatus_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI3:SizeX'.format(pilatus_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI3:MinY'.format(pilatus_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI3:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        detselect(pilatus_name, suffix='_stats3_total')

    def setROI2ReflectBeamROI(self, total_angle=0.16, size=[10,100], verbosity=3):
        '''Update the ROI (stats3) for the reflected beam on the Pilatus300k
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). A size=[6,2] is reasonable.'''
        
        if pilatus_name.name == 'pilatus2M':
            detector = self.SAXS
            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_SAXS_x0_pix']
            y0 = det_md['detector_SAXS_y0_pix']        
        if pilatus_name.name == 'pilatus800':
            detector = self.WAXS

            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_WAXS_x0_pix']
            y0 = det_md['detector_WAXS_y0_pix']
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus800k
        # if pilatus_name = pilatus800:
        #     y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #for pilatus2M, placed up-side down
        #y_pos = int( y0 - size[1]/2 + y_offset_pix )

        #for pilatus2M, with pattern rotated 180deg. changed at 052918
        # if pilatus_name = pilatus2m:
        #     y_pos = int( y0 - size[1]/2 - y_offset_pix )
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:MinX', int(x0-size[0]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:SizeX', int(size[0]))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:MinY', y_pos)
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:SizeY', int(size[1]))
        
        #detselect(pilatus300, suffix='_stats3_total')
            
        caput('XF:11BMB-ES{}:ROI2:MinX'.format(pilatus_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI2:SizeX'.format(pilatus_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI2:MinY'.format(pilatus_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI2:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        detselect(pilatus_name, suffix='_stats2_total')

    def setSpecularReflectivityROI(self, total_angle=0.16, size=[10,10], default_SAXSy=None, verbosity=3):
        '''Update the ROIs (stats1, stats2) for the specular reflected beam on the Pilatus
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). 
        
        stats1 is centered on the specular reflected beam and has the size specified in 
        the size argument.
        
        stats2 is centered on the specular reflected beam and has the size that is twice
        as wide as specified in the size argument, for capturing background.
        
        The background-subtracted intensity for specular reflection is equal to: 
        2 * stats1 - stats2 
        '''
         
        detector = self.SAXS
        #self.setMonitor()
        
        if default_SAXSy is not None: 
            if abs(default_SAXSy - SAXSy.position) > 0.01: 
                SAXSy.move(default_SAXSy)
                print('SAXS detector has been shifted to default SAXSy = {:.3f} mm.'.format(SAXSy.position)) 
        
        # These positions are updated based on current detector position
        det_md = detector.get_md()
        x0 = det_md['detector_SAXS_x0_pix']
        y0 = det_md['detector_SAXS_y0_pix']
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus800k
        if pilatus_name.name == 'pilatus800':
            y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #for pilatus2M, placed up-side down
        #y_pos = int( y0 - size[1]/2 + y_offset_pix )

        #for pilatus2M, with pattern rotated 180deg. changed at 052918
        if pilatus_name.name == 'pilatus2M':
            y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #y pixels for intermodule gaps, for pilatus2M (195 pixels high module, 17 pixels high gap)
        y_gap_2M = []
        for i in np.arange(7): 
            for j in np.arange(17): 
                y_gap_2M.append((195+17)*(i+1)-17+j)
         
        #y pixels for Spectular Reflectivity ROI
        y_roi = []
        for i in np.arange(int(size[1]+1)):
            y_roi.append(y_pos+i)
         
        #flag for whether the ROI falls on intermodule gap 
        flag_ROIonGap = len(np.unique(y_gap_2M + y_roi)) < (len(y_gap_2M)+len(y_roi)) 
         
        #Move SAXSy if ROI falls on intermodule gap; if not, move on 
        if flag_ROIonGap == True: 
            y_shift = 17+size[1]+1	# intermodule gap is 17 pixels high 
            y_shift_mm = pixel_size*y_shift # mm
            SAXSy.move(SAXSy.position+y_shift_mm) 
            print('SAXS detector has been shifted to SAXSy = {:.3f} mm (by {:.3f} mm or {} pixels) to avoid a gap.'.format(SAXSy.position,y_shift_mm,y_shift)) 
         
            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_SAXS_x0_pix']
            y0 = det_md['detector_SAXS_y0_pix']
           
            ##for pilatus2M, placed up-side down
            #y_pos = int( y0 - size[1]/2 + y_offset_pix )

            #for pilatus2M, with pattern rotated 180deg. changed at 052918
            y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:MinX', int(x0-size[0]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:SizeX', int(size[0]))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:MinY', y_pos)
        #caput('XF:11BMB-ES{Det:SAXS}:ROI3:SizeY', int(size[1]))
        
        #detselect(pilatus300, suffix='_stats3_total')
            
        # ROI1: Raw signal 
        caput('XF:11BMB-ES{}:ROI1:MinX'.format(pilatus_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI1:SizeX'.format(pilatus_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI1:MinY'.format(pilatus_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI1:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        # ROI2: Raw signal+background (same as ROI1 for y, but twice as large for x) 
        caput('XF:11BMB-ES{}:ROI2:MinX'.format(pilatus_Epicsname), int(x0-size[0]))
        caput('XF:11BMB-ES{}:ROI2:SizeX'.format(pilatus_Epicsname), int(2*size[0]))
        caput('XF:11BMB-ES{}:ROI2:MinY'.format(pilatus_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI2:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        detselect(pilatus_name, suffix='_stats1_total')

    def setSpecularReflectivityROI_SAXSyPOS(self, total_angle=0.16, size=[10,10], default_SAXSy=None, verbosity=3):
        '''Update the ROIs (stats1, stats2) for the specular reflected beam on the Pilatus
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        calculate the SAXSy position for Pialtus2M 
        '''
         
        detector = self.SAXS
        #self.setMonitor()
        
        #if default_SAXSy is not None: 
            #if abs(default_SAXSy - SAXSy.position) > 0.01: 
                #SAXSy.move(default_SAXSy)
                #print('SAXS detector has been shifted to default SAXSy = {:.3f} mm.'.format(SAXSy.position)) 
        
        # These positions are based on the default detector position
        #det_md = detector.get_md()
        x0 = self.SAXS.direct_beam[0]
        y0 = self.SAXS.direct_beam[1]
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus300k
        #y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #for pilatus2M, placed up-side down
        #y_pos = int( y0 - size[1]/2 + y_offset_pix )

        #for pilatus2M, with pattern rotated 180deg. changed at 052918
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #y pixels for intermodule gaps, for pilatus2M (195 pixels high module, 17 pixels high gap)
        y_gap_2M = []
        for i in np.arange(7): 
            for j in np.arange(17): 
                y_gap_2M.append((195+17)*(i+1)-17+j)
         
        #y pixels for Spectular Reflectivity ROI
        y_roi = []
        for i in np.arange(int(size[1]+1)):
            y_roi.append(y_pos+i)
         
        #flag for whether the ROI falls on intermodule gap 
        flag_ROIonGap = len(np.unique(y_gap_2M + y_roi)) < (len(y_gap_2M)+len(y_roi)) 
         
        #Move SAXSy if ROI falls on intermodule gap; if not, move on 
        if flag_ROIonGap == True: 
            y_shift = 17+size[1]+1      # intermodule gap is 17 pixels high 
            y_shift_mm = pixel_size*y_shift # mm            
            return default_SAXSy+y_shift_mm        
        else:
            return default_SAXSy
        
    def setSpecularReflectivityROI_update(self, total_angle=0.16, size=[10,10], default_SAXSy=None, verbosity=3):
        '''Update the ROIs (stats1, stats2) for the specular reflected beam on the Pilatus
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). 
        
        stats1 is centered on the specular reflected beam and has the size specified in 
        the size argument.
        
        stats2 is centered on the specular reflected beam and has the size that is twice
        as wide as specified in the size argument, for capturing background.
        
        The background-subtracted intensity for specular reflection is equal to: 
        2 * stats1 - stats2 
        
        The difference from the original is that the stage SAXSy will not move except necessary
        The SAXSy position is obtained by setSpecularReflectivityROI_calculate
        '''
         
        detector = self.SAXS
        #self.setMonitor()
        
        SAXSy_pos = self.setSpecularReflectivityROI_SAXSyPOS(total_angle=total_angle,size=size,default_SAXSy=default_SAXSy)
        SAXSy.move(SAXSy_pos)
        
        # These positions are updated based on current detector position
        det_md = detector.get_md()
        x0 = det_md['detector_SAXS_x0_pix']
        y0 = det_md['detector_SAXS_y0_pix']

        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus300k
        #y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #for pilatus2M, placed up-side down
        #y_pos = int( y0 - size[1]/2 + y_offset_pix )

        #for pilatus2M, with pattern rotated 180deg. changed at 052918
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        # ROI1: Raw signal 
        caput('XF:11BMB-ES{}:ROI1:MinX'.format(pilatus_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI1:SizeX'.format(pilatus_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI1:MinY'.format(pilatus_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI1:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        # ROI2: Raw signal+background (same as ROI1 for y, but twice as large for x) 
        caput('XF:11BMB-ES{}:ROI2:MinX'.format(pilatus_Epicsname), int(x0-size[0]))
        caput('XF:11BMB-ES{}:ROI2:SizeX'.format(pilatus_Epicsname), int(2*size[0]))
        caput('XF:11BMB-ES{}:ROI2:MinY'.format(pilatus_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI2:SizeY'.format(pilatus_Epicsname), int(size[1]))
        
        detselect(pilatus_name, suffix='_stats1_total')          

    
    def out_of_beamstop(self, total_angle, size=[12,12], default_SAXSy=None):

        detector = self.SAXS
        
        #if default_SAXSy is not None: 
            #if abs(default_SAXSy - SAXSy.position) > 0.01: 
                #SAXSy.move(default_SAXSy)
                #print('SAXS detector has been shifted to default SAXSy = {:.3f} mm.'.format(SAXSy.position)) 
        
        # These positions are updated based on current detector position
        #det_md = detector.get_md()
        #y0 = det_md['detector_SAXS_y0_pix']
        
        #y_shift_mm = SAXSy.position - detector.detector_position[1]
        #y_shift_pixel = y_shift_mm/pixel_size
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size

        ##for pilatus2M, placed up-side down
        #y_pos = int( y0 - size[1]/2 + y_offset_pix )

        #y pixels for the size of circle beamstop, for pilatus2M (radius 27~28 pixels)
        y_beamstop = 15
                
        #ROI_ymin = caget('XF:11BMB-ES{}:ROI1:MinY'.format(pilatus_Epicsname))
        
        #return abs(y0 - y_shift_pixel - ROI_ymin) > y_beamstop

        return y_offset_pix  - size[1]/2 > y_beamstop
    
    def beamOutXR(self, total_angle, roi=[260, 618], size=[10,10]):
        #check whether the reflect beam is high enough to move the WAXS detector to pos2. 
        
        detector = self.WAXS
        
        self.setWAXSpos2(size=size)
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm

        #supposed direct beam position
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size        
        y_pos_pix = roi[1]/2 - y_offset_pix

        y_shift_pix = y0 - y_pos_pix
        y_shift_mm = y_shift_pix*pixel_size

        #y pixels for the size of circle beamstop, for pilatus800 
        y_beamstop = 17
                
        #return abs(y0 - y_shift_pixel - ROI_ymin) > y_beamstop
        return y_shift_pix >  y_beamstop + size[1]/2



    #def definePos(self, pos1=self.XR_pos1,size=[10,10]):
        
        #self.XR_pos2 = pos1
        #self.XR_pos2[1] = pos1[1] - size[1]/2 - 17
        #return self.XR_pos2

    def setMonitor(self, monitor=['stats1', 'stats2', 'stats3', 'stats4']):
        if monitor == None: 
            pilatus2M.read_attrs = ['tiff'] 
            #monitor = ['stats3', 'stats4']        
        else:
            pilatus2M.read_attrs = ['tiff'] + monitor
            #pilatus2M.configuration_attrs=[]

        pilatus2M.configuration_attrs=[]
        #print(pilatus2M.configuration_attrs)

class CMS_Beamline_XR(CMS_Beamline_GISAXS):
    
    def __init__(self, **kwargs):
        
        super().__init__(**kwargs)
        
        self.beam = beam
        ##self.SAXS = CMS_SAXS_Detector(pilatus300)
        #self.WAXS = CMS_WAXS_Detector(pilatus800)
        #self.SAXS = CMS_SAXS_Detector(pilatus2M)

        #TODO: define position for WAXS
        # there are two positions for XR on WAXS
        # pos1 will be fixed at one position where the direct beam right on the edge of the detector
        # pos1 will be used for direct beam measurement and low q range
        # pos2 will be a second position which is (size[1]/2+17) pixels lower than pos1
        # pos2 will be used for higher q-range than pos1

        self.XR_edge=618
        self.XR_align=618+50
        #self.definePos()

        pilatus_name = pilatus800
        pilatus_Epicsname = '{Det:PIL800K}'
    
    def modeXRMeasurement(self, verbosity=3):   
        
        self.beam.off()
        bsx.move(self.bsx_pos)

        if abs(bsx.user_readback.value - self.bsx_pos)>0.1:
            print('WARNING: Beamstop did not return to correct position!')
            return
        
        self.beam.setTransmission(1)
        self.beam.setAbsorber(0)
       
        self.current_mode = 'XR'

        det_name = pilatus800
        det_Epicsname = '{Det:PIL800K}'

        detselect(det_name)
        self.definePos(size=[10, 4])
        
        # Check if gate valves are open
        if self.beam.GVdsbig.state() is not 'out' and verbosity>=1:
            print('Warning: Sample chamber gate valve (large, downstream) is not open.')        

    def modeXRAlignment(self, verbosity=3):
        
        if RE.state!='idle':
            RE.abort()
        
        self.current_mode = 'undefined'
        
        # TODO: Check what mode (TSAXS, GISAXS) and respond accordingly
        # TODO: Check if gate valves are open and flux is okay (warn user)
        
        self.beam.off()
        self.beam.setTransmission(1e-6)
        while beam.transmission() > 2e-6:
            time.sleep(0.5)
            self.beam.setTransmission(1e-6)
            
        det_name = pilatus2M
        det_Epicsname = '{Det:PIL2M}'        
        
        self.setReflectedBeamROI()
        self.setDirectBeamROI()
        bsx.move(self.bsx_pos+5)
        #detselect(pilatus300, suffix='_stats4_total')
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', 0.5)
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', 0.6)

        #self.setMonitor(monitor=['stats3', 'stats4'])        
        detselect(det_name, suffix='_stats4_total')
        caput('XF:11BMB-ES{}:cam1:AcquireTime'.format(det_Epicsname), 0.5)
        caput('XF:11BMB-ES{}:cam1:AcquirePeriod'.format(det_Epicsname), 0.6)
        
        self.definePos()
        self.setWAXSpos(total_angle=0, roi=cms.XR_posAlign) 


        #TODO: Update ROI based on current SAXSx, SAXSy and the md in cms object
        
        self.current_mode = 'alignment'
        
    def setDirectBeamROI_WAXS(self, size=[10,4], verbosity=3):
        '''Update the ROI (stats4) for the direct beam on the Pilatus
        detector. This (should) update correctly based on the current SAXSx, SAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). A size=[6,4] is reasonable.
        The size is changed to [10, 4] for possible beam drift during a user run (changed at 08/16/17)'''
        
        detector = self.WAXS

        # These positions are updated based on current detector position
        det_md = detector.get_md()
        x0 = det_md['detector_WAXS_x0_pix']
        y0 = det_md['detector_WAXS_y0_pix']
        det_Epicsname = det_md['detector_WAXS_epics_name'] 
        
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:MinX', int(x0-size[0]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:SizeX', int(size[0]))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:MinY', int(y0-size[1]/2))
        #caput('XF:11BMB-ES{Det:SAXS}:ROI4:SizeY', int(size[1]))
        
        #detselect(pilatus300, suffix='_stats4_total')

        
        caput('XF:11BMB-ES{}:ROI4:MinX'.format(det_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI4:SizeX'.format(det_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI4:MinY'.format(det_Epicsname), int(y0-size[1]/2))
        caput('XF:11BMB-ES{}:ROI4:SizeY'.format(det_Epicsname), int(size[1]))
        
        detselect(pilatus_name, suffix='_stats4_total')    
        
    def setXRROI(self, total_angle=0.16, size=[10,4], default_WAXSy=None, verbosity=3):
        '''Update the ROIs (stats1, stats2) for the specular reflected beam on the Pilatus800
        detector. This (should) update correctly based on the current WAXSx, WAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). 
        
        stats1 is centered on the specular reflected beam and has the size specified in 
        the size argument.
        
        stats2 is centered on the specular reflected beam and has the size that is twice
        as wide as specified in the size argument, for capturing background.
        
        The background-subtracted intensity for specular reflection is equal to: 
        2 * stats1 - stats2 
        '''
         
        detector = self.WAXS
        #self.setMonitor()
        
        if default_WAXSy is not None: 
            if abs(default_WAXSy - WAXSy.position) > 0.01: 
                WAXSy.move(default_WAXSy)
                print('WAXS detector has been shifted to default WAXSy = {:.3f} mm.'.format(WAXSy.position)) 
        
        # These positions are updated based on current detector position
        det_md = detector.get_md()
        x0 = det_md['detector_WAXS_x0_pix']
        y0 = det_md['detector_WAXS_y0_pix']
        det_Epicsname = det_md['detector_WAXS_epics_name'] 
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus800
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #y pixels for intermodule gaps, for pilatus800 (195 pixels high module, 17 pixels high gap)
        y_gap_800 = []
        for i in np.arange(2): 
            for j in np.arange(17): 
                y_gap_800.append((195+17)*(i+1)-17+j)
         
        #y pixels for Spectular Reflectivity ROI
        y_roi = []
        for i in np.arange(int(size[1]+1)):
            y_roi.append(y_pos+i)
         
        #flag for whether the ROI falls on intermodule gap 
        flag_ROIonGap = len(np.unique(y_gap_800 + y_roi)) < (len(y_gap_800)+len(y_roi)) 
         
        #Move SAXSy if ROI falls on intermodule gap; if not, move on 
        if flag_ROIonGap == True: 
            y_shift = 17+size[1]+1      # intermodule gap is 17 pixels high 
            y_shift_mm = pixel_size*y_shift # mm
            WAXSy.move(WAXSy.position+y_shift_mm) 
            print('WAXS detector has been shifted to WAXSy = {:.3f} mm (by {:.3f} mm or {} pixels) to avoid a gap.'.format(WAXSy.position,y_shift_mm,y_shift)) 
         
            # These positions are updated based on current detector position
            det_md = detector.get_md()
            x0 = det_md['detector_WAXS_x0_pix']
            y0 = det_md['detector_WAXS_y0_pix']
           
            #for pilatus800
            y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        # ROI1: Raw signal 
        caput('XF:11BMB-ES{}:ROI1:MinX'.format(det_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI1:SizeX'.format(det_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI1:MinY'.format(det_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI1:SizeY'.format(det_Epicsname), int(size[1]))
        
        # ROI2: Raw signal+background (same as ROI1 for y, but twice as large for x) 
        caput('XF:11BMB-ES{}:ROI2:MinX'.format(det_Epicsname), int(x0-size[0]))
        caput('XF:11BMB-ES{}:ROI2:SizeX'.format(det_Epicsname), int(2*size[0]))
        caput('XF:11BMB-ES{}:ROI2:MinY'.format(det_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI2:SizeY'.format(det_Epicsname), int(size[1]))
        
        #detselect(pilatus_name, suffix='_stats1_total')
        detselect(pilatus800, suffix='_stats1_total')

    def setXRROI_WAXSy(self, total_angle=0.16, size=[10,10], default_WAXSy=None, verbosity=3):
        '''Update the ROIs (stats1, stats2) for the specular reflected beam on the Pilatus 800
        detector. This (should) update correctly based on the XR_POS2 position.
        
        calculate the SAXSy position for Pialtus2M 
        '''
         
        detector = self.WAXS
        #self.setMonitor()
        self.definePos()
        #TODO:
        # These positions are based on the detector position POS2
        #det_md = detector.get_md()
        [x0, y0] = self.XR_pos2
        #x0 = self.WAXS.direct_beam[0]
        #y0 = self.WAXS.direct_beam[1]
        
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus2M, with pattern rotated 180deg. changed at 052918
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        #y pixels for intermodule gaps, for pilatus800 (195 pixels high module, 17 pixels high gap)
        y_gap_800 = []
        for i in np.arange(2): 
            for j in np.arange(17): 
                y_gap_800.append((195+17)*(i+1)-17+j)
         
        #y pixels for Spectular Reflectivity ROI
        y_roi = []
        for i in np.arange(int(size[1]+1)):
            y_roi.append(y_pos+i)
         
        #flag for whether the ROI falls on intermodule gap 
        flag_ROIonGap = len(np.unique(y_gap_800 + y_roi)) < (len(y_gap_800)+len(y_roi)) 
         
        #Move SAXSy if ROI falls on intermodule gap; if not, move on 
        if flag_ROIonGap == True: 
            y_shift = 17+size[1]+1      # intermodule gap is 17 pixels high 
            y_shift_mm = pixel_size*y_shift # mm            
            self.setWAXSpos(total_angle=0.0, roi=self.XR_pos2, verbosity=3)
            WAXSy.move(WAXSy.position+y_shift_mm)
        else:
            self.setWAXSpos(total_angle=0.0, roi=self.XR_pos2, verbosity=3)
        
    def setXRROI_update(self, total_angle=0.16, size=[10,10], default_WAXSy=None, verbosity=3):
        '''Update the ROIs (stats1, stats2) for the specular reflected beam on the Pilatus 800
        detector. This (should) update correctly based on the current WAXSx, WAXSy.
        
        The size argument controls the size (in pixels) of the ROI itself
        (in the format [width, height]). 
        
        stats1 is centered on the specular reflected beam and has the size specified in 
        the size argument.
        
        stats2 is centered on the specular reflected beam and has the size that is twice
        as wide as specified in the size argument, for capturing background.
        
        The background-subtracted intensity for specular reflection is equal to: 
        2 * stats1 - stats2 
        
        The difference from the original is that the stage WAXSy will not move except necessary
        The WAXSy position is obtained by setXRROI_calculate
        '''
         
        detector = self.WAXS
        det_md = detector.get_md()
        det_Epicsname = det_md['detector_WAXS_epics_name'] 
        
        #self.setMonitor()
        #TODO:
        #if default_WAXSy==None:
            #default_WAXSy = -73
        
        #if self.beamOutXR():
            ##move the detector to pos2
            ## These positions are updated based on current detector position
            ##det_md = detector.get_md()
            ##x0 = det_md['detector_WAXS_x0_pix']
            ##y0 = det_md['detector_WAXS_y0_pix']
            #self.setWAXSpos(total_angle=0, roi=self.XR_pos2, size=size)
            #[x0, y0]=self.XR_pos2
            ##TODO:need to define a default position for pos2
            #WAXSy_pos = self.setXRROI(total_angle=total_angle,size=size,default_WAXSy=WAXSy.position)
            #WAXSy.move(WAXSy_pos)    

        #else: 
            #self.setWAXSpos(total_angle=0, roi=self.XR_pos1, size=size)
            #[x0, y0]=self.XR_pos1
            #WAXSy_pos = self.setXRROI(total_angle=total_angle,size=size,default_WAXSy=WAXSy.position)
            #WAXSy.move(WAXSy_pos)    
 
 
        self.setXRROI_WAXSy(total_angle=total_angle,size=size)
        
        
        # These positions are updated based on current detector position
        det_md = detector.get_md()
        x0 = det_md['detector_WAXS_x0_pix']
        y0 = det_md['detector_WAXS_y0_pix']

 
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size
        
        #for pilatus800k
        y_pos = int( y0 - size[1]/2 - y_offset_pix )
        
        # ROI1: Raw signal 
        caput('XF:11BMB-ES{}:ROI1:MinX'.format(det_Epicsname), int(x0-size[0]/2))
        caput('XF:11BMB-ES{}:ROI1:SizeX'.format(det_Epicsname), int(size[0]))
        caput('XF:11BMB-ES{}:ROI1:MinY'.format(det_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI1:SizeY'.format(det_Epicsname), int(size[1]))
        
        # ROI2: Raw signal+background (same as ROI1 for y, but twice as large for x) 
        caput('XF:11BMB-ES{}:ROI2:MinX'.format(det_Epicsname), int(x0-size[0]))
        caput('XF:11BMB-ES{}:ROI2:SizeX'.format(det_Epicsname), int(2*size[0]))
        caput('XF:11BMB-ES{}:ROI2:MinY'.format(det_Epicsname), y_pos)
        caput('XF:11BMB-ES{}:ROI2:SizeY'.format(det_Epicsname), int(size[1]))
        
        detselect(pilatus800, suffix='_stats1_total')
        
    def setWAXSpos(self, total_angle=0.16, roi=[458, 1043-409], verbosity=3):
        #to locate WAXSy position with given roi and incident angle. 
        #The defined roi could be used for data collection for the current angle. 

        detector = self.WAXS
        #self.setMonitor()
        
        # These positions are updated based on current detector position
        det_md = detector.get_md()
        x0 = det_md['detector_WAXS_x0_pix']
        y0 = det_md['detector_WAXS_y0_pix']        

        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm

        #supposed direct beam position
        x_shift_pix =  roi[0] - x0 
        x_shift_mm = x_shift_pix*pixel_size
        
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size        
        y_pos_pix = roi[1] + y_offset_pix

        y_shift_pix = y_pos_pix - y0 
        y_shift_mm = y_shift_pix*pixel_size
        
        WAXSx.move(WAXSx.position+x_shift_mm) 
        WAXSy.move(WAXSy.position+y_shift_mm) 
        print('WAXSx has been moved to new position {}'.format(WAXSx.position))
        print('WAXSy has been moved to new position {}'.format(WAXSy.position))
        self.setDirectBeamROI_WAXS()
        return x_shift_mm, y_shift_mm

    def gotoWAXSpos2(self):
        self.definepos()
        self.setWAXSpos(total_angle=0, roi=self.XR_pos2)

    def gotoWAXSpos1(self):
        self.definepos()
        beam.setTransmission(1e-6)
        print('Transmission is 1e-6.')
        self.setWAXSpos(total_angle=0, roi=self.XR_pos1)


    def beamOutXR(self, total_angle, roi=[458, 1043-409], size=[10,4]):
        #check whether the reflect beam is high enough to move the WAXS detector to pos2. 
        #TODO: to test the best angle to move to POS2. 15pixel at 255mm is about 0.58deg as 2theta.
        # this one should be roi_ysize/2+safe_distance_for_directbeam
        # POS2 should have a fixed y position. 
        
        detector = self.WAXS
        det_md = detector.get_md()
        x0 = det_md['detector_WAXS_x0_pix']
        y0 = det_md['detector_WAXS_y0_pix'] 
        
        #WAXS_edge = 424 # The edge pixel of the L shape
       
        d = detector.distance*1000.0 # mm
        pixel_size = detector.pixel_size # mm

        #supposed direct beam position
        y_offset_mm = np.tan(np.radians(total_angle))*d
        y_offset_pix = y_offset_mm/pixel_size        
        y_pos_pix = roi[1] - y_offset_pix

        y_shift_pix = y0 - y_pos_pix
        y_shift_mm = y_shift_pix*pixel_size

        #y pixels to move the beam into thru hole for pilatus800 
        y_beamstop = 7
                
        #return abs(y0 - y_shift_pixel - ROI_ymin) > y_beamstop
        return y_shift_pix >  y_beamstop + size[1]/2

    def bsin():
        bsx.move(self.bsx_pos)
        print('=========The beam stop is moved in.=============')
        
    def definePos(self,size=[10,4]):
        
        detector = self.WAXS
        det_md = detector.get_md()
        x0 = det_md['detector_WAXS_x0_pix']
        y0 = det_md['detector_WAXS_y0_pix']

        self.XR_pos1 = [x0, self.XR_edge-size[1]/2] 
        self.XR_pos2 = [x0, self.XR_edge+size[1]/2+7]
        self.XR_posAlign = [x0, self.XR_align]

        return self.XR_pos1, self.XR_pos2

    
#cms = CMS_Beamline()
# cms = CMS_Beamline_XR()
cms = CMS_Beamline_GISAXS()

def get_beamline():
    return cms


def detselect(detector_object, suffix='_stats4_total'):
    """Switch the active detector and set some internal state"""

    if isinstance(detector_object, (list, tuple)):
        #gs.DETS = detector_object
        #gs.PLOT_Y = detector_object[0].name + suffix
        #gs.TABLE_COLS = [gs.PLOT_Y] 
        cms.detector = detector_object
        cms.PLOT_Y = detector_object[0].name + suffix
        cms.TABLE_COLS = [cms.PLOT_Y] 

    else:
        cms.detector = [detector_object]
        cms.PLOT_Y = detector_object.name + suffix
        cms.TABLE_COLS = [cms.PLOT_Y] 
    return cms.detector
    #only return the detector name than the long list with
    #all attributes since bluesky upgrade in cycle 201802
    detector_list = []
    for detector in cms.detector:
        detector_list.append(detector.name)
    return detector_list
    #return cms.detector



##### I/O devices 
from epics import (caget, caput)

def pneumatic(inout,pv_r,pv_in,pv_out,ss1,quiet):
    if inout == 1:
        caput(pv_in,1)
        ss2 = 'has been inserted'
    elif inout == 0:
        caput(pv_out,1)
        ss2 = 'has been retracted'
    else:
        if caget(pv_r)==1:
            ss2 = 'is IN'
        else:
            ss2 = 'is OUT'
    if quiet==0:
        print(ss1+' '+ss2) 


## Fluorescence screen 1 (FOE)
def io_fs1(inout,q=0):
    pv_r = 'XF:11BMA-BI{FS:1}Pos-Sts'
    pv_in = 'XF:11BMA-BI{FS:1}Cmd:In-Cmd'
    pv_out = 'XF:11BMA-BI{FS:1}Cmd:Out-Cmd'
    ss1 = 'Fluorescence screen 1 (FOE)'
    pneumatic(inout,pv_r,pv_in,pv_out,ss1,q)

## Fluorescence screen 3 (Endstation)
def io_fs3(inout,q=0):
    pv_r = 'XF:11BMB-BI{FS:3}Pos-Sts'
    pv_in = 'XF:11BMB-BI{FS:3}Cmd:In-Cmd'
    pv_out = 'XF:11BMB-BI{FS:3}Cmd:Out-Cmd'
    ss1 = 'Fluorescence screen 3 (Endstation)'
    pneumatic(inout,pv_r,pv_in,pv_out,ss1,q)

## Fluorescence screen 4 (Endstation)
def io_fs4(inout,q=0):
    pv_r = 'XF:11BMB-BI{FS:4}Pos-Sts'
    pv_in = 'XF:11BMB-BI{FS:4}Cmd:In-Cmd'
    pv_out = 'XF:11BMB-BI{FS:4}Cmd:Out-Cmd'
    ss1 = 'Fluorescence screen 3 (Endstation)'
    pneumatic(inout,pv_r,pv_in,pv_out,ss1,q)

## BIM 5 - RIGI (Endstation)
def io_bim5(inout,q=0):
    pv_r = 'XF:11BMB-BI{IM:5}Pos-Sts'
    pv_in = 'XF:11BMB-BI{IM:5}Cmd:In-Cmd'
    pv_out = 'XF:11BMB-BI{IM:5}Cmd:Out-Cmd'
    ss1 = 'BIM 5 - RIGI (Endstation)'
    pneumatic(inout,pv_r,pv_in,pv_out,ss1,q)


## Attenuation filter box
def io_atten(pos,inout,q=0):
    if pos >= 1 and pos <= 8:
        pv_r = 'XF:11BMB-OP{Fltr:' + str(int(pos)) + '}Pos-Sts'        
        pv_in = 'XF:11BMB-OP{Fltr:' + str(int(pos)) + '}Cmd:In-Cmd'        
        pv_out = 'XF:11BMB-OP{Fltr:' + str(int(pos)) + '}Cmd:Out-Cmd'        
        ss1 = 'Atten filter ' + str(int(pos))
        pneumatic(inout,pv_r,pv_in,pv_out,ss1,q)
    else:
        print('Attenuator position must be an integer between 1 and 8')

from math import (exp, log)

def get_atten_trans():
    E = getE(q=1)		# Current E [keV]
    
    if E < 6.0 or E > 18.0:
        print('Transmission data not available at the current X-ray enegy.')

    else:
        N = []
        for i in np.arange(8):
            N.append(caget('XF:11BMB-OP{Fltr:' + str(int(i)+1) + '}Pos-Sts'))

        N_Al = N[0] + 2*N[1] + 4*N[2] + 8*N[3]
        N_Nb = N[4] + 2*N[5] + 4*N[6] + 8*N[7]

        d_Nb = 0.1	# Thickness [mm] of one Nb foil 
        d_Al = 0.25	# Thickness [mm] of one Al foil 

        # Absorption length [mm] based on fits to LBL CXRO data for 6 < E < 19 keV
        l_Nb = 1.4476e-3 - 5.6011e-4 * E + 1.0401e-4 * E*E + 8.7961e-6 * E*E*E
        l_Al = 5.2293e-3 - 1.3491e-3 * E + 1.7833e-4 * E*E + 1.4001e-4 * E*E*E

        # transmission factors
        tr_Nb = exp(-N_Nb*d_Nb/l_Nb) 
        tr_Al = exp(-N_Al*d_Al/l_Al) 
        tr_tot = tr_Nb*tr_Al

        print('%dx 0.25mm Al (%.1e) and %dx 0.10mm Nb (%.1e)' % (N_Al, tr_Al, N_Nb, tr_Nb))
        print('Combined transmission is %.1e' % tr_tot)

        return(tr_tot)

def set_atten_trans(tr):
    E = getE(q=1)		# Current E [keV]
    
    if E < 6.0 or E > 18.0:
        print('Transmission data not available at the current X-ray enegy.')

    elif tr > 1.0 or tr < 1.0e-10:
        print('Requested attenuator transmission is not valid.')

    else:
        d_Nb = 0.1	# Thickness [mm] of one Nb foil 
        d_Al = 0.25	# Thickness [mm] of one Al foil 

        # Absorption length [mm] based on fits to LBL CXRO data for 6 < E < 19 keV
        l_Nb = 1.4476e-3 - 5.6011e-4 * E + 1.0401e-4 * E*E + 8.7961e-6 * E*E*E
        l_Al = 5.2293e-3 - 1.3491e-3 * E + 1.7833e-4 * E*E + 1.4001e-4 * E*E*E
 
        d_l_Nb = d_Nb/l_Nb 
        d_l_Al = d_Al/l_Al 

        # Number of foils to be inserted (picks a set that gives smallest deviation from requested transmission)
        dev=[]
        for i in np.arange(16):
            for j in np.arange(16):
                dev_ij = abs(tr - exp(-i*d_l_Nb)*exp(-j*d_l_Al))
                dev.append(dev_ij)
                if (dev_ij == min(dev)):
                    N_Nb = i			# number of Nb foils selected
                    N_Al = j			# number of Al foils selected

        N=[]
        state = N_Al
        for i in np.arange(4):
            N.append(state % 2)
            state = int(state/2)

        state = N_Nb
        for i in np.arange(4):
            N.append(state % 2)
            state = int(state/2)

        for i in np.arange(8):
            io_atten(i+1,N[i],q=1)

        time.sleep(1.); return(get_atten_trans())


### 1-stage valves
def single_valve(cmd,pv_r,pv_op,pv_cl,ss1,quiet):
    if cmd=='st':
        st = caget(pv_r)
        if st == 1:
            ss2 = 'valve is open'
        if st == 0:
            ss2 = 'valve is closed'
    if cmd=='o' or cmd=='open':
        caput(pv_op,1)
        ss2 = 'valve has been opened'
    if cmd=='c' or cmd=='close':
        caput(pv_cl,1)
        ss2 = 'valve has been closed'
    if quiet==0:
        print(ss1+' '+ss2) 

### 2-stage valves
def dual_valve(cmd,pv_r_soft,pv_op_soft,pv_cl_soft,pv_r,pv_op,pv_cl,ss1,quiet):
    if cmd=='st':
        st_h = caget(pv_r)
        st_s = caget(pv_r_soft)
        if st_h == 1 and st_s == 1:
            ss2 = 'main open and soft open'
        if st_h == 0 and st_s == 1:
            ss2 = 'main closed and soft open'
        if st_h == 1 and st_s == 0:
            ss2 = 'main open and soft closed'
        if st_h == 0 and st_s == 0:
            ss2 = 'main closed and soft closed'
    if cmd=='o' or cmd=='open':
        caput(pv_cl_soft,1)
        time.sleep(0.2)
        caput(pv_op,1)
        ss2 = 'main has been opened (soft closed)'
    if cmd=='so' or cmd=='soft':
        caput(pv_cl,1)
        time.sleep(0.5)
        caput(pv_op_soft,1)
        ss2 = 'soft has been opened (main closed)'
    if cmd=='c' or cmd=='close':
        caput(pv_cl,1)
        time.sleep(0.2)
        caput(pv_cl_soft,1)
        ss2 = 'valve has been closed'
    if quiet==0:
        print(ss1+' '+ss2) 


## Isolation valve - incident path
def iv_inc(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for hard open, 'so' or 'soft' for soft open, 'c' or 'close' for closing'''
    pv_r_soft = 'XF:11BMB-VA{Mir:KB-IV:1_Soft}Pos-Sts'
    pv_op_soft = 'XF:11BMB-VA{Mir:KB-IV:1_Soft}Cmd:Opn-Cmd'
    pv_cl_soft = 'XF:11BMB-VA{Mir:KB-IV:1_Soft}Cmd:Cls-Cmd'
    pv_r = 'XF:11BMB-VA{Mir:KB-IV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{Mir:KB-IV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{Mir:KB-IV:1}Cmd:Cls-Cmd'
    ss1 = 'Isolation valve for incident path: '
    dual_valve(cmd,pv_r_soft,pv_op_soft,pv_cl_soft,pv_r,pv_op,pv_cl,ss1,q)

## Isolation valve - sample/detector chamber
def iv_chm(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for hard open, 'so' or 'soft' for soft open, 'c' or 'close' for closing'''
    pv_r_soft = 'XF:11BMB-VA{Chm:Det-IV:1_Soft}Pos-Sts'
    pv_op_soft = 'XF:11BMB-VA{Chm:Det-IV:1_Soft}Cmd:Opn-Cmd'
    pv_cl_soft = 'XF:11BMB-VA{Chm:Det-IV:1_Soft}Cmd:Cls-Cmd'
    pv_r = 'XF:11BMB-VA{Chm:Det-IV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{Chm:Det-IV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{Chm:Det-IV:1}Cmd:Cls-Cmd'
    ss1 = 'Isolation valve for sample/WAXS chamber: '
    dual_valve(cmd,pv_r_soft,pv_op_soft,pv_cl_soft,pv_r,pv_op,pv_cl,ss1,q)

## Isolation valve - SAXS flightpath
def iv_pipe(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for hard open, 'so' or 'soft' for soft open, 'c' or 'close' for closing'''
    pv_r_soft = 'XF:11BMB-VA{BT:SAXS-IV:1_Soft}Pos-Sts'
    pv_op_soft = 'XF:11BMB-VA{BT:SAXS-IV:1_Soft}Cmd:Opn-Cmd'
    pv_cl_soft = 'XF:11BMB-VA{BT:SAXS-IV:1_Soft}Cmd:Cls-Cmd'
    pv_r = 'XF:11BMB-VA{BT:SAXS-IV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{BT:SAXS-IV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{BT:SAXS-IV:1}Cmd:Cls-Cmd'
    ss1 = 'Isolation valve for SAXS pipe: '
    dual_valve(cmd,pv_r_soft,pv_op_soft,pv_cl_soft,pv_r,pv_op,pv_cl,ss1,q)


## Vent valve - chamber upstream
def vv_us(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for hard open, 'so' or 'soft' for soft open, 'c' or 'close' for closing'''
    pv_r_soft = 'XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Pos-Sts'
    pv_op_soft = 'XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Opn-Cmd'
    pv_cl_soft = 'XF:11BMB-VA{Chm:Smpl-VV:1_Soft}Cmd:Cls-Cmd'
    pv_r = 'XF:11BMB-VA{Chm:Smpl-VV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{Chm:Smpl-VV:1}Cmd:Cls-Cmd'
    ss1 = 'Upstream vent valve for sample/WAXS chamber: '
    dual_valve(cmd,pv_r_soft,pv_op_soft,pv_cl_soft,pv_r,pv_op,pv_cl,ss1,q)

## Vent valve - chamber downstream
def vv_ds(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for hard open, 'so' or 'soft' for soft open, 'c' or 'close' for closing'''
    pv_r_soft = 'XF:11BMB-VA{Chm:Det-VV:1_Soft}Pos-Sts'
    pv_op_soft = 'XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Opn-Cmd'
    pv_cl_soft = 'XF:11BMB-VA{Chm:Det-VV:1_Soft}Cmd:Cls-Cmd'
    pv_r = 'XF:11BMB-VA{Chm:Det-VV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{Chm:Det-VV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{Chm:Det-VV:1}Cmd:Cls-Cmd'
    ss1 = 'Downstream vent valve for sample/WAXS chamber: '
    dual_valve(cmd,pv_r_soft,pv_op_soft,pv_cl_soft,pv_r,pv_op,pv_cl,ss1,q)


## Gate valve (Endstation) - upstream/small
def gv_us(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for open, 'c' or 'close' for closing'''
    pv_r = 'XF:11BMB-VA{Slt:4-GV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{Slt:4-GV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{Slt:4-GV:1}Cmd:Cls-Cmd'
    ss1 = 'Upstream/small gate valve (Endstation): '
    single_valve(cmd,pv_r,pv_op,pv_cl,ss1,q)

## Gate valve (Endstation) - downstream/large
def gv_ds(cmd='st',q=0):
    '''cmd: 'st' for status, 'o' or 'open' for open, 'c' or 'close' for closing'''
    pv_r = 'XF:11BMB-VA{Chm:Det-GV:1}Pos-Sts'
    pv_op = 'XF:11BMB-VA{Chm:Det-GV:1}Cmd:Opn-Cmd'
    pv_cl = 'XF:11BMB-VA{Chm:Det-GV:1}Cmd:Cls-Cmd'
    ss1 = 'Downstream/large gate valve (Endstation): '
    single_valve(cmd,pv_r,pv_op,pv_cl,ss1,q)


##### Endstation pumps
## Pump for flightpaths
def pump_fp(onoff, q=0):
    pv_r = 'XF:11BMB-VA{BT:SAXS-Pmp:1}Sts:Enbl-Sts'
    pv_w = 'XF:11BMB-VA{BT:SAXS-Pmp:1}Cmd:Enbl-Cmd'
    if onoff == 1:
        caput(pv_w,0)
        time.sleep(0.2)
        caput(pv_w,1)	
        ss='Flightpath pump has been turned ON'
    elif onoff == 0:
        caput(pv_w,0)	
        ss='Flightpath pump has been turned OFF'
    else:
        if caget(pv_r)==1:
            ss='Flightpath pump is ON'
        else:
            ss='Flightpath pump is OFF'
    if q==0:
        print(ss)

## Pump for sample/WAXS chamber
def pump_chm(onoff, q=0):
    pv_r = 'XF:11BMB-VA{Chm:Det-Pmp:1}Sts:Enbl-Sts'
    pv_w = 'XF:11BMB-VA{Chm:Det-Pmp:1}Cmd:Enbl-Cmd'
    if onoff == 1:
        caput(pv_w,0)
        time.sleep(0.2)
        caput(pv_w,1)	
        ss='Chamber pump has been turned ON'
    elif onoff == 0:
        caput(pv_w,0)	
        ss='Chamber pump has been turned OFF'
    else:
        if caget(pv_r)==1:
            ss='Chamber pump is ON'
        else:
            ss='Chamber pump is OFF'
    if q==0:
        print(ss)


#PROFILE_ROOT = os.path.dirname(__file__)
PROFILE_ROOT = '/nsls2/data/cms/legacy/xf11bm/ipython_profiles/profile_collection/startup'
CMS_CONFIG_FILENAME =  os.path.join(PROFILE_ROOT, '.cms_config')

## CMS config file
import pandas as pds
def config_update():

    cms.bsx_pos = bsx.position
    beam.armr_absorber_out = armr.position

    #collect the current positions of motors
    
    current_config = {'bsx_pos': cms.bsx_pos,
        #'armr_absorber_o':beam.armr_absorber_o,
        '_delta_y_hover': robot._delta_y_hover, 
        '_delta_y_slot': robot._delta_y_slot, 
        '_delta_garage_x': robot._delta_garage_x, 
        '_delta_garage_y': robot._delta_garage_y, 
        '_position_safe': [robot._position_safe], 
        '_position_sample_gripped': [robot._position_sample_gripped], 
        '_position_hold': [robot._position_hold], 
        '_position_garage': [robot._position_garage],
        '_position_stg_exchange': [robot._position_stg_exchange], 
        '_position_stg_safe': [robot._position_stg_safe], 
        'time':time.ctime() }
    
    current_config_DF = pds.DataFrame(data=current_config, index=[1])
    
    #load the previous config file
    cms_config = pds.read_csv(CMS_CONFIG_FILENAME, index_col=0)
    cms_config_update = cms_config.append(current_config_DF, ignore_index=True)    
    
    #save to file
    cms_config_update.to_csv(CMS_CONFIG_FILENAME)
    
    config_load()
    
def config_load():

    #collect the current positions of motors
    cms_config = pds.read_csv(CMS_CONFIG_FILENAME, index_col=0)
    cms.bsx_pos = cms_config.bsx_pos.values[-1]
    #beam.armr_absorber_o = cms_config.armr_absorber_o.values[-1]
   
    #robot positions --- with single value
    robot._delta_y_hover = cms_config._delta_y_hover.values[-1]
    robot._delta_y_slot = cms_config._delta_y_slot.values[-1]
    robot._delta_garage_x = cms_config._delta_garage_x.values[-1] 
    robot._delta_garage_y = cms_config._delta_garage_y.values[-1]
    
    #robot positions --- with multiple values in (x, y, r, z, phi)
    
    #tmp = cms_config._position_safe.values[-1]
    #robot._position_safe = [float(pos) for pos in tmp[1:-1].split(',')]

    robot._position_safe = [float(pos) for pos in cms_config._position_safe.values[-1][1:-1].split(',')]

    #robot._position_safe = cms_config._position_safe.values[-1] 
    robot._position_sample_gripped = [float(pos) for pos in cms_config._position_sample_gripped.values[-1][1:-1].split(',')] 
    robot._position_hold = [float(pos) for pos in cms_config._position_hold.values[-1][1:-1].split(',')] 
    robot._position_garage = [float(pos) for pos in cms_config._position_garage.values[-1][1:-1].split(',')]
    robot._position_stg_exchange = [float(pos) for pos in cms_config._position_stg_exchange.values[-1][1:-1].split(',')]
    robot._position_stg_safe = [float(pos) for pos in cms_config._position_stg_safe.values[-1][1:-1].split(',')]
    

## output the scan data and save them in user_folder/data. 
def data_output(experiment_cycle=None, experiment_alias_directory=None): 
    
    """
    To output the scan data with the scan_id as name
    Please first create "data" folder under user_folder. 
    """
    
    #headers = db(experiment_cycle='2017_3', experiment_group= 'I. Herman (Columbia U.) group', experiment_alias_directory='/nsls2/xf11bm/data/2017_3/IHerman' )
    if experiment_cycle is not None:
        headers = db( experiment_cycle=experiment_cycle, experiment_alias_directory=experiment_alias_directory)
    else:
        headers = db( experiment_alias_directory=experiment_alias_directory)
        
    for header in headers:
        
        dtable = header.table() 
        dtable.to_csv('{}/data/{}.csv'.format(header.get('start').get('experiment_alias_directory') , header.get('start').get('scan_id')))
        

## output the scan data and save them in user_folder/data. 
def data_output_seires(id_range): 
    
    """
    To output the scan data with the scan_id as name
    Please first create "data" folder under user_folder. 
    id_range = np.arange(55123, 56354)
    """
       
    for ii in id_range:
        
        header = db[scan_id]
        dtable = header.table() 
        dtable.to_csv('{}/data/{}.csv'.format(header.get('start').get('experiment_alias_directory') , header.get('start').get('scan_id')))
        
#def XRR_data_output(experiment_ids=None)
    
    #headers = db( experiement_ids )
    #for header in headers: 
        #dtable = header.table()
        
def metadata_output(output_file, SAF=None, experiment_alias_directory=None): 
    
    """
    To output the scan data with the scan_id as name
    Please first create "data" folder under user_folder. 
    SAF: SAF number, like '302914'
    """
    
    #headers = db(experiment_cycle='2017_3', experiment_group= 'I. Herman (Columbia U.) group', experiment_alias_directory='/nsls2/xf11bm/data/2017_3/IHerman' )
    #if experiment_cycle is not None:
        #headers = db( experiment_cycle=experiment_cycle, experiment_alias_directory=experiment_alias_directory)
    #else:
        #headers = db( experiment_alias_directory=experiment_alias_directory)


    headers= db(experiment_SAF_number=SAF) 
    output_data = pds.DataFrame()
    
    
    for header in headers:
        
        if 'sample_name' in header.start and 'sample_x' in header.start and 'sample_clock' in header.start:

            current_data = {'a_scan_id':header.start['scan_id'],
                            'b_sample_name': header.start['sample_name'],
                            'c_clock':header.start['sample_clock'], 
                            'd_pos_x': header.start['sample_x'],
                            'e_pos_th': header.start['sample_th'],
                            'f_temperature': header.start['sample_temperature_A']
                            }    
            current = pds.DataFrame(data=current_data, index=[1])

        output_data = output_data.append(current_data, ignore_index=True)    
        
        #output_data = output_data.iloc[0:0]
    
    output_data.to_csv(output_file)


#rock/swing a motor contineously while taking images
#added by AWalter and RLi at 20181106
def rock_motor_per_step(detector, motor, step, rock_motor = None, rock_motor_limits =None):
    '''
    rock/swing a motor contineously while taking images
    use 'per_step' function in scan plan to rock the motor
    
    detector: pilatus2M or pilatus300
    motor: this motor is NOT used for measurement. use a motor not related to sample/measurement
    step: this step is NOT useed for measurement. set as 1 for single exposure
    rock_motor: the motor to rock.
    rock_motor_limits: the relative rocking position for rock_motor.
    
    
    '''
    
    devices = detector + [motor]
    rewindable = all_safe_rewind(devices)  # if devices can be re-triggered

    current = rock_motor.position
 
    #define rock to swing rock_motor
    #def rock():
        #yield from mvr(rock_motor, rock_motor_limits)
        #yield from mvr(rock_motor, -rock_motor_limits)
    def rock(current=current):
        yield from mv(rock_motor, current + rock_motor_limits)
        yield from mv(rock_motor, current + -rock_motor_limits)
    
    def inner_rock_and_read():

        #yield from trigger(detector)    
        #status = yield from trigger(detector[0])
        status = detector[0].trigger()
        while not status.done:
            yield from rock()
        yield from mv(rock_motor, current )
        yield from create('primary')

        ret = {}  # collect and return readings to give plan access to them
        for obj in devices:
            reading = (yield from read(obj))
            if reading is not None:
                ret.update(reading)
        yield from save()
        return ret

    from bluesky.preprocessors import rewindable_wrapper
    return (yield from rewindable_wrapper(inner_rock_and_read(),rewindable))

#Here is how ot use the rock plan
#our_scan=list_scan([pilatus2M], srot, [1,1], per_step = functools.partial(rock_motor_per_step, rock_motor=strans2, rock_motor_limits=2) )

        
    
    
    
    

# Classes and functions to make it easy to do a dscan with realtime fitting to
# a custom function.

import glob
from bluesky.callbacks import CallbackBase

class SavingCallback(CallbackBase):
	''' This call back saves data in a data element.

		Access each element by calling
		scallback.data[key] etc...
	'''
	def __init__(self, *args, **kwargs):
		super(SavingCallback, self).__init__(*args, **kwargs)
		self.data = dict()

	def descriptor(self, doc):
		for key, val in doc['data_keys'].items():
			self.data[key] = list()

	def event(self, doc):
		for key, val in doc['data'].items():
			self.data[key].append(val)


class PrintCallback(CallbackBase):
	''' For debugging only
		Exposes raw documents
	'''
	def start(self, doc):
		print("Start document: ")
		print(doc)
		print("END")
	def event(self, doc):
		print("Events document: ")
		print(doc)
		print("END")
	def descriptor(self, doc):
		print("Descriptor document: ")
		print(doc)
		print("END")
	def stop(self, doc):
		print("Stop document: ")
		print(doc)
		print("END")

def remove_last_Pilatus_series():
    '''Delete the last Pilatus image tiff. If the last image is a series of files
    with sequential IDs, they are all deleted.'''
    
    #chars = caget('XF:11BMB-ES{Det:SAXS}:TIFF1:FullFileName_RBV')
    #chars = caget('XF:11BMB-ES{Det:SAXS}:TIFF1:FullFileName_RBV')

    chars = caget('XF:11BMB-ES{}:TIFF1:FullFileName_RBV'.format(pilatus_Epicsname))
    chars = caget('XF:11BMB-ES{}:TIFF1:FullFileName_RBV'.format(pilatus_Epicsname))
    filename = ''.join(chr(char) for char in chars)[:-1]
    filenames = filename[:-11] + '*' + '.tiff'
    for filename in glob.glob(filenames):
        #print(filename)
        os.remove(filename)

if False:
    #%run -i /opt/ipython_profiles/profile_collection/startup/91-fit_scan.py
    
    # Define a 'fake' detector, for testing purposes
    from bluesky.examples import Reader
    def fake_detector_response_peak():
        pos = armz.user_readback.value
        A = 1000.0
        x0 = -40.0
        sigma = 0.1
        I = A*np.exp(-(pos - x0)**2/(2 * sigma**2)) + 10.0
        
        return np.random.poisson(I)
    def fake_detector_response_edge():
        pos = armz.user_readback.value
        A = 1000.0
        x0 = -17.0
        sigma = 0.05
        I = A/( 1 + np.exp( -(pos-x0)/(-sigma) ) ) + 10.0
        
        return np.random.poisson(I)

    #det = Reader( 'det', {'intensity': lambda: 1.0*( (DETx.user_readback.value - (-40.0))**2 )/(2.*(0.1)**2) } )    
    det = Reader( 'intensity', {'intensity': fake_detector_response_edge} )
    detselect(det)
    #detselect(det, suffix='')
    
    #fit_scan(DETx, 1, 3, detector_suffix='')
    #fit_scan(armz, [-5,0], 5, detector_suffix='')


class MotorWait(CallbackBase):
    
    def __init__(self, motor, wait_time):
        
        self.motor = motor
        self.wait_time = wait_time

    def start(self, doc):
        self.settle_time_original = self.motor.settle_time
        self.motor.settle_time = self.wait_time
    
    def stop(self, doc):
        self.motor.settle_time = self.settle_time_original


class LiveTable_Custom(LiveTable):
    '''Simple customization of LiveTable that preserves the x and y data.'''
    # Based on:
    # /opt/conda_envs/collection-17Q1.0/lib/python3.5/site-packages/bluesky/callbacks/core.py
    # class LiveTable(CallbackBase)
    
    def __init__(self, fields, y_name, x_name):
        
        super().__init__(fields)

        self.y_name = y_name
        self.x_name = x_name
        self.ydata = []
        self.xdata = []

    def start(self, doc):
        super().start(doc)

    def event(self, doc):
        if self.y_name not in doc['data']:
            return
        
        y = doc['data'][self.y_name]
        x = doc['data'][self.x_name]
        
        self.ydata.append(y)
        self.xdata.append(x)
        
        super().event(doc)

    def stop(self, doc):
        super().stop(doc)
    

class LiveStat(CallbackBase):
    """
    Calculate simple statistics for an (x,y) curve.
    """
    
    # Note: Follows the style/naming of class LiveFit(CallbackBase),
    # where possible, so that it can be used in similar contexts.
    
    def __init__(self, stat, y_name, x_name, update_every=1):
        
        self.stat = stat
        self.y_name = y_name
        self.x_name = x_name
        self.update_every = update_every
        
        self.ydata = []
        self.xdata = []
        
        class Result(object):
            pass
        self.result = Result() # Dummy object to replicate the hiearchy expected for LiveFit
        self.result.values = {}
        
 
        
    def event(self, doc):
        
        if self.y_name not in doc['data']:
            return
        
        y = doc['data'][self.y_name]
        x = doc['data'][self.x_name]
        
        self.ydata.append(y)
        self.xdata.append(x)
        
        if self.update_every is not None:
            i = doc['seq_num']
            if ((i - 1) % self.update_every == 0):

                if type(self.stat) is list:
                    for stat in self.stat:
                        self.update_fit(stat)
                else:
                    self.update_fit(self.stat)
                
        super().event(doc)
    
    
    def update_fit(self, stat):
        
        xs = np.asarray(self.xdata)
        ys = np.asarray(self.ydata)
    
        if stat is 'max':
            idx = np.argmax(ys)
            x0 = xs[idx]
            y0 = ys[idx]
            
            self.result.values['x_max'] = x0
            self.result.values['y_max'] = y0

        elif stat is 'min':
            idx = np.argmin(ys)
            x0 = xs[idx]
            y0 = ys[idx]
            
            self.result.values['x_min'] = x0
            self.result.values['y_min'] = y0
            
        elif stat is 'COM':
            x0 = np.sum(xs*ys)/np.sum(ys)
            y0 = np.interp(x0, xs, ys)

            self.result.values['x_COM'] = x0
            self.result.values['y_COM'] = y0
            
        elif stat is 'HM':
            '''Half-maximum, using the point(s) closest to HM.'''
            idx_max = np.argmax(ys)
            half_max = 0.5*ys[idx_max]
            
            l = None
            r = None
            
            left = ys[:idx_max]
            right = ys[idx_max:]
            
            if len(left)>0 and left.min()<half_max:
                idx_hm = np.abs(left-half_max).argmin()
                l = xs[:idx_max][idx_hm]
            if len(right)>0 and right.min()<half_max:
                idx_hm = np.abs(right-half_max).argmin()
                r = xs[idx_max:][idx_hm]


            if l is None:
                x0 = r
            elif r is None:
                x0 = l
            else:
                x0 = np.average( [l,r] )
                
            if x0 is None:
                x0 = np.average(xs)

            y0 = np.interp(x0, xs, ys)
            self.result.values['x_HM'] = x0
            self.result.values['y_HM'] = y0
            
            
        elif stat is 'HMi':
            '''Half-maximum, with averaging of values near HW.'''
            idx_max = np.argmax(ys)
            half_max = 0.5*ys[idx_max]
            
            l = None
            r = None
            
            left = ys[:idx_max]
            right = ys[idx_max:]
            
            if len(left)>0 and left.min()<half_max and left.max()>half_max:
                idx = np.where(left<half_max)[0][-1]
                l = np.average( [xs[:idx_max][idx], xs[:idx_max][idx+1]] )
            if len(right)>0 and right.min()<half_max and right.max()>half_max:
                idx = np.where(right<half_max)[0][0]
                r = np.average( [xs[idx_max:][idx-1], xs[idx_max:][idx]] )


            if l is None:
                x0 = r
            elif r is None:
                x0 = l
            else:
                x0 = np.average( [l,r] )
                
            if x0 is None:
                x0 = np.average(xs)

            y0 = np.interp(x0, xs, ys)
            self.result.values['x_HM'] = x0
            self.result.values['y_HM'] = y0
                        

            
        else:
            print('ERROR: Statistic type {} is not recognized.'.format(stat))
            
        
        
        #print('Update_fit: ({:g}, {:g})'.format(x0, y0))
        self.result.values['x0'] = x0
        self.result.values['y0'] = y0
        
            
        
        
        
    

class LiveStatPlot(LivePlot):
    
    def __init__(self, livestat, *, scan_range=None, legend_keys=None, xlim=None, ylim=None, ax=None, **kwargs):
        
        
        kwargs_update = { 
            'color' : 'b' ,
            'linewidth' : 0 ,
            'marker' : 'o' ,
            'markersize' : 10.0 ,
            }
        kwargs_update.update(kwargs)        
        
        super().__init__(livestat.y_name, livestat.x_name, legend_keys=legend_keys,
                         xlim=xlim, ylim=xlim, ax=ax, **kwargs_update)
        
        self.livestat = livestat
        
        self.scan_range = scan_range


    def get_scan_range(self, overscan=0.0):
        if self.scan_range is None:
            x_start = np.min(self.livestat.xdata)
            x_stop = np.max(self.livestat.xdata)
        else:
            x_start = np.min(self.scan_range)
            x_stop = np.max(self.scan_range)
            
        span = abs(x_stop-x_start)

        x_start -= span*overscan
        x_stop += span*overscan
        
        return x_start, x_stop, span
    
        
    def start(self, doc):
        self.livestat.start(doc)
        super().start(doc)
        
        for line in self.ax.lines:
            if hasattr(line, 'custom_tag_x0') and line.custom_tag_x0:
                line.remove()
        
        # A line that denotes the current fit position for x0 (e.g. center of gaussian)
        x_start, x_stop, span = self.get_scan_range(overscan=0.0)
        self.x0_line = self.ax.axvline( (x_start+x_stop)*0.5, color='b', alpha=0.5, dashes=[5,5], linewidth=2.0 )
        self.x0_line.custom_tag_x0 = True
        
        
    def event(self, doc):
        
        self.livestat.event(doc)
        
        # Slight kludge (to over-ride possible 'greying out' from LivePlot_Custom.start)
        self.current_line.set_alpha(1.0)
        self.current_line.set_linewidth(2.5)
        self.x0_line.set_alpha(0.5)
        self.x0_line.set_linewidth(2.0)
        
        
        if self.livestat.result is not None:
            x0 = self.livestat.result.values['x0']
            y0 = self.livestat.result.values['y0']
            
            self.x_data = [x0]
            self.y_data = [y0]
            
            self.update_plot()
        # Intentionally override LivePlot.event. Do not call super().
        
        self.update_plot()
        
    def update_plot(self):
        
        super().update_plot()
        
        self.x0_line.set_xdata([self.x_data[0]])
        
        
    def descriptor(self, doc):
        self.livestat.descriptor(doc)
        super().descriptor(doc)

    def stop(self, doc):
        self.livestat.stop(doc)
        # Intentionally override LivePlot.stop. Do not call super().
        


class LivePlot_Custom(LivePlot):
    
    def __init__(self, y, x=None, *, legend_keys=None, xlim=None, ylim=None,ax=None, fig=None, **kwargs):
        
        kwargs_update = { 
            'color' : 'k' ,
            'linewidth' : 3.5 ,
            }
        kwargs_update.update(kwargs)
        
        
        rcParams_update = {
            'figure.figsize' : (11,7) ,
            'figure.facecolor' : 'white' ,
            'font.size' : 14 ,
            'axes.labelsize' : 16 ,
            'legend.frameon' : False ,
            'legend.fontsize' : 10 ,
            'legend.borderpad' : 0.1 ,
            'legend.labelspacing' : 0.1 ,
            'legend.columnspacing' : 1.5 ,
            
            }
        # For more rcParam options: http://matplotlib.org/users/customizing.html
        plt.matplotlib.rcParams.update(rcParams_update)
        
        super().__init__(y, x, legend_keys=legend_keys, xlim=xlim, ylim=ylim, ax=ax, fig=fig, **kwargs_update)
        #super().setup()
        
        #self.ax.figure.canvas.manager.toolbar.pan()
        
        
    def start(self, doc):
        print(f"*** LivePlot_Custom.start() got {doc}")
        # Make all the 'older' lines greyed-out
        for line in self.ax.lines:
            
            alpha = line.get_alpha()
            if alpha is None:
                alpha = 1.0
            alpha = max(alpha*0.75, 0.1)
            line.set_alpha(alpha)
            
            lw = line.get_linewidth()
            if lw is None:
                lw = 1.0
            lw = max(lw*0.5, 0.2)
            line.set_linewidth(lw)
            
        super().start(doc)
        self.ax.figure.canvas.mpl_connect('scroll_event', self.scroll_event )
        
        
    def update_plot(self):
        
        ymin = min(self.y_data)
        ymax = max(self.y_data)
        yspan = ymax-ymin
        
        # If the data is 'reasonable' (strictly positive and close to zero),
        # then force the plotting range to something sensible
        if ymin>=0 and yspan>0 and ymin/yspan<0.25:
            self.ax.set_ylim([0, ymax*1.2])
        
        super().update_plot()
        
        
    def scroll_event(self, event):
        '''Gets called when the mousewheel/scroll-wheel is used. This activates
        zooming.'''

        if event.inaxes!=self.ax:
            return

        current_plot_limits = self.ax.axis()
        x = event.xdata
        y = event.ydata


        # The following function converts from the wheel-mouse steps
        # into a zoom-percentage. Using a base of 4 and a divisor of 2
        # means that each wheel-click is a 50% zoom. However, the speed
        # of zooming can be altered by changing these numbers.

        # 50% zoom:
        step_percent = 4.0**( -event.step/2.0 )
        # Fast zoom:
        #step_percent = 100.0**( -event.step/2.0 )
        # Slow zoom:
        #step_percent = 2.0**( -event.step/4.0 )

        xi = x - step_percent*(x-current_plot_limits[0])
        xf = x + step_percent*(current_plot_limits[1]-x)
        yi = y - step_percent*(y-current_plot_limits[2])
        yf = y + step_percent*(current_plot_limits[3]-y)

        self.ax.axis( (xi, xf, yi, yf) )

        self.ax.figure.canvas.draw()
        
        
    def add_line(self, x_data, y_data, **kwargs):
        
        self.current_line, = self.ax.plot(x_data, y_data, **kwargs)
        self.lines.append(self.current_line)
        self.legend = self.ax.legend(loc=0, title=self.legend_title)#.draggable()


 

class LiveFitPlot_Custom(LiveFitPlot):
    """
    Add a plot to an instance of LiveFit.

    Note: If your figure blocks the main thread when you are trying to
    scan with this callback, call `plt.ion()` in your IPython session.

    Parameters
    ----------
    livefit : LiveFit
        an instance of ``LiveFit``
    legend_keys : list, optional
        The list of keys to extract from the RunStart document and format
        in the legend of the plot. The legend will always show the
        scan_id followed by a colon ("1: ").  Each
    xlim : tuple, optional
        passed to Axes.set_xlim
    ylim : tuple, optional
        passed to Axes.set_ylim
    ax : Axes, optional
        matplotib Axes; if none specified, new figure and axes are made.
    All additional keyword arguments are passed through to ``Axes.plot``.
    """
    
    def __init__(self, livefit, *, legend_keys=None, xlim=None, ylim=None,
                 ax=None, scan_range=None, **kwargs):
        
        
        kwargs_update = { 
            'color' : 'b' ,
            'linewidth' : 2.5 ,
            }
        kwargs_update.update(kwargs)
        
        
        super().__init__(livefit, legend_keys=legend_keys, xlim=xlim, ylim=ylim, ax=ax, **kwargs_update)
        
        self.y_guess = 0
        self.scan_range = scan_range


    def get_scan_range(self, overscan=0.0):
        if self.scan_range is None:
            x_start = np.min(self.livefit.independent_vars_data[self.__x_key])
            x_stop = np.max(self.livefit.independent_vars_data[self.__x_key])
        else:
            x_start = np.min(self.scan_range)
            x_stop = np.max(self.scan_range)
            
        span = abs(x_stop-x_start)

        x_start -= span*overscan
        x_stop += span*overscan
        
        return x_start, x_stop, span
        

    def event(self, doc):
        
        # Slight kludge (to over-ride possible 'greying out' from LivePlot_Custom.start)
        self.current_line.set_alpha(1.0)
        self.current_line.set_linewidth(2.5)
        self.x0_line.set_alpha(0.5)
        self.x0_line.set_linewidth(2.0)
        
        self.livefit.event(doc)
        if self.livefit.result is not None:
            #self.y_data = self.livefit.result.best_fit
            #self.x_data = self.livefit.independent_vars_data[self.__x_key]
            
            x_start, x_stop, span = self.get_scan_range(overscan=0.25)
            
            self.x_data = np.linspace(x_start, x_stop, num=200, endpoint=True, retstep=False)
            self.y_data = self.livefit.result.eval(x=self.x_data)
            
            self.update_plot()
            
            
        # Intentionally override LivePlot.event. Do not call super().
        
        
    def start(self, doc):
        
        super().start(doc)

        for line in self.ax.lines:
            if hasattr(line, 'custom_tag_x0') and line.custom_tag_x0:
                line.remove()
        
        # A line that denotes the current fit position for x0 (e.g. center of gaussian)
        x_start, x_stop, span = self.get_scan_range(overscan=0.0)
        self.x0_line = self.ax.axvline( (x_start+x_stop)*0.5, color='b', alpha=0.5, dashes=[5,5], linewidth=2.0 )
        self.x0_line.custom_tag_x0 = True
        
        
        
    def update_plot(self):
        
        x0 = self.livefit.result.values['x0']
        self.x0_line.set_xdata([x0])
        super().update_plot()
        
        


class LiveFit_Custom(LiveFit):
    """
    Fit a model to data using nonlinear least-squares minimization.

    Parameters
    ----------
    model_name : string
        The name of the model to be used in fitting
    y : string
        name of the field in the Event document that is the dependent variable
    independent_vars : dict
        map the independent variable name(s) in the model to the field(s)
        in the Event document; e.g., ``{'x': 'motor'}``
    init_guess : dict, optional
        initial guesses for other values, if expected by model;
        e.g., ``{'sigma': 1}``
    update_every : int or None, optional
        How often to recompute the fit. If `None`, do not compute until the
        end. Default is 1 (recompute after each new point).

    Attributes
    ----------
    result : lmfit.ModelResult
    """    
    def __init__(self, model_name, y, independent_vars, scan_range, update_every=1, background=None):
        
        
        self.x_start = min(scan_range)
        self.x_stop = max(scan_range)
        self.x_span = abs(self.x_stop-self.x_start)
        
        substitutions = { 'gaussian': 'gauss', 'lorentzian': 'lorentz', 'squarewave': 'square', 'tophat': 'square', 'rectangular': 'square', 'errorfunction': 'erf' }
        if model_name in substitutions.keys():
            model_name = substitutions[model_name]
            
        
        lm_model = self.get_model(model_name)
        init_guess = self.get_initial_guess(model_name)
        
        # Add additional models (if any)
        if background is not None:
            if type(background) is list:
                for back in background:
                    lm_model += self.get_model(back)
                    init_guess.update(self.get_initial_guess(back))
            else:
                lm_model += self.get_model(background)
                init_guess.update(self.get_initial_guess(background))
        
        super().__init__(lm_model, y, independent_vars, init_guess=init_guess, update_every=update_every)
        
        
        
    def get_model(self, model_name):
        
        if model_name is 'gauss':
            def model_function(x, x0, prefactor, sigma):
                return prefactor*np.exp(-(x - x0)**2/(2 * sigma**2))

        elif model_name is 'lorentz':
            def model_function(x, x0, prefactor, gamma):
                return prefactor* (gamma**2) / ( (x-x0)**2 + (gamma**2) )

        elif model_name is 'doublesigmoid':
            def model_function(x, x0, prefactor, sigma, fwhm):
                left = prefactor/( 1 + np.exp( -(x-(x0-fwhm*0.5))/sigma ) )
                right = prefactor/( 1 + np.exp( -(x-(x0+fwhm*0.5))/sigma ) )
                return prefactor*( left - right )

        elif model_name is 'square':
            def model_function(x, x0, prefactor, fwhm):
                sigma = fwhm*0.02
                left = prefactor/( 1 + np.exp( -(x-(x0-fwhm*0.5))/sigma ) )
                right = prefactor/( 1 + np.exp( -(x-(x0+fwhm*0.5))/sigma ) )
                return prefactor*( left - right )


        elif model_name is 'sigmoid':
            def model_function(x, x0, prefactor, sigma):
                return prefactor/( 1 + np.exp( -(x-x0)/sigma ) )

        elif model_name is 'sigmoid_r':
            def model_function(x, x0, prefactor, sigma):
                return prefactor/( 1 + np.exp( +(x-x0)/sigma ) )

        elif model_name is 'step':
            def model_function(x, x0, prefactor, sigma):
                return prefactor/( 1 + np.exp( -(x-x0)/sigma ) )

        elif model_name is 'step_r':
            def model_function(x, x0, prefactor, sigma):
                return prefactor/( 1 + np.exp( +(x-x0)/sigma ) )

        elif model_name is 'tanh':
            def model_function(x, x0, prefactor, sigma):
                return prefactor*0.5*( np.tanh((x-x0)/sigma) + 1.0 )

        elif model_name is 'tanh_r':
            def model_function(x, x0, prefactor, sigma):
                return prefactor*0.5*( np.tanh(-(x-x0)/sigma) + 1.0 )

        elif model_name is 'erf':
            import scipy
            def model_function(x, x0, prefactor, sigma):
                return prefactor*0.5*( scipy.special.erf((x-x0)/sigma) + 1.0 )

        elif model_name is 'erf_r':
            import scipy
            def model_function(x, x0, prefactor, sigma):
                return prefactor*0.5*( scipy.special.erf(-(x-x0)/sigma) + 1.0 )
                

        elif model_name is 'constant':
            def model_function(x, offset):
                return x*0 + offset

        elif model_name is 'linear':
            def model_function(x, m, b):
                return m*x + b
            
        else:
            print('ERROR: Model {:s} unknown.'.format(model_name))
        
        lm_model = lmfit.Model(model_function)
        
        return lm_model
    
    
    def get_initial_guess(self, model_name):
        return getattr(self, 'initial_guess_{:s}'.format(model_name))()
    
    
    def initial_guess_gauss(self):
        init_guess = {
            'x0': lmfit.Parameter('x0', (self.x_start+self.x_stop)*0.5, min=self.x_start-self.x_span*0.1, max=self.x_stop+self.x_span*0.1) ,
            'prefactor': lmfit.Parameter('prefactor', 1000, min=0) ,
            'sigma': lmfit.Parameter('sigma', self.x_span*0.25, min=0, max=self.x_span*4) ,
            }
        return init_guess
    
    def initial_guess_lorentz(self):
        init_guess = {
            'x0': lmfit.Parameter('x0', (self.x_start+self.x_stop)*0.5, min=self.x_start-self.x_span*0.1, max=self.x_stop+self.x_span*0.1) ,
            'prefactor': lmfit.Parameter('prefactor', 1, min=0) ,
            'gamma': lmfit.Parameter('gamma', self.x_span*0.25, min=0, max=self.x_span*4) ,
            }
        return init_guess

    def initial_guess_doublesigmoid(self):
        init_guess = {
            'x0': lmfit.Parameter('x0', (self.x_start+self.x_stop)*0.5, min=self.x_start-self.x_span*0.1, max=self.x_stop+self.x_span*0.1) ,
            'prefactor': lmfit.Parameter('prefactor', 100, min=0) ,
            'sigma': lmfit.Parameter('sigma', self.x_span*0.25, min=0, max=self.x_span) ,
            'fwhm': lmfit.Parameter('fwhm', self.x_span*0.25, min=0, max=self.x_span) ,
            }
        return init_guess

    def initial_guess_square(self):
        init_guess = {
            'x0': lmfit.Parameter('x0', (self.x_start+self.x_stop)*0.5, min=self.x_start-self.x_span*0.1, max=self.x_stop+self.x_span*0.1) ,
            'prefactor': lmfit.Parameter('prefactor', 100, min=0) ,
            'fwhm': lmfit.Parameter('fwhm', self.x_span*0.25, min=0, max=self.x_span) ,
            }
        return init_guess

    def initial_guess_sigmoid(self):
        init_guess = {
            'x0': lmfit.Parameter('x0', (self.x_start+self.x_stop)*0.5, min=self.x_start-self.x_span*0.1, max=self.x_stop+self.x_span*0.1) ,
            'prefactor': lmfit.Parameter('prefactor', 100, min=0) ,
            'sigma': lmfit.Parameter('sigma', self.x_span*0.25, min=0, max=self.x_span*4) ,
            }
        return init_guess
    
    def initial_guess_sigmoid_r(self):
        return self.initial_guess_sigmoid()    

    def initial_guess_step(self):
        init_guess = {
            'x0': lmfit.Parameter('x0', (self.x_start+self.x_stop)*0.5, min=self.x_start-self.x_span*0.1, max=self.x_stop+self.x_span*0.1) ,
            'prefactor': lmfit.Parameter('prefactor', 100, min=0) ,
            'sigma': lmfit.Parameter('sigma', self.x_span*0.002, min=0, max=self.x_span*0.005) ,
            }
        return init_guess

    def initial_guess_step_r(self):
        return self.initial_guess_step()

    def initial_guess_tanh(self):
        return self.initial_guess_sigmoid()
    
    def initial_guess_tanh_r(self):
        return self.initial_guess_tanh()

    def initial_guess_erf(self):
        return self.initial_guess_sigmoid()

    def initial_guess_erf_r(self):
        return self.initial_guess_erf()

    
    def initial_guess_linear(self):
        init_guess = {'m' : 0, 'b' : 0 }
        return init_guess

    def initial_guess_constant(self):
        init_guess = {'offset' : 0}
        return init_guess
        




import lmfit

def fit_scan(motor, span, num=11, detectors=None, detector_suffix='', exposure_time=0.5, toggle_beam=True,  fit='HMi', background=None, per_step=None, wait_time=None, md={}, save_flg=0):
    """
    Scans the specified motor, and attempts to fit the data as requested.
    
    Parameters
    ----------
    motor : motor
        The axis/stage/motor that you want to move.
    span : float
        The total size of the scan range (centered about the current position).
        If a two-element list is instead specified, this is interpreted as the
        distances relative to the current position for the start and end.
    num : int
        The number of scan points.
    fit : None or string
        If None, then fitting is not done. Otherwise, the model specified by the
        supplied string is used.
            peaks: gauss, lorentz, doublesigmoid, square
            edges: sigmoid, step
            stats: max, min, COM (center-of-mass), HM (half-max)
    background : None or string
        A baseline/background underlying the fit function can be specified.
        (In fact, a sequence of summed background functions can be supplied.)
            constant, linear
    md : dict, optional
        metadata        
    """
    
    # TODO: Normalize per ROI pixel and per count_time?
    # TODO: save scan data with save_flg=1.

    if toggle_beam:
        beam.on()
    
    if not beam.is_on():
        print('WARNING: Experimental shutter is not open.')
    
    initial_position = motor.user_readback.value
  
    if type(span) is list:
        start = initial_position+span[0]
        stop = initial_position+span[1]
    else:
        start = initial_position-span/2.
        stop = initial_position+span/2.
    span = abs(stop-start)
    #positions, dp = np.linspace(start, stop, num, endpoint=True, retstep=True)

    if detectors is None:

        #detselect(pilatus_name, suffix='_stats4_total')
        detectors = get_beamline().detector
        plot_y = get_beamline().PLOT_Y
        
        #plot_y = pilatus2M.stats4.total
        #print("plot_y is {}".format(plot_y))
        
    else:
        plot_y = '{}{}'.format(detectors[0].name, detector_suffix)
       
    
    # Get axes for plotting
    title = 'fit_scan: {} vs. {}'.format(detectors[0].name, motor.name)
    #if len(plt.get_fignums())>0:
        # Try to use existing figure
        #fig = plt.gcf() # Most recent figure
        
    fig = None
    for i in plt.get_fignums():
        title_cur = plt.figure(i).canvas.manager.window.windowTitle()
        if title_cur==title:
            fig = plt.figure(i)
            break
            
    if fig is None:
        # New figure
        #fig, ax = plt.subplots() 
        fig = plt.figure(figsize=(11,7), facecolor='white')
        fig.canvas.manager.toolbar.pan()
        
    fig.canvas.set_window_title(title)
    ax = fig.gca()
    
    
    subs = []
    
    livetable = LiveTable([motor] + list(detectors))
    #subs.append(livetable)
    #liveplot = LivePlot_Custom(plot_y, motor.name, ax=ax)
    liveplot = LivePlot(plot_y, motor.name, ax=ax)
    subs.append(liveplot)
    
    if wait_time is not None:
        subs.append(MotorWait(motor, wait_time))
    
    
    if fit in ['max', 'min', 'COM', 'HM', 'HMi'] or type(fit) is list:
        
        livefit = LiveStat(fit, plot_y, motor.name)
        
        livefitplot = LiveStatPlot(livefit, ax=ax, scan_range=[start, stop])
        
        subs.append(livefitplot)
        
    
    elif fit is not None:
        
        # Perform a fit

        #livefit = LiveFit(lm_model, plot_y, {'x': motor.name}, init_guess)
        livefit = LiveFit_Custom(fit, plot_y, {'x': motor.name}, scan_range=[start, stop], background=background)
        
        #livefitplot = LiveFitPlot(livefit, color='k')
        livefitplot = LiveFitPlot_Custom(livefit, ax=ax, scan_range=[start, stop])
        
        subs.append(livefitplot)
        
        
    md['plan_header_override'] = 'fit_scan'
    md['scan'] = 'fit_scan'
    md['measure_type'] = 'fit_scan_{}'.format(motor.name)
    md['fit_function'] = fit
    md['fit_background'] = background

    #cms.SAXS.detector.setExposureTime(exposure_time)
    RE(cms.SAXS.detector.setExposureTime(exposure_time))

    #exposure_time_last = md['exposure_time'] 
    #md['exposure_time'] = exposure_time
    
    # Perform the scan
    
    bec.disable_plots()
    RE(scan(list(detectors), motor, start, stop, num, per_step=per_step, md=md), subs )
    bec.enable_plots()
    #RE(scan(list(detectors), motor, start, stop, num, per_step=per_step, md=md), [liveplot, livefit, livefitplot])
    #RE(scan(list(detectors), motor, start, stop, num, per_step=per_step, md=md), [livefit])
   
    
    #md['exposure_time'] = exposure_time_last
    #if plot_y=='pilatus300_stats4_total' or plot_y=='pilatus300_stats3_total':
    if plot_y=='pilatus2M_stats4_total' or plot_y=='pilatus2M_stats3_total':
        remove_last_Pilatus_series()
    
    #check save_flg and save the scan data thru databroker
    if save_flg == 1:
        header = db[-1]
        dtable = header.table()
        filename = '{}/{}'.format(RE.md['experiment_alias_directory'],header.start['scan_id'])
        dtable.to_csv(filename)


    if toggle_beam:
        beam.off()

    
    if fit is None:
        # Return to start position
        #motor.user_setpoint.set(initial_position)
        #mov(motor, initial_position)
        motor.move(initial_position)
        
    else:
        
        print( livefit.result.values )
        x0 = livefit.result.values['x0']
        #mov(motor, x0)
        motor.move(x0)
        return livefit.result




def fit_edge(motor, span, num=11, detectors=None, detector_suffix='', plot=True, toggle_beam=True, wait_time=None, md={}):
    """
    Optimized fit_scan for finding a (decreasing) step-edge.
    
    Parameters
    ----------
    motor : motor
        The axis/stage/motor that you want to move.
    span : float
        The total size of the scan range (centered about the current position).
        If a two-element list is instead specified, this is interpreted as the
        distances relative to the current position for the start and end.
    num : int
        The number of scan points.
    md : dict, optional
        metadata        
    """
    
    if toggle_beam:
        beam.on()

    if not beam.is_on():
        print('WARNING: Experimental shutter is not open.')
    
    cms.setMonitor(monitor=['stats1', 'stats2', 'stats3', 'stats4'])
    
    initial_position = motor.user_readback.value

    if type(span) is list:
        start = initial_position+span[0]
        stop = initial_position+span[1]
    else:
        start = initial_position-span/2.
        stop = initial_position+span/2.
    span = abs(stop-start)

    if detectors is None:
        detectors = get_beamline().detector
        plot_y = get_beamline().PLOT_Y
    else:
        plot_y = '{}{}'.format(detectors[0].name, detector_suffix)
    
    subs = []
    livetable = LiveTable_Custom([motor] + list(detectors), plot_y, motor.name)
	#scallback = SavingCallback()
	#subs.append(scallback)
	# access data with scallback.data['keyname']
	# (gives a list)
    subs.append(livetable)
    
    if plot:
        # Get axes for plotting
        title = 'fit_scan: {} vs. {}'.format(detectors[0].name, motor.name)
        fig = None
        for i in plt.get_fignums():
            title_cur = plt.figure(i).canvas.manager.window.windowTitle()
            if title_cur==title:
                fig = plt.figure(i)
                break
                
        if fig is None:
            # New figure
            #fig, ax = plt.subplots() 
            fig = plt.figure(figsize=(11,7), facecolor='white')
            fig.canvas.manager.toolbar.pan()
            
        fig.canvas.set_window_title(title)
        ax = fig.gca()
    
        liveplot = LivePlot_Custom(plot_y, motor.name, ax=ax)
        #liveplot = LivePlot(plot_y, motor.name, ax=ax)
        subs.append(liveplot)
    
    if wait_time is not None:
        subs.append(MotorWait(motor, wait_time))
    
    
    md['plan_header_override'] = 'fit_edge'
    md['scan'] = 'fit_edge'

    # Perform the scan
    bec.disable_table()
    bec.disable_plots()
    RE(scan(list(detectors), motor, start, stop, num, md=md), subs)
    #RE(scan(list(detectors), motor, start, stop, num, md=md), [liveplot, livetable] )
    bec.enable_plots()
    bec.enable_table()
    
    #if plot_y=='pilatus300_stats4_total' or plot_y=='pilatus300_stats3_total':
    if plot_y=='pilatus2M_stats4_total' or plot_y=='pilatus2M_stats3_total':
        remove_last_Pilatus_series()
            
    x0_guess = np.average(livetable.xdata)
    
    # Determine x0 from half-max (HM) analysis
    if True:
        # TODO: Handle case where more than one pair of points cross the HM
        if len(livetable.xdata)>3:
            
            y_max = np.max(livetable.ydata)
            HM = (y_max-np.min(livetable.ydata))/2.0
            
            for ip, (x2, y2) in enumerate(zip(livetable.xdata, livetable.ydata)):
                if ip>0:
                    x1 = livetable.xdata[ip-1]
                    yx1 = livetable.ydata[ip-1]
                    
                    if x1>HM and x2<HM:
                        # This pair of points crosses the HM
                        m = (y2-y1)/(x2-x1)
                        b = y2-m*x2
                        xHM = (HM-b)/m
                        x0_guess = xHM
                
    # Fit to sigmoid_r
    if True:
        
        y_max = np.max(livetable.ydata)

        x_span = abs(np.max(livetable.xdata)-np.min(livetable.xdata))
        def model(v, x):
            return v['prefactor']/( 1 + np.exp( +(x-v['x0'])/v['sigma'] ) )
        
        def func2minimize(params, x, data):
            v = params.valuesdict()
            m = model(v, x)
            return m - data

        params = lmfit.Parameters()
        if y_max>0:
            params.add('prefactor', value=y_max*0.95, min=y_max*0.90, max=y_max*1.02)
        else:
            params.add('prefactor', value=y_max*0.95, min=0, max=1)
        params.add('x0', value=x0_guess, min=np.min(livetable.xdata)+x_span*0.05, max=np.max(livetable.xdata)-x_span*0.05 )
        params.add('sigma', value=0.014, min=x_span*1e-4, max=x_span*0.08)
        
        
        # 1st fit: only vary x0
        params['prefactor'].set(vary=False)
        params['sigma'].set(vary=False)
        lm_result = lmfit.minimize(func2minimize, params, args=(livetable.xdata, livetable.ydata))
        #lmfit.report_fit(lm_result.params)

        # 2nd fit: vary everything
        params['prefactor'].set(vary=True)
        params['sigma'].set(vary=True)
        lm_result = lmfit.minimize(func2minimize, params, args=(livetable.xdata, livetable.ydata))
        #lmfit.report_fit(lm_result.params)
        
        if plot:
            xe = 0.25
            fit_x = np.linspace(np.min(livetable.xdata)-xe*x_span, np.max(livetable.xdata)+xe*x_span, num=500)
            fit_y = model(lm_result.params.valuesdict(), fit_x)
            #liveplot.add_line(fit_x, fit_y, color='b', linewidth=2.5)
            
            
        # Detect bad fits
        avg_deviation = np.sum(np.abs(lm_result.residual/y_max))/len(livetable.ydata)
        print('  avg deviation {:.1f}%'.format(avg_deviation*100))
        #avg_deviation of <1% is good.
        #avg_deviation of 1-4% is normal.
        #avg_deviation of 8% is not good (fit okay, but HM slightly off).
        #avg_deviation of 10% is bad fit.
        
        # TODO: Change the plotting if the fit is bad. (I.e. since we're using HM instead of fit, show that.)
        

    if avg_deviation>0.06:
        x0 = x0_guess
    else:
        x0 = lm_result.params['x0'].value
    
    print('Moving to x = {:.3f}'.format(x0))
    motor.move(x0)

    if toggle_beam:
        beam.off()

    lm_result_values = { k : v.value for k, v in lm_result.params.items() }
    return lm_result_values



def _test_fit_scan(motor, span, num=11, detectors=None, detector_suffix='', fit='HMi', background=None, per_step=None, wait_time=None, md={}):
    """
    Scans the specified motor, and attempts to fit the data as requested.
    
    Parameters
    ----------
    motor : motor
        The axis/stage/motor that you want to move.
    span : float
        The total size of the scan range (centered about the current position).
        If a two-element list is instead specified, this is interpreted as the
        distances relative to the current position for the start and end.
    num : int
        The number of scan points.
    fit : None or string
        If None, then fitting is not done. Otherwise, the model specified by the
        supplied string is used.
            peaks: gauss, lorentz, doublesigmoid, square
            edges: sigmoid, step
            stats: max, min, COM (center-of-mass), HM (half-max)
    background : None or string
        A baseline/background underlying the fit function can be specified.
        (In fact, a sequence of summed background functions can be supplied.)
            constant, linear
    md : dict, optional
        metadata        
    """
    
    # TODO: Normalize per ROI pixel and per count_time?
    
    if not beam.is_on():
        print('WARNING: Experimental shutter is not open.')
    
    initial_position = motor.user_readback.value
  
    if type(span) is list:
        start = initial_position+span[0]
        stop = initial_position+span[1]
    else:
        start = initial_position-span/2.
        stop = initial_position+span/2.
    span = abs(stop-start)
    #positions, dp = np.linspace(start, stop, num, endpoint=True, retstep=True)

    if detectors is None:
        detectors = get_beamline().detector
        plot_y = get_beamline().PLOT_Y
    else:
        plot_y = '{}{}'.format(detectors[0].name, detector_suffix)
    
    
    
    # Get axes for plotting
    title = 'fit_scan: {} vs. {}'.format(detectors[0].name, motor.name)
    #if len(plt.get_fignums())>0:
        # Try to use existing figure
        #fig = plt.gcf() # Most recent figure
        
    fig = None
    for i in plt.get_fignums():
        title_cur = plt.figure(i).canvas.manager.window.windowTitle()
        if title_cur==title:
            fig = plt.figure(i)
            break
            
    if fig is None:
        # New figure
        #fig, ax = plt.subplots() 
        fig = plt.figure(figsize=(11,7), facecolor='white')
        fig.canvas.manager.toolbar.pan()
        
    fig.canvas.set_window_title(title)
    ax = fig.gca()
    
    
    subs = []
    
    livetable = LiveTable([motor] + list(detectors))
    #livetable = LiveTable([motor] + list(detectors))
    subs.append(livetable)
    liveplot = LivePlot_Custom(plot_y, motor.name, ax=ax)
    subs.append(liveplot)
    
    if wait_time is not None:
        subs.append(MotorWait(motor, wait_time))
    
    
    if fit in ['max', 'min', 'COM', 'HM', 'HMi'] or type(fit) is list:
        
        livefit = LiveStat(fit, plot_y, motor.name)
        
        livefitplot = LiveStatPlot(livefit, ax=ax, scan_range=[start, stop])
        
        subs.append(livefitplot)
        
    
    elif fit is not None:
        
        # Perform a fit

        #livefit = LiveFit(lm_model, plot_y, {'x': motor.name}, init_guess)
        livefit = LiveFit_Custom(fit, plot_y, {'x': motor.name}, scan_range=[start, stop], background=background)
        
        #livefitplot = LiveFitPlot(livefit, color='k')
        livefitplot = LiveFitPlot_Custom(livefit, ax=ax, scan_range=[start, stop])
        
        subs.append(livefitplot)
        
        
    md['plan_header_override'] = 'fit_scan'
    md['scan'] = 'fit_scan'
    md['fit_function'] = fit
    md['fit_background'] = background

    # Perform the scan
    def _fit_scan():
        yield from scan(list(detectors), motor, start, stop, num, per_step=per_step, md=md)
        yield from read(list(detectors))
        #threshold=1
        #print(reading)
        #if reading['det']['value']>threshold:
            #print(reading['det']['value'])
            #print('the scan is DONE')
                 
    
    RE(_fit_scan())
    
    
#    RE(scan(list(detectors), motor, start, stop, num, per_step=per_step, md=md), subs )
   
    
    #if plot_y=='pilatus300_stats4_total' or plot_y=='pilatus300_stats3_total':
    if plot_y=='pilatus2M_stats4_total' or plot_y=='pilatus2M_stats3_total':
        remove_last_Pilatus_series()
    
    
    if fit is None:
        # Return to start position
        #motor.user_setpoint.set(initial_position)
        #mov(motor, initial_position)
        motor.move(initial_position)

    else:
        
        print( livefit.result.values )
        x0 = livefit.result.values['x0']
        #mov(motor, x0)
        motor.move(x0)
        
        return livefit.result

def setMonitor(monitor=['stats1', 'stats2', 'stats3', 'stats4']):
    if monitor == None: 
        monitor = ['stats3', 'stats4']
    
    pilatus2M.read_attrs = ['tiff'] + monitor

# TODO:
# - Fit parameters on graph
# - Correctly guess orientation of sigmoids/etc.
# - Have an 'auto' mode that just picks the right fit-function?
# - Do it silently (for autonomous modes); maybe save to disk
# - Allow fit to be 'redone' (with a different function) at the end.
## Maybe need a global pointer to the last fit? (Or contained within beamline?)

# HMi


# TODO:
# version of fit_scan for use in scripts (only fits at end, does lots of double-checks for sanity...)
# terminate the fit_scan when reaching < threshold



# BlueskyMagics were imported and registered in 00-startup.py

BlueskyMagics.detectors = [pilatus2M]
BlueskyMagics.positioners = [smx,smy,sth,schi,sphi,srot,strans,strans2,stilt,stilt2, WAXSx,WAXSy,WAXSz,SAXSx,SAXSy, bsx,bsy,bsphi, camx,camy, armz,armx,armphi,army,armr, bim3y,fs3y,bim4y,bim5y, s0.tp, s0.bt, s0.ob, s0.ib, s0.xc, s0.yc, s0.xg, s0.yg, s1.xc, s1.yc, s1.xg, s1.yg, s2.xc, s2.yc, s2.xg, s2.yg, s3.xc, s3.yc, s3.xg, s3.yg, s4.xc, s4.yc, s4.xg, s4.yg, s5.xc, s5.yc, s5.xg, s5.yg, mono_bragg,mono_pitch2,mono_roll2,mono_perp2, mir_usx,mir_dsx,mir_usy,mir_dsyi,mir_dsyo,mir_bend]

### Override the %wa magic with one that includes offsets.
### Later this will be added to bluesky itself and will not
### need to be customized here.


from IPython.core.magic import Magics, magics_class, line_magic
from operator import attrgetter


#@magics_class
#class CMSCustomMagics(BlueskyMagics):
    #@line_magic
    #def wa(self, line):
        #"List positioner info. 'wa' stands for 'where all'."
        #if line.strip():
            #positioners = eval(line, self.shell.user_ns)
        #else:
            #positioners = self.positioners
        #positioners = sorted(set(positioners), key=attrgetter('name'))
        #values = []
        #for p in positioners:
            #try:
                #values.append(p.position)
            #except Exception as exc:
                #values.append(exc)

        #headers = ['Positioner', 'Value', 'Low Limit', 'High Limit', 'Offset']
        #LINE_FMT = '{: <30} {: <10} {: <10} {: <10} {: <10}'
        #lines = []
        #lines.append(LINE_FMT.format(*headers))
        #for p, v in zip(positioners, values):
            #if not isinstance(v, Exception):
                #try:
                    #prec = p.precision
                #except Exception:
                    #prec = self.FMT_PREC
                #value = np.round(v, decimals=prec)
                #try:
                    #low_limit, high_limit = p.limits
                #except Exception as exc:
                    #low_limit = high_limit = exc.__class__.__name__
                #else:
                    #low_limit = np.round(low_limit, decimals=prec)%
                    #high_limit = np.round(high_limit, decimals=prec)
                #try:
                    #offset = p.user_offset.get()
                #except Exception as exc:
                    #offset = exc.__class__.__name__
                #else:
                    #offset = np.round(offset, decimals=prec)
            #else:
                #value = v.__class__.__name__  # e.g. 'DisconnectedError'
                #low_limit = high_limit = ''

            #lines.append(LINE_FMT.format(p.name, value, low_limit, high_limit,
                                         #offset))
        #print('\n'.join(lines))

## This will override the %wa registered from BlueskyMagics
##get_ipython().register_magics(CMSCustomMagics)



def wh_motors(motor=None, verbosity=3):
    if motor==None:
        motor_list1 = [schi, smx, smy, sphi, srot, sth, stilt, stilt2, strans, strans2] 
        motor_list2 = [s0.xc, s0.xg, s0.yc, s0.yg, s1.xc, s1.xg, s1.yc, s1.yg, s2.xc, s2.xg, s2.yc, s2.yg, s3.xc, s3.xg, s3.yc, s3.yg, s4.xc, s4.xg, s4.yc, s4.yg, s5.xc, s5.xg, s5.yc, s5.yg]
        motor_list3 = [SAXSx, SAXSy, WAXSx, WAXSy, WAXSz, armphi, armr, armx, army, armz, bim3y, bim4y, bim5y, bsphi, bsx, bsy,camx, camy, fs3y,mir_bend, mir_dsx, mir_dsyi, mir_dsyo, mir_usx, mir_usy, mono_bragg, mono_perp2, mono_pitch2, mono_roll2]
        motor_list = motor_list1 + motor_list2 + motor_list3
    else:
        motor_list = motor
        
    #for motor in motor_list:
        #print('motor: {} -- position: {} -- limits: {} -- offset: -- {} direction: {}'.format(motor.name, motor.position, motor.limits, motor.user_offset.value, sth.direction_of_travel.value))


    if verbosity>=1:
        print('|{:*^12}|{:*^12}|{:*^12}|{:*^12}|{:*^12}|{:*^12}|'.format('*','*','*','*','*','*'))
        print('|{:12}|{:12}|{:12}|{:12}|{:12}|{:12}|'.format('motor','position','low_limit','high_limit','offset', 'direction'))
        print('|{:*^12}|{:*^12}|{:*^12}|{:*^12}|{:*^12}|{:*^12}|'.format('*','*','*','*','*','*'))
        #print('|{:12}|{:12.4}|{:8.4}|{:8.4}|{:12}|{:5}|'
    
    last_z = -100
    beam = True
    
    flux_expected = None
    
    
    for motor in motor_list:
        #print('motor: {} -- position: {} -- limits: {} -- offset: -- {} direction: {}'.format(motor.name, motor.position, motor.limits, motor.user_offset.value, sth.direction_of_travel.value))

        #print('|{:12}  | {:6.6} | {} | {:11.11} | {:5} |'.format(motor.name, motor.position, motor.limits, motor.user_offset.value, sth.direction_of_travel.value))   
        ##print('|{:5.1}  | {:16.16} | {:s} | {:11.11} | {:11.11} | |'.format(motor.name, motor.position, motor.limits, motor.user_offset.value, sth.direction_of_travel.value))
        #print('|{:12}  | {:12} | {:12} | {:12} | {:5} |'.format(motor.name, motor.position, motor.limits, motor.user_offset.value, sth.direction_of_travel.value))   
        print('|{:12}|{:12.6}|{:12.6}|{:12.6}|{:12}|{:12}|'.format(motor.name, motor.position, motor.low_limit, motor.high_limit, motor.user_offset.value, motor.user_offset_dir.value))    
    if verbosity>=1:
        print('|{:*^12}|{:*^12}|{:*^12}|{:*^12}|{:*^12}|{:*^12}|'.format('*','*','*','*','*','*'))sd.baseline = []

#!/usr/bin/python
# -*- coding: utf-8 -*-
# vi: ts=4 sw=4

################################################################################
#  Code for defining a 'Sample' object, which keeps track of its state, and 
# simplifies the task of aligning, measuring, etc.
################################################################################
# Known Bugs:
#  N/A
################################################################################
# TODO:
#  - Search for "TODO" below.
#  - Ability to have a collection of simultaneous motions? (E.g. build up a set
#  of deferred motions?)
#  - Use internal naming scheme to control whether 'saxs'/'waxs' is put in the
# filename
################################################################################


import time
import re
import os
import shutil

import pandas as pds
from datetime import datetime
import functools

class CoordinateSystem(object):
    """
    A generic class defining a coordinate system. Several coordinate systems
    can be layered on top of one another (with a reference to the underlying
    coordinate system given by the 'base_stage' pointer). When motion of a given
    CoordinateSystem is requested, the motion is passed (with coordinate
    conversion) to the underlying stage.
    """
    
    hint_replacements = { 'positive': 'negative',
                         'up': 'down',
                         'left': 'right',
                         'towards': 'away from',
                         'downstream': 'upstream',
                         'inboard': 'outboard',
                         'clockwise': 'counterclockwise',
                         'CW': 'CCW',
                         }


    # Core methods
    ########################################
    
    def __init__(self, name='<unnamed>', base=None, **kwargs):
        '''Create a new CoordinateSystem (e.g. a stage or a sample).
        
        Parameters
        ----------
        name : str
            Name for this stage/sample.
        base : Stage
            The stage on which this stage/sample sits.
        '''        
        
        self.name = name
        self.base_stage = base
        
        
        self.enabled = True
        
        self.md = {}
        self._marks = {}

        self._set_axes_definitions()
        self._init_axes(self._axes_definitions)
        # self.align_success = True
        
    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        self._axes_definitions = []
        
        
    def _init_axes(self, axes):
        '''Internal method that generates method names to control the various axes.'''
        
        # Note: Instead of defining CoordinateSystem() having methods '.x', '.xr', 
        # '.y', '.yr', etc., we programmatically generate these methods when the 
        # class (and subclasses) are instantiated.
        # Thus, the Axis() class has generic versions of these methods, which are
        # appropriated renamed (bound, actually) when a class is instantiated.
        
        self._axes = {}
        
        for axis in axes:
            
            axis_object = Axis(axis['name'], axis['motor'], axis['enabled'], axis['scaling'], axis['units'], axis['hint'], self.base_stage, stage=self)
            self._axes[axis['name']] = axis_object
               
            # Bind the methods of axis_object to appropriately-named methods of 
            # the CoordinateSystem() class.
            setattr(self, axis['name'], axis_object.get_position )
            setattr(self, axis['name']+'abs', axis_object.move_absolute )
            setattr(self, axis['name']+'r', axis_object.move_relative )
            setattr(self, axis['name']+'pos', axis_object.get_position )
            setattr(self, axis['name']+'posMotor', axis_object.get_motor_position )
            
            
            setattr(self, axis['name']+'units', axis_object.get_units )
            setattr(self, axis['name']+'hint', axis_object.get_hint )
            setattr(self, axis['name']+'info', axis_object.get_info )
            
            setattr(self, axis['name']+'set', axis_object.set_current_position )
            setattr(self, axis['name']+'o', axis_object.goto_origin )
            setattr(self, axis['name']+'setOrigin', axis_object.set_origin )
            setattr(self, axis['name']+'mark', axis_object.mark )
            
            setattr(self, axis['name']+'search', axis_object.search )
            setattr(self, axis['name']+'scan', axis_object.scan )
            setattr(self, axis['name']+'c', axis_object.center )
            
            
    def comment(self, text, logbooks=None, tags=None, append_md=True, **md):
        '''Add a comment related to this CoordinateSystem.'''
        
        text += '\n\n[comment for CoordinateSystem: {} ({})].'.format(self.name, self.__class__.__name__)
        
        if append_md:
        
            md_current = { k : v for k, v in RE.md.items() } # Global md
            md_current.update(get_beamline().get_md()) # Beamline md

            # Self md
            #md_current.update(self.get_md())
            
            # Specified md
            md_current.update(md)
            
            text += '\n\n\nMetadata\n----------------------------------------'
            for key, value in sorted(md_current.items()):
                text += '\n{}: {}'.format(key, value)
            
        
        logbook.log(text, logbooks=logbooks, tags=tags)
    
    
    def set_base_stage(self, base):
        
        self.base_stage = base
        self._init_axes(self._axes_definitions)
        

    # Convenience/helper methods
    ########################################
    
    
    def multiple_string_replacements(self, text, replacements, word_boundaries=False):
        '''Peform multiple string replacements simultaneously. Matching is case-insensitive.
        
        Parameters
        ----------
        text : str
            Text to return modified
        replacements : dictionary
            Replacement pairs
        word_boundaries : bool, optional
            Decides whether replacements only occur for words.
        '''
        
        # Code inspired from:
        # http://stackoverflow.com/questions/6116978/python-replace-multiple-strings
        # Note inclusion of r'\b' sequences forces the regex-match to occur at word-boundaries.

        if word_boundaries:
            replacements = dict((r'\b'+re.escape(k.lower())+r'\b', v) for k, v in replacements.items())
            pattern = re.compile("|".join(replacements.keys()), re.IGNORECASE)
            text = pattern.sub(lambda m: replacements[r'\b'+re.escape(m.group(0).lower())+r'\b'], text)
            
        else:
            replacements = dict((re.escape(k.lower()), v) for k, v in replacements.items())
            pattern = re.compile("|".join(replacements.keys()), re.IGNORECfdeASE)
            text = pattern.sub(lambda m: rep[re.escape(m.group(0))], text)
        
        return text
    

    def _hint_replacements(self, text):
        '''Convert a motor-hint into its logical inverse.'''
        
        # Generates all the inverse replacements
        replacements = dict((v, k) for k, v in self.hint_replacements.items())
        replacements.update(self.hint_replacements)
        
        return self.multiple_string_replacements(text, replacements, word_boundaries=True)


    # Control methods
    ########################################
    def setTemperature(self, temperature, verbosity=3):
        if verbosity>=1:
            print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
        
        
    def temperature(self, verbosity=3):
        if verbosity>=1:
            print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
            
        return 0.0

        
    # Motion methods
    ########################################
    
    
    def enable(self):
        self.enabled = True
    
    
    def disable(self):
        self.enabled = False
    
    
    def is_enabled(self):
        return self.enabled
    
                          
    def pos(self, verbosity=3):
        '''Return (and print) the positions of all axes associated with this
        stage/sample.'''
        
        out = {}
        for axis_name, axis_object in sorted(self._axes.items()):
            out[axis_name] = axis_object.get_position(verbosity=verbosity)
            #if verbosity>=2: print('') # \n
            
        return out
                  
    def origin(self, verbosity=3):
        '''Returns the origin for axes.'''
        
        out = {}
        for axis_name, axis_object in sorted(self._axes.items()):
            origin = axis_object.get_origin()
            if verbosity>=2: print('{:s} origin = {:.3f} {:s}'.format(axis_name, origin, axis_object.get_units()))
            out[axis_name] = origin
            
        return out
            
        
    def gotoOrigin(self, axes=None):
        '''Go to the origin (zero-point) for this stage. All axes are zeroed,
        unless one specifies the axes to move.'''
        
        # TODO: Guard against possibly buggy behavior if 'axes' is a string instead of a list.
        # (Python will happily iterate over the characters in a string.)
        
        if axes is None:
            axes_to_move = self._axes.values()
            
        else:
            axes_to_move = [self._axes[axis_name] for axis_name in axes]
                
        for axis in axes_to_move:
            axis.goto_origin()
        
        
    def setOrigin(self, axes, positions=None):
        '''Define the current position as the zero-point (origin) for this stage/
        sample. The axes to be considered in this redefinition must be supplied
        as a list.
        
        If the optional positions parameter is passed, then those positions are
        used to define the origins for the axes.'''

        if positions is None:
        
            for axis in axes:
                getattr(self, axis+'setOrigin')()
                
        else:
            for axis, pos in zip(axes, positions):
                getattr(self, axis+'setOrigin')(pos)
    
    
    def gotoAlignedPosition(self):
        '''Goes to the currently-defined 'aligned' position for this stage. If
        no specific aligned position is defined, then the zero-point for the stage
        is used instead.'''
        
        # TODO: Optional offsets? (Like goto mark?)
        
        if 'aligned_position' in self.md and self.md['aligned_position'] is not None:
            for axis_name, position in self.md['aligned_position'].items():
                self._axes[axis_name].move_absolute(position)
        
        else:
            self.gotoOrigin()
        

            
            

    # Motion logging
    ########################################
            
    def setAlignedPosition(self, axes):
        '''Saves the current position as the 'aligned' position for this stage/
        sample. This allows one to return to this position later. One must
        specify the axes to be considered.

        WARNING: Currently this position data is not saved persistently. E.g. it will 
        be lost if you close and reopen the console.
        '''
        
        positions = {}
        for axis_name in axes:
            positions[axis_name] = self._axes[axis_name].get_position(verbosity=0)
        
        self.attributes['aligned_position'] = positions

            
    def mark(self, label, *axes, **axes_positions):
        '''Set a mark for the stage/sample/etc.
        
        'Marks' are locations that have been labelled, which is useful for 
        later going to a labelled position (using goto), or just to keep track
        of sample information (metadata).
        
        By default, the mark is set at the current position. If no 'axes' are 
        specified, all motors are logged. Alternately, axes (as strings) can 
        be specified. If axes_positions are given as keyword arguments, then 
        positions other than the current position can be specified.        
        '''
        
        positions = {}
        
        if len(axes)==0 and len(axes_positions)==0:
            
            for axis_name in self._axes:
                positions[axis_name] = self._axes[axis_name].get_position(verbosity=0)
                
        else:
            for axis_name in axes:
                positions[axis_name] = self._axes[axis_name].get_position(verbosity=0)
                
            for axis_name, position in axes_positions.items():
                positions[axis_name] = position
        
        self._marks[label] = positions
        
        
    def marks(self, verbosity=3):
        '''Get a list of the current marks on the stage/sample/etc. 'Marks' 
        are locations that have been labelled, which is useful for later
        going to a labelled position (using goto), or just to keep track
        of sample information (metadata).'''
        
        if verbosity>=3:
            print('Marks for {:s} (class {:s}):'.format(self.name, self.__class__.__name__))
        
        if verbosity>=2:
            for label, positions in self._marks.items():
                print(label)
                for axis_name, position in sorted(positions.items()):
                    print('  {:s} = {:.4f} {:s}'.format(axis_name, position, self._axes[axis_name].get_units()))
            
        return self._marks
    
    
    def goto(self, label, verbosity=3, **additional):
        '''Move the stage/sample to the location given by the label. For this
        to work, the specified label must have been 'marked' at some point.
        
        Additional keyword arguments can be provided. For instance, to move 
        3 mm from the left edge:
          sam.goto('left edge', xr=+3.0)
        '''
        
        if label not in self._marks:
            if verbosity>=1:
                print("Label '{:s}' not recognized. Use '.marks()' for the list of marked positions.".format(label))
            return
            
        for axis_name, position in sorted(self._marks[label].items()):
            
            if axis_name+'abs' in additional:
                # Override the marked value for this position
                position = additional[axis_name+'abs']
                del(additional[axis_name+'abs'])
            
            
            #relative = 0.0 if axis_name+'r' not in additional else additional[axis_name+'r']
            if axis_name+'r' in additional:
                relative = additional[axis_name+'r']
                del(additional[axis_name+'r'])
            else:
                relative = 0.0
            
            self._axes[axis_name].move_absolute(position+relative, verbosity=verbosity)


        # Handle any optional motions not already covered
        for command, amount in additional.items():
            if command[-1]=='r':
                getattr(self, command)(amount, verbosity=verbosity)
            elif command[-3:]=='abs':
                getattr(self, command)(amount, verbosity=verbosity)
            else:
                print("Keyword argument '{}' not understood (should be 'r' or 'abs').".format(command))


    # State methods
    ########################################
    def save_state(self):
        '''Outputs a string you can use to re-initialize this object back 
        to its current state.'''
        #TODO: Save to databroker?
        
        state = { 'origin': {} }
        for axis_name, axis in self._axes.items():
            state['origin'][axis_name] = axis.origin
        
        return state
    

    def restore_state(self, state):
        '''Outputs a string you can use to re-initialize this object back 
        to its current state.'''
        
        for axis_name, axis in self._axes.items():
            axis.origin = state['origin'][axis_name]


    # End class CoordinateSystem(object)
    ########################################

class Axis(object):
    '''Generic motor axis.
    
    Meant to be used within a CoordinateSystem() or Stage() object.
    '''
    
    def __init__(self, name, motor, enabled, scaling, units, hint, base, stage=None, origin=0.0):
        
        self.name = name
        self.motor = motor
        self.enabled = enabled
        self.scaling = scaling
        self.units = units
        self.hint = hint
        
        self.base_stage = base
        self.stage = stage
        
        self.origin = 0.0

        self._move_settle_max_time = 10.0
        self._move_settle_period = 0.05
        self._move_settle_tolerance = 0.01

    # Coordinate transformations
    ########################################
        
        
    def cur_to_base(self, position):
        '''Convert from this coordinate system to the coordinate in the (immediate) base.'''
        
        base_position = self.get_origin() + self.scaling*position
        
        return base_position
    
    
    def base_to_cur(self, base_position):
        '''Convert from this base position to the coordinate in the current system.'''
        
        position = (base_position - self.get_origin())/self.scaling
        
        return position
    
    
    def cur_to_motor(self, position):
        '''Convert from this coordinate system to the underlying motor.'''
        
        if self.motor is not None:
            return self.cur_to_base(position)
        
        else:
            base_position = self.cur_to_base(position)
            return self.base_stage._axes[self.name].cur_to_motor(base_position)
        
    def motor_to_cur(self, motor_position):
        '''Convert a motor position into the current coordinate system.'''
        
        if self.motor is not None:
            return self.base_to_cur(motor_position)
        
        else:
            base_position = self.base_stage._axes[self.name].motor_to_cur(motor_position)
            return self.base_to_cur(base_position)
        
            
            
    # Programmatically-defined methods
    ########################################
    # Note: Instead of defining CoordinateSystem() having methods '.x', '.xr', 
    # '.xp', etc., we programmatically generate these methods when the class 
    # (and subclasses) are instantiated.
    # Thus, the Axis() class has generic versions of these methods, which are
    # appropriated renamed (bound, actually) when a class is instantiated.
    def get_position(self, verbosity=3):
        '''Return the current position of this axis (in its coordinate system).
        By default, this also prints out the current position.'''
        
        
        if self.motor is not None:
            base_position = self.motor.position
            
        else:
            verbosity_c = verbosity if verbosity>=4 else 0
            base_position = getattr(self.base_stage, self.name+'pos')(verbosity=verbosity_c)
            
        position = self.base_to_cur(base_position)
        
        
        if verbosity>=2:
            if self.stage:
                stg = self.stage.name
            else:
                stg = '?'

            if verbosity>=5 and self.motor is not None:
                print( '{:s} = {:.3f} {:s}'.format(self.motor.name, base_position, self.get_units()) )
            
            print( '{:s}.{:s} = {:.3f} {:s} (origin = {:.3f})'.format(stg, self.name, position, self.get_units(), self.get_origin()) )
            
            
        return position
    
    
    def get_motor_position(self, verbosity=3):
        '''Returns the position of this axis, traced back to the underlying
        motor.'''
        
        if self.motor is not None:
            return self.motor.position
        
        else:
            return getattr(self.base_stage, self.name+'posMotor')(verbosity=verbosity)
            #return self.base_stage._axes[self.name].get_motor_position(verbosity=verbosity)
    
    
    def move_absolute(self, position=None, wait=True, verbosity=3):
        '''Move axis to the specified absolute position. The position is given
        in terms of this axis' current coordinate system. The "defer" argument
        can be used to defer motions until "move" is called.'''
        
        
        if position is None:
            # If called without any argument, just print the current position
            return self.get_position(verbosity=verbosity)
        
        # Account for coordinate transformation
        base_position = self.cur_to_base(position)
        
        if self.is_enabled():
            
            if self.motor:
                #mov( self.motor, base_position )
                self.motor.user_setpoint.value = base_position
                
            else:
                # Call self.base_stage.xabs(base_position)
                getattr(self.base_stage, self.name+'abs')(base_position, verbosity=0)


            if self.stage:
                stg = self.stage.name
            else:
                stg = '?'

            if verbosity>=2:
                
                # Show a realtime output of position
                start_time = time.time()
                current_position = self.get_position(verbosity=0)
                while abs(current_position-position)>self._move_settle_tolerance and (time.time()-start_time)<self._move_settle_max_time:
                    current_position = self.get_position(verbosity=0)
                    print( '{:s}.{:s} = {:5.3f} {:s}      \r'.format(stg, self.name, current_position, self.get_units()), end='')
                    time.sleep(self._move_settle_period)
                    
            #if verbosity>=1:
                #current_position = self.get_position(verbosity=0)
                #print( '{:s}.{:s} = {:5.3f} {:s}        '.format(stg, self.name, current_position, self.get_units()))
                
        elif verbosity>=1:
            print( 'Axis %s disabled (stage %s).' % (self.name, self.stage.name) )

    def move_relative(self, move_amount=None, verbosity=3):
        '''Move axis relative to the current position.'''
        
        if move_amount is None:
            # If called without any argument, just print the current position
            return self.get_position(verbosity=verbosity)
        
        target_position = self.get_position(verbosity=0) + move_amount
        
        return self.move_absolute(target_position, verbosity=verbosity)
        
    
    def goto_origin(self):
        '''Move axis to the currently-defined origin (zero-point).'''
        
        self.move_absolute(0)
    
    
    def set_origin(self, origin=None):
        '''Sets the origin (zero-point) for this axis. If no origin is supplied,
        the current position is redefined as zero. Alternatively, you can supply
        a position (in the current coordinate system of the axis) that should
        henceforth be considered zero.'''
        
        if origin is None:
            # Use current position
            if self.motor is not None:
                self.origin = self.motor.position
                
            else:
                if self.base_stage is None:
                    print("Error: %s %s has 'base_stage' and 'motor' set to 'None'." % (self.__class__.__name__, self.name))
                else:
                    self.origin = getattr(self.base_stage, self.name+'pos')(verbosity=0)
                    
        else:
            # Use supplied value (in the current coordinate system)
            base_position = self.cur_to_base(origin)
            self.origin = base_position
            
            
    def set_current_position(self, new_position):
        '''Redefines the position value of the current position.'''
        current_position = self.get_position(verbosity=0)
        self.origin = self.get_origin() + (current_position - new_position)*self.scaling


    def search(self, step_size=1.0, min_step=0.05, intensity=None, target=0.5, detector=None, detector_suffix=None, polarity=+1, verbosity=3):
        '''Moves this axis, searching for a target value.
        
        Parameters
        ----------
        step_size : float
            The initial step size when moving the axis
        min_step : float
            The final (minimum) step size to try
        intensity : float
            The expected full-beam intensity readout
        target : 0.0 to 1.0
            The target ratio of full-beam intensity; 0.5 searches for half-max.
            The target can also be 'max' to find a local maximum.
        detector, detector_suffix
            The beamline detector (and suffix, such as '_stats4_total') to trigger to measure intensity
        polarity : +1 or -1
            Positive motion assumes, e.g. a step-height 'up' (as the axis goes more positive)
        '''
        
        if not get_beamline().beam.is_on():
            print('WARNING: Experimental shutter is not open.')
        
        
        if intensity is None:
            intensity = RE.md['beam_intensity_expected']

        
        if detector is None:
            #detector = gs.DETS[0]
            detector = get_beamline().detector[0]
        if detector_suffix is None:
            #value_name = gs.TABLE_COLS[0]
            value_name = get_beamline().TABLE_COLS[0]
        else:
            value_name = detector.name + detector_suffix

        bec.disable_table()
        
        
        # Check current value
        RE(count([detector]))
        value = detector.read()[value_name]['value']


        if target == 'max':
            
            if verbosity>=5:
                print("Performing search on axis '{}' target is 'max'".format(self.name))
            
            max_value = value
            max_position = self.get_position(verbosity=0)
            
            
            direction = +1*polarity
            
            while step_size>=min_step:
                if verbosity>=4:
                    print("        move {} by {} × {}".format(self.name, direction, step_size))
                self.move_relative(move_amount=direction*step_size, verbosity=verbosity-2)

                prev_value = value
                RE(count([detector]))
                
                value = detector.read()[value_name]['value']
                if verbosity>=3:
                    print("      {} = {:.3f} {}; value : {}".format(self.name, self.get_position(verbosity=0), self.units, value))
                    
                if value>max_value:
                    max_value = value
                    max_position = self.get_position(verbosity=0)
                    
                if value>prev_value:
                    # Keep going in this direction...
                    pass
                else:
                    # Switch directions!
                    direction *= -1
                    step_size *= 0.5
                
                
        elif target == 'min':
            
            if verbosity>=5:
                print("Performing search on axis '{}' target is 'min'".format(self.name))
            
            direction = +1*polarity
            
            while step_size>=min_step:
                if verbosity>=4:
                    print("        move {} by {} × {}".format(self.name, direction, step_size))
                self.move_relative(move_amount=direction*step_size, verbosity=verbosity-2)

                prev_value = value
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                if verbosity>=3:
                    print("      {} = {:.3f} {}; value : {}".format(self.name, self.get_position(verbosity=0), self.units, value))
                    
                if value<prev_value:
                    # Keep going in this direction...
                    pass
                else:
                    # Switch directions!
                    direction *= -1
                    step_size *= 0.5
                                
        else:

            target_rel = target
            target = target_rel*intensity

            if verbosity>=5:
                print("Performing search on axis '{}' target {} × {} = {}".format(self.name, target_rel, intensity, target))
            if verbosity>=4:
                print("      value : {} ({:.1f}%)".format(value, 100.0*value/intensity))
            
            
            # Determine initial motion direction
            if value>target:
                direction = -1*polarity
            else:
                direction = +1*polarity
                
            while step_size>=min_step:
                
                if verbosity>=4:
                    print("        move {} by {} × {}".format(self.name, direction, step_size))
                self.move_relative(move_amount=direction*step_size, verbosity=verbosity-2)
                
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                if verbosity>=3:
                    print("      {} = {:.3f} {}; value : {} ({:.1f}%)".format(self.name, self.get_position(verbosity=0), self.units, value, 100.0*value/intensity))
                    
                # Determine direction
                if value>target:
                    new_direction = -1.0*polarity
                else:
                    new_direction = +1.0*polarity
                    
                if abs(direction-new_direction)<1e-4:
                    # Same direction as we've been going...
                    # ...keep moving this way
                    pass
                else:
                    # Switch directions!
                    direction *= -1
                    step_size *= 0.5
    
        bec.enable_table()
            

    def _search(self, step_size=1.0, min_step=0.05, intensity=None, maxInt=40000, target=0.5, detector=None, detector_suffix=None, polarity=+1, verbosity=3):
        '''Moves this axis, searching for a target value.
        
        Parameters
        ----------
        step_size : float
            The initial step size when moving the axis
        min_step : float
            The final (minimum) step size to try
        intensity : float
            The expected full-beam intensity readout
        target : 0.0 to 1.0
            The target ratio of full-beam intensity; 0.5 searches for half-max.
            The target can also be 'max' to find a local maximum.
        detector, detector_suffix
            The beamline detector (and suffix, such as '_stats4_total') to trigger to measure intensity
        polarity : +1 or -1
            Positive motion assumes, e.g. a step-height 'up' (as the axis goes more positive)
        '''
        
        if not get_beamline().beam.is_on():
            print('WARNING: Experimental shutter is not open.')
        
        
        if intensity is None:
            intensity = RE.md['beam_intensity_expected']

        
        if detector is None:
            #detector = gs.DETS[0]
            detector = get_beamline().detector[0]
        if detector_suffix is None:
            #value_name = gs.TABLE_COLS[0]
            value_name = get_beamline().TABLE_COLS[0]
        else:
            value_name = detector.name + detector_suffix

        bec.disable_table()
        
        
        # Check current value
        RE(count([detector]))
        value = detector.read()[value_name]['value']


        if target == 'max':
            
            if verbosity>=5:
                print("Performing search on axis '{}' target is 'max'".format(self.name))
            
            max_value = value
            max_position = self.get_position(verbosity=0)
            
            
            direction = +1*polarity
            
            while step_size>=min_step:
                if verbosity>=4:
                    print("        move {} by {} × {}".format(self.name, direction, step_size))
                self.move_relative(move_amount=direction*step_size, verbosity=verbosity-2)

                prev_value = value
                RE(count([detector]))
                
                value = detector.read()[value_name]['value']

                if abs(maxInt-value)/maxInt < 0.1:
                    self.align_success = False
                else:
                    self.align_success = True

                if verbosity>=3:
                    print("      {} = {:.3f} {}; value : {}".format(self.name, self.get_position(verbosity=0), self.units, value))
                    
                if value>max_value:
                    max_value = value
                    max_position = self.get_position(verbosity=0)
                    
                if value>prev_value:
                    # Keep going in this direction...
                    pass
                else:
                    # Switch directions!
                    direction *= -1
                    step_size *= 0.5
                
                
        elif target == 'min':
            
            if verbosity>=5:
                print("Performing search on axis '{}' target is 'min'".format(self.name))
            
            direction = +1*polarity
            
            while step_size>=min_step:
                if verbosity>=4:
                    print("        move {} by {} × {}".format(self.name, direction, step_size))
                self.move_relative(move_amount=direction*step_size, verbosity=verbosity-2)

                prev_value = value
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                if verbosity>=3:
                    print("      {} = {:.3f} {}; value : {}".format(self.name, self.get_position(verbosity=0), self.units, value))
                    
                if value<prev_value:
                    # Keep going in this direction...
                    pass
                else:
                    # Switch directions!
                    direction *= -1
                    step_size *= 0.5
                                
        else:

            target_rel = target
            target = target_rel*intensity

            if verbosity>=5:
                print("Performing search on axis '{}' target {} × {} = {}".format(self.name, target_rel, intensity, target))
            if verbosity>=4:
                print("      value : {} ({:.1f}%)".format(value, 100.0*value/intensity))
            
            
            # Determine initial motion direction
            if value>target:
                direction = -1*polarity
            else:
                direction = +1*polarity
                
            while step_size>=min_step:
                
                if verbosity>=4:
                    print("        move {} by {} × {}".format(self.name, direction, step_size))
                self.move_relative(move_amount=direction*step_size, verbosity=verbosity-2)
                
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                if verbosity>=3:
                    print("      {} = {:.3f} {}; value : {} ({:.1f}%)".format(self.name, self.get_position(verbosity=0), self.units, value, 100.0*value/intensity))
                    
                # Determine direction
                if value>target:
                    new_direction = -1.0*polarity
                else:
                    new_direction = +1.0*polarity
                    
                if abs(direction-new_direction)<1e-4:
                    # Same direction as we've been going...
                    # ...keep moving this way
                    pass
                else:
                    # Switch directions!
                    direction *= -1
                    step_size *= 0.5
    
        bec.enable_table()
 
                    
    def scan(self):
        print('todo')
        
    def center(self):
        print('todo')
        
    def mark(self, label, position=None, verbosity=3):
        '''Set a mark for this axis. (By default, the current position is
        used.)'''
        
        if position is None:
            position = self.get_position(verbosity=0)
            
        axes_positions = { self.name : position }
        self.stage.mark(label, **axes_positions)
            
    # Book-keeping
    ########################################
    
    def enable(self):
        self.enabled = True
        
        
    def disable(self):
        self.enabled = False
        
        
    def is_enabled(self):
        
        return self.enabled and self.stage.is_enabled()
    
        
    def get_origin(self):
        
        return self.origin
        
        
    def get_units(self):
        
        if self.units is not None:
            return self.units
        
        else:
            return getattr(self.base_stage, self.name+'units')()


    def get_hint(self, verbosity=3):
        '''Return (and print) the "motion hint" associated with this axis. This
        hint gives information about the expected directionality of the motion.'''
        
        if self.hint is not None:
            s = '%s\n%s' % (self.hint, self.stage._hint_replacements(self.hint))
            if verbosity>=2:
                print(s)
            return s
        
        else:
            return getattr(self.base_stage, self.name+'hint')(verbosity=verbosity)
        
        
    def get_info(self, verbosity=3):
        '''Returns information about this axis.'''
        
        self.get_position(verbosity=verbosity)
        self.get_hint(verbosity=verbosity)

        
    def check_base(self):
        if self.base_stage is None:
            print("Error: %s %s has 'base_stage' set to 'None'." % (self.__class__.__name__, self.name))
        

class Sample_Generic(CoordinateSystem):
    """
    The Sample() classes are used to define a single, individual sample. Each
    sample is created with a particular name, which is recorded during measurements.
    Logging of comments also includes the sample name. Different Sample() classes
    can define different defaults for alignment, measurement, etc.
    """


    # Core methods
    ########################################
    def __init__(self, name, base=None, **md):
        '''Create a new Sample object.
        
        Parameters
        ----------
        name : str
            Name for this sample.
        base : Stage
            The stage/holder on which this sample sits.
        '''               
        
        if base is None:
            base = get_default_stage()
            #print("Note: No base/stage/holder specified for sample '{:s}'. Assuming '{:s}' (class {:s})".format(name, base.name, base.__class__.__name__))
            
        
        super().__init__(name=name, base=base)
        
        self.name = name
        
        
        self.md = {
            'exposure_time' : 1.0 ,
            'measurement_ID' : 1 ,
            }
        self.md.update(md)
        
        self.naming_scheme = ['name', 'extra', 'exposure_time','id']
        self.naming_delimeter = '_'
        

        # TODO
        #if base is not None:
            #base.addSample(self)
        
        
        self.reset_clock()
        
        
    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        self._axes_definitions = [ {'name': 'x',
                            'motor': None,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': None,
                            'hint': None,
                            },
                            {'name': 'y',
                            'motor': None,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': None,
                            },
                            #{'name': 'z',
                            #'motor': None,
                            #'enabled': False,
                            #'scaling': +1.0,
                            #'units': 'mm',
                            #'hint': None,
                            #},
                            {'name': 'th',
                            'motor': None,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'deg',
                            'hint': None,
                            },
                            #{'name': 'chi',
                            #'motor': None,
                            #'enabled': True,
                            #'scaling': +1.0,
                            #'units': 'deg',
                            #'hint': None,
                            #},
                            # {'name': 'phi',
                            # 'motor': srot,
                            # 'enabled': True,
                            # 'scaling': +1.0,
                            # 'units': 'deg',
                            # 'hint': None,
                            # },
                            #{'name': 'yy',
                            #'motor': None,
                            #'enabled': True,
                            #'scaling': +1.0,
                            #'units': 'mm',
                            #'hint': None,
                            #},
                            ]          
        

        
    # Metadata methods
    ########################################
    # These involve setting or getting values associated with this sample.
        
    def clock(self):
        '''Return the current value of the "clock" variable. This provides a
        way to set a clock/timer for a sample. For instance, you can call
        "reset_clock" when you initiate some change to the sample. Thereafter,
        the "clock" method lets you check how long it has been since that
        event.'''
        
        clock_delta = time.time() - self.clock_zero
        return clock_delta
        

    def reset_clock(self):
        '''Resets the sample's internal clock/timer to zero.'''
        
        self.clock_zero = time.time()
        
        return self.clock()        
        
        
        
    def get_attribute(self, attribute):
        '''Return the value of the requested md.'''
        
        if attribute in self._axes:
            return self._axes[attribute].get_position(verbosity=0)
        
        if attribute=='name':
            return self.name

        if attribute=='clock':
            return self.clock()

        if attribute=='temperature':
            return self.temperature(verbosity=0)
        if attribute=='temperature_A':
            return self.temperature(temperature_probe='A', verbosity=0)
        if attribute=='temperature_B':
            return self.temperature(temperature_probe='B',verbosity=0)
        if attribute=='temperature_C':
            return self.temperature(temperature_probe='C',verbosity=0)
        if attribute=='temperature_D':
            return self.temperature(temperature_probe='D',verbosity=0)
        if attribute=='temperature_E':
            return self.temperature(temperature_probe='E',verbosity=0)
        if attribute=='humidity':
            return self.humidity(verbosity=0)
  
        if attribute=='WAXSy':
            return WAXSy.position
        if attribute=='WAXSx':
            return WAXSx.position
        
        if attribute=='SAXSy':
            return SAXSy.position
        if attribute=='SAXSx':
            return SAXSx.position
        
        if attribute in self.md:
            return self.md[attribute]
        if attribute=='energy':
            return '{}kev'.format(np.round(beam.energy(verbosity=0),2))
        if attribute=='dry':
            return 'dry{}'.format(readDryFlow())
        if attribute=='wet':
            return 'wet{}'.format(readWetFlow())
        if attribute=='flow':
            if MFC.mode('A1')==0: #open
                return 'flowMAX'
            if MFC.mode('A1')==1: #close
                return 'flowOFF'
            if MFC.mode('A1')==2:
                return 'flow{}'.format(MFC.flow('A1'))
        if attribute=='voltage':
            return '{0:.3f}V'.format(ioL.read(AI[1]))
        for ii in range(9):
            if attribute=='voltage{}'.format(ii):
                return '{0:.3f}V'.format(ioL.read(AI[ii]))
        if attribute=='applied_v':
            return '{0:.3f}V'.format(ioL.read(AO[5]))
        if attribute=='TC':
            temp = 1.0175 * ioL.read(TC[1]) - 4.1286    #temporary for B. Wild run 10/16/19
            return '{0:.3f}C'.format(temp)

        replacements = { 
            'id' : 'measurement_ID' ,
            'ID' : 'measurement_ID' ,
            'extra' : 'savename_extra' ,
            }
        
        if attribute=='pos1':
            return 'pos1'
        if attribute=='pos2':
            return 'pos2'
        if attribute=='pos3':
            return 'pos3'
        if attribute=='pos4':
            return 'pos4'

        if attribute in replacements:
            return self.md[replacements[attribute]]
        
        return None
            

    def set_attribute(self, attribute, value):
        '''Arbitrary attributes can be set and retrieved. You can use this to 
        store additional meta-data about the sample.
        
        WARNING: Currently this meta-data is not saved anywhere. You can opt
        to store the information in the sample filename (using "naming").
        '''
        
        self.md[attribute] = value
        
        
    def set_md(self, **md):
        
        self.md.update(md)
        
        
        
    def get_md(self, prefix='sample_', include_marks=True, **md):
        '''Returns a dictionary of the current metadata.
        The 'prefix' argument is prepended to all the md keys, which allows the
        metadata to be grouped with other metadata in a clear way. (Especially,
        to make it explicit that this metadata came from the sample.)'''
        
        # Update internal md
        #self.md['key'] = value

        
        md_return = self.md.copy()
        md_return['name'] = self.name
    
    
        if include_marks:
            for label, positions in self._marks.items():
                md_return['mark_'+label] = positions
    
    
        # Add md that varies over time
        md_return['clock'] = self.clock()
        md_return['temperature'] = self.temperature(temperature_probe='A', verbosity=0)
        md_return['temperature_A'] = self.temperature(temperature_probe='A', verbosity=0)
        md_return['temperature_B'] = self.temperature(temperature_probe='B', verbosity=0)
        md_return['temperature_C'] = self.temperature(temperature_probe='C', verbosity=0)
        md_return['temperature_D'] = self.temperature(temperature_probe='D', verbosity=0)
        #md_return['temperature_E'] = self.temperature(temperature_probe='E', verbosity=0)
        # md_return['humidity'] = self.humidity(verbosity=0)
    
        for axis_name, axis in self._axes.items():
            md_return[axis_name] = axis.get_position(verbosity=0)
            md_return['motor_'+axis_name] = axis.get_motor_position(verbosity=0)
        
        
        md_return['savename'] = self.get_savename() # This should be over-ridden by 'measure'



        #TODO: save the attributes into metadata --061921 RL
        '''
        for attribute in self.naming_scheme:
            md_return[attribute] = self.get_attribute(attribute)
            # self.set_attribute(attribute, self.get_attribute(attribute))
        '''    
        

        # Include the user-specified metadata
        md_return.update(md)

    
        # Add an optional prefix
        if prefix is not None:
            md_return = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_return.items() }
    
        return md_return
    
        
    # Naming scheme methods
    ########################################
    # These allow the user to control how data is named.
        
    def naming(self, scheme=['name', 'extra', 'exposure_time','id'], delimeter='_'):
        '''This method allows one to define the naming convention that will be
        used when storing data for this sample. The "scheme" variable is an array
        that lists the various elements one wants to store in the filename.
        
        Each entry in "scheme" is a string referring to a particular element/
        value. For instance, motor names can be stored ("x", "y", etc.), the
        measurement time can be stored, etc.'''
        
        self.naming_scheme = scheme
        self.naming_delimeter = delimeter


    def get_naming_string(self, attribute):
        
        # Handle special cases of formatting the text
        
        if attribute in self._axes:
            return '{:s}{:.3f}'.format(attribute, self._axes[attribute].get_position(verbosity=0))
        
        if attribute=='clock':
            return '{:.1f}s'.format(self.get_attribute(attribute))

        if attribute=='exposure_time':
            return '{:.2f}s'.format(self.get_attribute(attribute))

        if attribute=='temperature':
            return 'T{:.3f}C'.format(self.get_attribute(attribute))
        if attribute=='temperature_A':
            return 'T{:.3f}C'.format(self.get_attribute(attribute))
        if attribute=='temperature_B':
            return 'T{:.3f}C'.format(self.get_attribute(attribute))
        if attribute=='temperature_C':
            return 'T{:.3f}C'.format(self.get_attribute(attribute))
        if attribute=='temperature_D':
            return 'T{:.3f}C'.format(self.get_attribute(attribute))
        if attribute=='temperature_E':
            return 'T{:.3f}C'.format(self.get_attribute(attribute))
        if attribute=='humidity':
            return 'RH{:.3f}'.format(self.get_attribute(attribute))
        if attribute=='trigger_time':
            return '{:.1f}s'.format(self.get_attribute(attribute))

        if attribute=='WAXSy':
           return 'WAXSy{}'.format(self.get_attribute(attribute))
        if attribute=='WAXSx':
           return 'WAXSx{}'.format(self.get_attribute(attribute))

        if attribute=='SAXSy':
           return 'SAXSy{}'.format(self.get_attribute(attribute))
        if attribute=='SAXSx':
           return 'SAXSx{}'.format(self.get_attribute(attribute))

        if attribute=='extra':
            # Note: Don't eliminate this check; it will not be properly handled
            # by the generic call below. When 'extra' is None, we should
            # return None, so that it gets skipped entirely.
            return self.get_attribute('savename_extra')

        if attribute=='spot_number':
            return 'spot{:d}'.format(self.get_attribute(attribute))
        

        # Generically: lookup the attribute and convert to string
        
        att = self.get_attribute(attribute)
        if att is None:
            # If the attribute is not found, simply return the text.
            # This allows the user to insert arbitrary text info into the
            # naming scheme.
            return attribute
        
        else:

            #TODO: save the attributes into metadata --061921 RL
            '''
            for attribute in self.get_attribute(attribute):
                self.set_attribute(attribute, self.get_attribute(attribute))
            '''    
            
            return str(att)
        

    def get_savename(self, savename_extra=None):
        '''Return the filename that will be used to store data for the upcoming
        measurement. The method "naming" lets one control what gets stored in
        the filename.'''
        
        if savename_extra is not None:
            self.set_attribute('savename_extra', savename_extra)
        
        attribute_strings = []
        for attribute in self.naming_scheme:
            s = self.get_naming_string(attribute)
            if s is not None:
                attribute_strings.append(s)

        self.set_attribute('savename_extra', None)
        
        savename = self.naming_delimeter.join(attribute_strings)
        
        # Avoid 'dangerous' characters
        savename = savename.replace(' ', '_')
        #savename = savename.replace('.', 'p')
        savename = savename.replace('/', '-slash-')
        
        return savename
    
        
        
    # Logging methods
    ########################################
    
    def comment(self, text, logbooks=None, tags=None, append_md=True, **md):
        '''Add a comment related to this sample.'''
        
        text += '\n\n[comment for sample: {} ({})].'.format(self.name, self.__class__.__name__)
        
        if append_md:
        
            md_current = { k : v for k, v in RE.md.items() } # Global md
            md_current.update(get_beamline().get_md()) # Beamline md

            # Sample md
            md_current.update(self.get_md())
            
            # Specified md
            md_current.update(md)
            
            text += '\n\n\nMetadata\n----------------------------------------'
            for key, value in sorted(md_current.items()):
                text += '\n{}: {}'.format(key, value)
            
        
        logbook.log(text, logbooks=logbooks, tags=tags)
        
        
    def log(self, text, logbooks=None, tags=None, append_md=True, **md):
        
        if append_md:
        
            text += '\n\n\nMetadata\n----------------------------------------'
            for key, value in sorted(md.items()):
                text += '\n{}: {}'.format(key, value)
        
        logbook.log(text, logbooks=logbooks, tags=tags)        


    # Control methods
    ########################################
    def setTemperature(self, temperature, verbosity=3):
        return self.base_stage.setTemperature(temperature, verbosity=verbosity)
        
        
    def temperature(self, verbosity=3):
        return self.base_stage.temperature(verbosity=verbosity)
    

    
    # Measurement methods
    ########################################
    
    def get_measurement_md(self, prefix=None, **md):
        
        #md_current = {}
        md_current = { k : v for k, v in RE.md.items() } # Global md

        #md_current['detector_sequence_ID'] = caget('XF:11BMB-ES{Det:SAXS}:cam1:FileNumber_RBV')
        #md_current['detector_sequence_ID'] = caget('XF:11BMB-ES{}:cam1:FileNumber_RBV'.format(pilatus_Epicsname))
        if get_beamline().detector[0].name is 'pilatus300':
            md_current['detector_sequence_ID'] = caget('XF:11BMB-ES{Det:SAXS}:cam1:FileNumber_RBV')
        elif get_beamline().detector[0].name is 'pilatus2M':
            md_current['detector_sequence_ID'] = caget('XF:11BMB-ES{Det:PIL2M}:cam1:FileNumber_RBV')
          
        md_current.update(get_beamline().get_md())
        
        md_current.update(md)

        # Add an optional prefix
        if prefix is not None:
            md_return = { '{:s}{:s}'.format(prefix, key) : value for key, value in md_return.items() }
        
        return md_current

    
    def _expose_manual(self, exposure_time=None, verbosity=3, poling_period=0.1, **md):
        '''Internal function that is called to actually trigger a measurement.'''
        
        # TODO: Improve this (switch to Bluesky methods)
        # TODO: Store metadata
        
        if 'measure_type' not in md:
            md['measure_type'] = 'expose'
        self.log('{} for {}.'.format(md['measure_type'], self.name), **md)

        if exposure_time is not None:
            # Prep detector
            #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', exposure_time)
            #caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', exposure_time+0.1)
            #caput('XF:11BMB-ES{}:cam1:AcquireTime'.format(pilatus_Epicsname), exposure_time)
            #caput('XF:11BMB-ES{}:cam1:AcquirePeriod'.format(pilatus_Epicsname), exposure_time+0.1)

            if get_beamline().detector[0].name is 'pilatus300':
                caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', exposure_time)
                caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', exposure_time+0.1)
            elif get_beamline().detector[0].name is 'pilatus2M':
                caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime', exposure_time)
                caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquirePeriod', exposure_time+0.1)
        
        get_beamline().beam.on()
        
        # Trigger acquisition manually
        caput('XF:11BMB-ES{}:cam1:Acquire'.format(pilatus_Epicsname), 1)
        
        if verbosity>=2:
            start_time = time.time()
            while caget('XF:11BMB-ES{}:cam1:Acquire'.format(pilatus_Epicsname))==1 and (time.time()-start_time)<(exposure_time+20):
                percentage = 100*(time.time()-start_time)/exposure_time
                print( 'Exposing {:6.2f} s  ({:3.0f}%)      \r'.format((time.time()-start_time), percentage), end='')
                time.sleep(poling_period)
        else:
            time.sleep(exposure_time)
            
        if verbosity>=3 and caget('XF:11BMB-ES{}:cam1:Acquire'.format(pilatus_Epicsname))==1:
            print('Warning: Detector still not done acquiring.')
        
        get_beamline().beam.off()
        

    def expose(self, exposure_time=None, extra=None, handlefile=True, verbosity=3, poling_period=0.1, **md):
        '''Internal function that is called to actually trigger a measurement.'''
        '''TODO: **md doesnot work in RE(count). '''
        
        
        if 'measure_type' not in md:
            md['measure_type'] = 'expose'
        #self.log('{} for {}.'.format(md['measure_type'], self.name), **md)

        # Set exposure time
        if exposure_time is not None:
            exposure_time = abs(exposure_time)
            #for detector in gs.DETS:
            for detector in get_beamline().detector:
                if exposure_time != detector.cam.acquire_time.get():  #caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'):
                    RE(detector.setExposureTime(exposure_time, verbosity=verbosity))
                #if detector.name is 'pilatus800' and exposure_time != detector.cam.acquire_time.get():  #caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'):
                    #RE(detector.setExposureTime(exposure_time, verbosity=verbosity))
                #if detector.name is 'pilatus300' and exposure_time != detector.cam.acquire_time.get():
                    #detector.setExposureTime(exposure_time, verbosity=verbosity)
                    ##extra wait time when changing the exposure time.  
                    ##time.sleep(2)
                    #############################################
                    ##extra wait time for adjusting pilatus2M 
                    ##this extra wait time has to be added. Otherwise, the exposure will be skipped when the exposure time is increased
                    ##Note by 091918
                    #############################################
                    #time.sleep(2)
                #elif detector.name is 'PhotonicSciences_CMS':
                    #detector.setExposureTime(exposure_time, verbosity=verbosity)

        # Do acquisition
        get_beamline().beam.on()
        
        md['plan_header_override'] = md['measure_type']
        start_time = time.time()
        
        #md_current = self.get_md()
        md['beam_int_bim3'] = beam.bim3.flux(verbosity=0)
        md['beam_int_bim4'] = beam.bim4.flux(verbosity=0)
        md['beam_int_bim5'] = beam.bim5.flux(verbosity=0)
        #md['trigger_time'] = self.clock()
        #md.update(md_current)

        #uids = RE(count(get_beamline().detector, 1), **md)
        uids = RE(count(get_beamline().detector), **md)
        #yield from (count(get_beamline().detector), **md)
        
        #get_beamline().beam.off()
        #print('shutter is off')

        # Wait for detectors to be ready
        max_exposure_time = 0.1
        for detector in get_beamline().detector:
            if detector.name is 'pilatus300':
                current_exposure_time = detector.cam.acquire_time.get()
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            elif detector.name is 'pilatus2M':
                current_exposure_time = detector.cam.acquire_time.get()
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            elif detector.name is 'pilatus800' or detector.name is 'pilatus8002':  
                current_exposure_time = detector.cam.acquire_time.get()
                max_exposure_time = max(max_exposure_time, current_exposure_time)


            # if detector.name is 'pilatus300':
            #     current_exposure_time = caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime')
            #     max_exposure_time = max(max_exposure_time, current_exposure_time)
            # elif detector.name is 'pilatus2M':
            #     current_exposure_time = caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime')
            #     max_exposure_time = max(max_exposure_time, current_exposure_time)
            # elif detector.name is 'pilatus800':
            #     current_exposure_time = caget('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime')
            #     max_exposure_time = max(max_exposure_time, current_exposure_time)
            #elif detector.name is 'PhotonicSciences_CMS':
                #current_exposure_time = detector.exposure_time
                #max_exposure_time = max(max_exposure_time, current_exposure_time)
            else:
                if verbosity>=1:
                    print("WARNING: Didn't recognize detector '{}'.".format(detector.name))
            
        if verbosity>=2:

            status = 0
            while (status==0) and (time.time()-start_time)<(max_exposure_time+20):
                percentage = 100*(time.time()-start_time)/max_exposure_time
                print( 'Exposing {:6.2f} s  ({:3.0f}%)      \r'.format((time.time()-start_time), percentage), end='')


                time.sleep(poling_period)
                
                status = 1
                for detector in get_beamline().detector:
                    if detector.cam.acquire.get()==1:
                        status *= 0

            # print('counting .... percentage = {}'.format(percentage))

        else:
            time.sleep(max_exposure_time)

        #special solution for 2022_1/TKoga2
        if verbosity>=5:
            print('verbosity = {}.'.format(verbosity))
            pct_threshold = 90
            while percentage < pct_threshold:
                print('sth is wrong .... percentage = {} < {}%'.format(percentage, pct_threshold))
                start_time = time.time()
                uids = RE(count(get_beamline().detector), **md)
                #yield from (count(get_beamline().detector), **md)
                
                #get_beamline().beam.off()
                #print('shutter is off')

                # Wait for detectors to be ready
                max_exposure_time = 0.1
                for detector in get_beamline().detector:
                    if detector.name is 'pilatus300':
                        current_exposure_time = detector.cam.acquire_time.get()
                        max_exposure_time = max(max_exposure_time, current_exposure_time)
                    elif detector.name is 'pilatus2M':
                        current_exposure_time = detector.cam.acquire_time.get()
                        max_exposure_time = max(max_exposure_time, current_exposure_time)
                    elif detector.name is 'pilatus800' or detector.name is 'pilatus8002':  
                        current_exposure_time = detector.cam.acquire_time.get()
                        max_exposure_time = max(max_exposure_time, current_exposure_time)

                percentage = 100*(time.time()-start_time)/max_exposure_time
                print('After re-exposing .... percentage = {} '.format(percentage))
                
                    # if detector.name is 'pilatus300':
                    #     if caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
                    #         status *= 0
                    # elif detector.name is 'pilatus2M':
                    #     if caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
                    #         status *= 0
                    # elif detector.name is 'pilatus800':
                    #     if caget('XF:11BMB-ES{Det:PIL800K}:cam1:Acquire')==1:
                    #         status *= 0
                    #elif detector.name is 'PhotonicSciences_CMS':
                        #if not detector.detector_is_ready(verbosity=0):
                            #status *= 0
                    
                


        # if verbosity>=3 and caget('XF:11BMB-ES{Det:PIL800K}:cam1:Acquire')==1:
        #     print('Warning: Detector pilatus300 still not done acquiring.')
        
        # #if verbosity>=3 and caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
        #     #print('Warning: Detector pilatus300 still not done acquiring.')

        # if verbosity>=3 and caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
        #     print('Warning: Detector pilatus2M still not done acquiring.')
 
        
        get_beamline().beam.off()
        
        #save the percentage information
        # if verbosity>=5:
        #     folder = '/nsls2/data/cms/legacy/xf11bm/data/2022_1/TKoga2/'
        #     # filename = ''

        #     current_data = {'a_sample': self.name,
        #                     'b_exposure_time': detector.cam.acquire_time.get(), 
        #                     'c_exposure_percentage': percentage, 
        #                     'd_align_time': md['filename'] 
        #                     }
            
        #     temp_data = pds.DataFrame([current_data])

        #     # INT_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , 'alignment_results.csv')            
        #     INT_FILENAME='{}/data/{}.csv'.format(folder , 'exposure_info.csv')            
        
        #     if os.path.isfile(INT_FILENAME):
        #         output_data = pds.read_csv(INT_FILENAME, index_col=0)
        #         output_data = output_data.append(temp_data, ignore_index=True)    
        #         output_data.to_csv(INT_FILENAME)
        #     else:
        #         temp_data.to_csv(INT_FILENAME)

        if handlefile == True:
            for detector in get_beamline().detector:
                self.handle_file(detector, extra=extra, verbosity=verbosity, **md)
                #self.handle_file(detector, extra=extra, verbosity=verbosity)


    def _expose_test(self, exposure_time=None, extra=None, handlefile=True, verbosity=3, poling_period=0.1, **md):
        '''Internal function that is called to actually trigger a measurement.'''
        '''TODO: **md doesnot work in RE(count). '''
        
        
        if 'measure_type' not in md:
            md['measure_type'] = 'expose'
        #self.log('{} for {}.'.format(md['measure_type'], self.name), **md)

        # Set exposure time
        start_time = time.time()
        print('1', time.time()-start_time)
        if exposure_time is not None:
            exposure_time = abs(exposure_time)
            #for detector in gs.DETS:
            for detector in get_beamline().detector:
                if exposure_time != detector.cam.acquire_time.get():  #caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'):
                    RE(detector.setExposureTime(exposure_time, verbosity=verbosity))
                #if detector.name is 'pilatus800' and exposure_time != detector.cam.acquire_time.get():  #caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'):
                    #RE(detector.setExposureTime(exposure_time, verbosity=verbosity))
                #if detector.name is 'pilatus300' and exposure_time != detector.cam.acquire_time.get():
                    #detector.setExposureTime(exposure_time, verbosity=verbosity)
                    ##extra wait time when changing the exposure time.  
                    ##time.sleep(2)
                    #############################################
                    ##extra wait time for adjusting pilatus2M 
                    ##this extra wait time has to be added. Otherwise, the exposure will be skipped when the exposure time is increased
                    ##Note by 091918
                    #############################################
                    #time.sleep(2)
                #elif detector.name is 'PhotonicSciences_CMS':
                    #detector.setExposureTime(exposure_time, verbosity=verbosity)
        print('2', time.time()-start_time)

        # Do acquisition
        get_beamline().beam.on()
        print('beamon', time.time()-start_time)
        
        md['plan_header_override'] = md['measure_type']
        #start_time = time.time()
        
        #md_current = self.get_md()
        md['beam_int_bim3'] = beam.bim3.flux(verbosity=0)
        md['beam_int_bim4'] = beam.bim4.flux(verbosity=0)
        md['beam_int_bim5'] = beam.bim5.flux(verbosity=0)
        #md['trigger_time'] = self.clock()
        #md.update(md_current)

        print('3', time.time()-start_time)
        #uids = RE(count(get_beamline().detector, 1), **md)
        uids = RE(count(get_beamline().detector), **md)
        #yield from (count(get_beamline().detector), **md)
        print('4', time.time()-start_time)
        
        #get_beamline().beam.off()
        #print('shutter is off')

        # Wait for detectors to be ready
        max_exposure_time = 0.1
        for detector in get_beamline().detector:
            if detector.name is 'pilatus300':
                current_exposure_time = caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime')
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            elif detector.name is 'pilatus2M':
                current_exposure_time = caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime')
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            elif detector.name is 'pilatus800':
                current_exposure_time = caget('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime')
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            #elif detector.name is 'PhotonicSciences_CMS':
                #current_exposure_time = detector.exposure_time
                #max_exposure_time = max(max_exposure_time, current_exposure_time)
            else:
                if verbosity>=1:
                    print("WARNING: Didn't recognize detector '{}'.".format(detector.name))
            
        print('5', time.time()-start_time)
        if verbosity>=2:
            status = 0
            while (status==0) and (time.time()-start_time)<(max_exposure_time+20):
                percentage = 100*(time.time()-start_time)/max_exposure_time
                print( 'Exposing {:6.2f} s  ({:3.0f}%)      \r'.format((time.time()-start_time), percentage), end='')
                time.sleep(poling_period)
                
                status = 1
                for detector in get_beamline().detector:
                    if detector.name is 'pilatus300':
                        if caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
                            status *= 0
                    elif detector.name is 'pilatus2M':
                        if caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
                            status *= 0
                    elif detector.name is 'pilatus800':
                        if caget('XF:11BMB-ES{Det:PIL800K}:cam1:Acquire')==1:
                            status *= 0
                    #elif detector.name is 'PhotonicSciences_CMS':
                        #if not detector.detector_is_ready(verbosity=0):
                            #status *= 0
            print('6', time.time()-start_time)
                    
                
        else:
            time.sleep(max_exposure_time)
        print('7', time.time()-start_time)
        
        #if verbosity>=3 and caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
            #print('Warning: Detector pilatus300 still not done acquiring.')

        if verbosity>=3 and caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
            print('Warning: Detector pilatus2M still not done acquiring.')
 
        
        get_beamline().beam.off()
        print('8', time.time()-start_time)
        
        #if handlefile == True:
            #for detector in get_beamline().detector:
                #self.handle_file(detector, extra=extra, verbosity=verbosity, **md)
                ##self.handle_file(detector, extra=extra, verbosity=verbosity)


    def handle_file(self, detector, extra=None, verbosity=3, subdirs=True, linksave=True, **md):
    
        subdir = ''
        if subdirs:
            if detector.name is 'pilatus300' or  detector.name is 'pilatus8002' :
                subdir = '/maxs/raw/'
                detname = 'maxs'
            elif detector.name is  'pilatus2M':
                subdir = '/saxs/raw/'
                detname = 'saxs'
            elif detector.name is  'pilatus800':
                subdir = '/waxs/raw/'
                detname = 'waxs'
            else:
                if verbosity>=1:
                    print("WARNING: Can't do file handling for detector '{}'.".format(detector.name))
                    return        
        
        filename = detector.tiff.full_file_name.get() #RL, 20210831
        
        # Alternate method to get the last filename
        #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

        if verbosity>=3:
            print('  Data saved to: {}'.format(filename))

        #if md['measure_type'] is not 'snap':
        if True:
            
            # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime'))
            self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831
            
            # Create symlink
            #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
            #savename = md['filename'][:-5]

            #savename = self.get_savename(savename_extra=extra)
            savename = md['filename']
            #link_name = '{}/{}{}_{:04d}_maxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
            link_name = '{}/{}{}_{}.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, detname)
            
            if os.path.isfile(link_name):
                i = 1
                while os.path.isfile('{}.{:d}'.format(link_name,i)):
                    i += 1
                os.rename(link_name, '{}.{:d}'.format(link_name,i))
            os.symlink(filename, link_name)
            
            if verbosity>=3:
                print('  Data linked as: {}'.format(link_name))


    def _old_handle_file(self, detector, extra=None, verbosity=3, subdirs=True, linksave=True, **md):
    
        subdir = ''
        
        if detector.name is 'pilatus300' or detector.name is 'pilatus8002':
            # chars = caget('XF:11BMB-ES{Det:SAXS}:TIFF1:FullFileName_RBV')
            # filename = ''.join(chr(char) for char in chars)[:-1]
            filename = detector.tiff.full_file_name.get() #RL, 20210831
            
            # Alternate method to get the last filename
            #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

            if verbosity>=3:
                print('  Data saved to: {}'.format(filename))

            if subdirs:
                subdir = '/maxs/raw/'
                #TODO:
                #subdir = '/maxs/raw/'

            #if md['measure_type'] is not 'snap':
            if True:
                
                # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime'))
                self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831
                
                # Create symlink
                #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
                #savename = md['filename'][:-5]

                #savename = self.get_savename(savename_extra=extra)
                savename = md['filename']
                #link_name = '{}/{}{}_{:04d}_maxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                link_name = '{}/{}{}_maxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename)
                
                if os.path.isfile(link_name):
                    i = 1
                    while os.path.isfile('{}.{:d}'.format(link_name,i)):
                        i += 1
                    os.rename(link_name, '{}.{:d}'.format(link_name,i))
                os.symlink(filename, link_name)
                
                if verbosity>=3:
                    print('  Data linked as: {}'.format(link_name))

        elif detector.name is 'pilatus2M':

            foldername = '/nsls2/xf11bm/'
            
            # chars = caget('XF:11BMB-ES{Det:PIL2M}:TIFF1:FullFileName_RBV')

            # filename = ''.join(chr(char) for char in chars)[:-1]
            #filename = foldername + filename
            filename = detector.tiff.full_file_name.get() #RL, 20210831

            #chars = caget('XF:11BMB-ES{Det:PIL2M}:TIFF1:FullFileName_RBV')
            #filename = ''.join(chr(char) for char in chars)[:-1]
            
            # Alternate method to get the last filename
            #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

            if verbosity>=3:
                print('  Data saved to: {}'.format(filename))

            if subdirs:
                subdir = '/saxs/raw/'
                #TODO:
                #subdir = '/saxs/raw/'
                
            #if md['measure_type'] is not 'snap':
            if True:
                
                # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'))
                self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831
                
                # Create symlink
                #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
                #savename = md['filename'][:-5]
                
                #savename = self.get_savename(savename_extra=extra)
                savename = md['filename']
                link_name = '{}/{}{}_saxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename)
                #link_name = '{}/{}{}_{:04d}_saxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                
                if os.path.isfile(link_name):
                    i = 1
                    while os.path.isfile('{}.{:d}'.format(link_name,i)):
                        i += 1
                    os.rename(link_name, '{}.{:d}'.format(link_name,i))
                os.symlink(filename, link_name)
                
                if verbosity>=3:
                    print('  Data linked as: {}'.format(link_name))
                        
        elif detector.name is 'pilatus800':
            foldername = '/nsls2/xf11bm/'
            
            # chars = caget('XF:11BMB-ES{Det:PIL800K}:TIFF1:FullFileName_RBV')
            # chars = pilatus800.tiff.full_file_name.get() #RL, 20210831

            # filename = ''.join(chr(char) for char in chars)[:-1]
            # filename = foldername + filename
            filename = detector.tiff.full_file_name.get() #RL, 20210831
            # Alternate method to get the last filename
            #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

            if verbosity>=3:
                print('  Data saved to: {}'.format(filename))

            if subdirs:
                subdir = '/waxs/raw/'
                #TODO:
                #subdir = '/waxs/raw/'
            #if md['measure_type'] is not 'snap':
            if True:
                
                # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime'))
                self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831
                
                # Create symlink
                #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
                #savename = md['filename'][:-5]
                
                #savename = self.get_savename(savename_extra=extra)
                savename = md['filename']
                
                link_name = '{}/{}{}_waxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename)
                #link_name = '{}/{}{}_{:04d}_saxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                
                if os.path.isfile(link_name):
                    i = 1
                    while os.path.isfile('{}.{:d}'.format(link_name,i)):
                        i += 1
                    os.rename(link_name, '{}.{:d}'.format(link_name,i))
                os.symlink(filename, link_name)
                
                if verbosity>=3:
                    print('  Data linked as: {}'.format(link_name))


        #elif detector.name is 'PhotonicSciences_CMS':
            
            #self.set_attribute('exposure_time', detector.exposure_time)
            
            #filename = '{:s}/{:s}.tif'.format( detector.file_path, detector.file_name )

            #if subdirs:
                #subdir = '/waxs/'

            ##savename = md['filename'][:-5]
            ##savename = self.get_savename(savename_extra=extra)
            #savename = md['filename']
            ##savename = '{}/{}{}_{:04d}_waxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
            #savename = '{}/{}{}_waxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename)
            
            #shutil.copy(filename, savename)
            #if verbosity>=3:
                #print('  Data saved to: {}'.format(savename))
        
        else:
            if verbosity>=1:
                print("WARNING: Can't do file handling for detector '{}'.".format(detector.name))
                return
                    
    def snap(self, exposure_time=None, extra=None, measure_type='snap', verbosity=3, **md):
        '''Take a quick exposure (without saving data).'''
        
        self.expose(exposure_time=exposure_time, extra=extra, measure_type=measure_type, verbosity=verbosity, handlefile=False, **md)
        # remove_last_Pilatus_series()
        
        
    def _measure(self, exposure_time=None, extra=None, measure_type='measure', verbosity=3, tiling=False, stitchback=False, **md):
        '''Measure data by triggering the area detectors.
        
        Parameters
        ----------
        exposure_time : float
            How long to collect data
        extra : string, optional
            Extra information about this particular measurement (which is typically
            included in the savename/filename).
        tiling : string
            Controls the detector tiling mode.
              None : regular measurement (single detector position)
              'ygaps' : try to cover the vertical gaps in the Pilatus detector
        '''           
        
        if tiling is 'xygaps':
            if cms.detector == [pilatus2M]:
                
                SAXSy_o = SAXSy.user_readback.value
                SAXSx_o = SAXSx.user_readback.value
                
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower_left'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                #extra x movement is needed for pilatus2M. 

                SAXSy.move(SAXSy.user_readback.value + 5.16)
                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper_left'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                #SAXSy.move(SAXSy.user_readback.value + -5.16)
                SAXSx.move(SAXSx.user_readback.value + 5.16)
                extra_current = 'pos4' if extra is None else '{}_pos4'.format(extra)
                md['detector_position'] = 'upper_right'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                
                SAXSy.move(SAXSy.user_readback.value + -5.16)
                extra_current = 'pos3' if extra is None else '{}_pos3'.format(extra)
                md['detector_position'] = 'lower_right'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)

                SAXSx.move(SAXSx.user_readback.value + -5.16)

                if SAXSx.user_readback.value != SAXSx_o:
                    SAXSx.move(SAXSx_o)
                if SAXSy.user_readback.value != SAXSy_o:
                    SAXSy.move(SAXSy_o)
            if cms.detector == [pilatus800]:
                
                WAXSy_o = WAXSy.user_readback.value
                WAXSx_o = WAXSx.user_readback.value
                
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower_left'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                #extra x movement is needed for pilatus2M. 

                WAXSy.move(WAXSy.user_readback.value + 5.16)
                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper_left'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                WAXSx.move(WAXSx.user_readback.value - 5.16)
                extra_current = 'pos4' if extra is None else '{}_pos4'.format(extra)
                md['detector_position'] = 'upper_right'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                
                WAXSy.move(WAXSy.user_readback.value + -5.16)
                extra_current = 'pos3' if extra is None else '{}_pos3'.format(extra)
                md['detector_position'] = 'lower_right'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)

                WAXSx.move(WAXSx.user_readback.value + 5.16)

                if WAXSx.user_readback.value != WAXSx_o:
                    WAXSx.move(WAXSx_o)
                if WAXSy.user_readback.value != WAXSy_o:
                    WAXSy.move(WAXSy_o)

        elif tiling is 'ygaps':
            if cms.detector == [pilatus2M]:
                
                SAXSy_o = SAXSy.user_readback.value
                SAXSx_o = SAXSx.user_readback.value
                
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                #extra x movement is needed for pilatus2M. 

                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                SAXSy.move(SAXSy.user_readback.value + 5.16)
                time.sleep(5)
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
                SAXSy.move(SAXSy.user_readback.value - 5.16)
                time.sleep(5)
                if SAXSx.user_readback.value != SAXSx_o:
                    SAXSx.move(SAXSx_o)
                if SAXSy.user_readback.value != SAXSy_o:
                    SAXSy.move(SAXSy_o)


            if cms.detector == [pilatus300]:

                #MAXSy_o = MAXSy.user_readback.value

                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)


                MAXSy.move(MAXSy.user_readback.value + 5.16)
                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)


                MAXSy.move(MAXSy.user_readback.value + -5.16)

                #if MAXSy.user_readback.value != MAXSy_o:
                    #MAXSy.move(MAXSy_o)

            if cms.detector == [pilatus800]:

                WAXSy_o = WAXSy.user_readback.value

                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)


                WAXSy.move(WAXSy.user_readback.value + 5.16)
                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)


                WAXSy.move(WAXSy.user_readback.value - 5.16)

                #if WAXSy.user_readback.value != WAXSy_o:
                    #WAXSy.move(MAXSy_o)    
        #if tiling is 'big':
            # TODO: Use multiple images to fill the entire detector motion range
        
        else:
            # Just do a normal measurement
            self.measure_single(exposure_time=exposure_time, extra=extra, measure_type=measure_type, verbosity=verbosity, **md)
        

    def measure(self, exposure_time=None, extra=None, measure_type='measure', verbosity=3, tiling=None, stitchback=False, **md):
        '''Measure data by triggering the area detectors.
        
        Parameters
        ----------
        exposure_time : float
            How long to collect data
        extra : string, optional
            Extra information about this particular measurement (which is typically
            included in the savename/filename).
        tiling : string
            Controls the detector tiling mode.
              None : regular measurement (single detector position)
              'ygaps' : try to cover the vertical gaps in the Pilatus detector
        '''           
        
        if tiling is 'xygaps':
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value
            #MAXSy_o = MAXSy.user_readback.value

            extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
            md['detector_position'] = 'lower_left'
            self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
            #pos2
            if [pilatus2M] in cms.detector:
                SAXSy.move(SAXSy_o + 5.16)
            if [pilatus800] in cms.detector:
                WAXSy.move(WAXSy_o + 5.16)
            #if [pilatus300] in cms.detector:
                #MAXSy.move(MAXSy_o + 5.16)

            extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
            md['detector_position'] = 'upper_left'
            self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            #pos4
            if pilatus2M in cms.detector:
                SAXSx.move(SAXSx_o + 5.16)
                SAXSy.move(SAXSy.o + 5.16)
            if pilatus800 in cms.detector:
                WAXSx.move(WAXSx_o - 5.16)
                WAXSy.move(WAXSy_o + 5.16)
            extra_current = 'pos4' if extra is None else '{}_pos4'.format(extra)
            md['detector_position'] = 'upper_right'
            self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            #pos3
            if pilatus2M in cms.detector:
                SAXSx.move(SAXSx_o + 5.16)
                SAXSy.move(SAXSy_o)
            if pilatus800 in cms.detector:
                WAXSx.move(WAXSx_o - 5.16)
                WAXSy.move(WAXSy_o)

            extra_current = 'pos3' if extra is None else '{}_pos3'.format(extra)
            md['detector_position'] = 'lower_right'
            self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)


            if WAXSx.user_readback.value != WAXSx_o:
                WAXSx.move(WAXSx_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)
            
            if SAXSx.user_readback.value != SAXSx_o:
                SAXSx.move(SAXSx_o)
            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)       

        elif tiling is 'ygaps':
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value
            ##MAXSy_o = MAXSy.user_readback.value

            extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
            md['detector_position'] = 'lower'
            self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)


            if pilatus2M in cms.detector:
                SAXSy.move(SAXSy_o + 5.16)
            if pilatus800 in cms.detector:
                WAXSy.move(WAXSy_o + 5.16)
            #if pilatus300 in cms.detector:
                #MAXSy.move(MAXSy_o + 5.16)
                
                
            #extra x movement is needed for pilatus2M. 
            extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
            md['detector_position'] = 'upper'
            self.measure_single(exposure_time=exposure_time, extra=extra_current, measure_type=measure_type, verbosity=verbosity, stitchback=True,**md)
                
            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)    
            #if MAXSy.user_readback.value != MAXSy_o:
                #MAXSy.move(MAXSy_o)  



        
        else:
            # Just do a normal measurement
            self.measure_single(exposure_time=exposure_time, extra=extra, measure_type=measure_type, verbosity=verbosity, **md)
        

    def measureRock(self, incident_angle=None, exposure_time=None, extra=None, measure_type='measure', rock_motor=None, rock_motor_limits=0.1, verbosity=3, stitchback=False, poling_period=0.2, **md):
        '''Measure data when swing the rock_motor.
        
        Parameters
        ----------
        exposure_time : float
            How long to collect data
        extra : string, optional
            Extra information about this particular measurement (which is typically
            included in the savename/filename).
        rock_motor: string, optional
            Motor to swing in measurement
        rock_motor_limits: float
            The offset in the swing range
        '''           
        if incident_angle != None:
            self.thabs(incident_angle)
            
        if exposure_time is not None:
            self.set_attribute('exposure_time', exposure_time)
        #else:
            #exposure_time = self.get_attribute('exposure_time')
            
        savename = self.get_savename(savename_extra=extra)
        
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:FileName', savename)
        
        if verbosity>=2 and (get_beamline().current_mode != 'measurement'):
            print("WARNING: Beamline is not in measurement mode (mode is '{}')".format(get_beamline().current_mode))

        if verbosity>=1 and len(get_beamline().detector)<1:
            print("ERROR: No detectors defined in cms.detector")
            return
        
        md_current = self.get_md()
        md_current.update(self.get_measurement_md())
        md_current['sample_savename'] = savename
        md_current['measure_type'] = measure_type
        #md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, md_current['detector_sequence_ID'])
        md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, RE.md['scan_id'])
        md_current['beam_int_bim3'] = beam.bim3.flux(verbosity=0)
        md_current['beam_int_bim4'] = beam.bim4.flux(verbosity=0)
        md_current['beam_int_bim5'] = beam.bim5.flux(verbosity=0)        
        #md_current['plan_header_override'] = md['measure_type']
        md_current.update(md)

       
        if 'measure_type' not in md:
            md['measure_type'] = 'expose'
        #self.log('{} for {}.'.format(md['measure_type'], self.name), **md)


        # Set exposure time
        if exposure_time is not None:
            #for detector in gs.DETS:
            for detector in get_beamline().detector:
                if exposure_time != detector.cam.acquire_time.get():  #caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'):
                    RE(detector.setExposureTime(exposure_time, verbosity=verbosity))
                #if detector.name is 'pilatus300' and exposure_time != detector.cam.acquire_time.get():
                    #detector.setExposureTime(exposure_time, verbosity=verbosity)
                    ##extra wait time when changing the exposure time.  
                    ##time.sleep(2)
                    #############################################
                    ##extra wait time for adjusting pilatus2M 
                    ##this extra wait time has to be added. Otherwise, the exposure will be skipped when the exposure time is increased
                    ##Note by 091918
                    #############################################
                    #time.sleep(2)
                #elif detector.name is 'PhotonicSciences_CMS':
                    #detector.setExposureTime(exposure_time, verbosity=verbosity)
       


        # Do acquisition
        get_beamline().beam.on()
        
        start_time = time.time()
        # Define the rock 
        #rock_scan=list_scan(get_beamline().detector, armr, [0], per_step = functools.partial(rock_motor_per_step, rock_motor=rock_motor, rock_motor_limits=rock_motor_limits) )
        rock_scan=list_scan(get_beamline().detector, armr, [0], per_step = lambda detectors, motor, step: rock_motor_per_step(detectors, motor, step, rock_motor=rock_motor, rock_motor_limits=rock_motor_limits) )
        #uids = RE(count(get_beamline().detector, 1), **md)
        uids = RE(rock_scan, **md_current)
        
        

        # Wait for detectors to be ready
        max_exposure_time = 0
        for detector in get_beamline().detector:
            if detector.name is 'pilatus300' or 'pilatus800' or 'pilatus2M':
               max_exposure_time = detector.cam.acquire_time.get()

            # if detector.name is 'pilatus300':
            #     current_exposure_time = caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime')
            #     max_exposure_time = max(max_exposure_time, current_exposure_time)
            # elif detector.name is 'pilatus2M':
            #     current_exposure_time = caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime')
            #     max_exposure_time = max(max_exposure_time, current_exposure_time)
            # elif detector.name is 'pilatus800':
            #     current_exposure_time = caget('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime')
            #     max_exposure_time = max(max_exposure_time, current_exposure_time)
            #elif detector.name is 'PhotonicSciences_CMS':
                #current_exposure_time = detector.exposure_time
                #max_exposure_time = max(max_exposure_time, current_exposure_time)
            else:
                if verbosity>=1:
                    print("WARNING: Didn't recognize detector '{}'.".format(detector.name))
            
        if verbosity>=2:
            status = 0
            while (status==0) and (time.time()-start_time)<(max_exposure_time+20):
                percentage = 100*(time.time()-start_time)/max_exposure_time
                print( 'Exposing {:6.2f} s  ({:3.0f}%)      \r'.format((time.time()-start_time), percentage), end='')
                time.sleep(poling_period)
                
                status = 1
                for detector in get_beamline().detector:
                    if detector.cam.acquire.get():
                        status *= 0 

                    # if detector.name is 'pilatus300':
                    #     if caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
                    #         status *= 0
                    # elif detector.name is 'pilatus2M':
                    #     if caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
                    #         status *= 0
                    # elif detector.name is 'pilatus800':
                    #     if caget('XF:11BMB-ES{Det:PIL800K}:cam1:Acquire')==1:
                    #         status *= 0
                    # elif detector.name is 'PhotonicSciences_CMS':
                    #     if not detector.detector_is_ready(verbosity=0):
                    #         status *= 0
            print('')
                    
                
        else:
            time.sleep(max_exposure_time)
        
        # if verbosity>=3 and caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
        #     print('Warning: Detector pilatus300 still not done acquiring.')
        # if verbosity>=3 and caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
        #     print('Warning: Detector pilatus2M still not done acquiring.')
        # if verbosity>=3 and caget('XF:11BMB-ES{Det:PIL800K}:cam1:Acquire')==1:
        #     print('Warning: Detector pilatus800 still not done acquiring.')
 
        
        get_beamline().beam.off()
        
        for detector in get_beamline().detector:
            self.handle_file(detector, extra=extra, verbosity=verbosity, **md_current)
            #self.handle_file(detector, extra=extra, verbosity=verbosity)
        self.md['measurement_ID'] += 1
                
    def measure_single(self, exposure_time=None, extra=None, measure_type='measure', verbosity=3, **md):
        '''Measure data by triggering the area detectors.
        
        Parameters
        ----------
        exposure_time : float
            How long to collect data
        extra : string, optional
            Extra information about this particular measurement (which is typically
            included in the savename/filename).
        '''           
        
        if exposure_time is not None:
            self.set_attribute('exposure_time', exposure_time)
        #else:
            #exposure_time = self.get_attribute('exposure_time')
            
        savename = self.get_savename(savename_extra=extra)
        
        
        if verbosity>=2 and (get_beamline().current_mode != 'measurement'):
            print("WARNING: Beamline is not in measurement mode (mode is '{}')".format(get_beamline().current_mode))

        if verbosity>=1 and len(get_beamline().detector)<1:
            print("ERROR: No detectors defined in cms.detector")
            return
        
        md_current = self.get_md()
        md_current.update(self.get_measurement_md())
        md_current['sample_savename'] = savename
        md_current['measure_type'] = measure_type
        #md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, md_current['detector_sequence_ID'])
        #md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, RE.md['scan_id'])
        md_current['filename'] = '{:s}_{:06d}'.format(savename, RE.md['scan_id'])
        md_current.update(md)

       
        self.expose(exposure_time, extra=extra, verbosity=verbosity, **md_current)
        #self.expose(exposure_time, extra=extra, verbosity=verbosity, **md)
        
        self.md['measurement_ID'] += 1
        
        
    def _test_time(self):
        print(time.time())
        time.time()
        
    
    def _test_measure_single(self, exposure_time=None, extra=None, shutteronoff=True, measure_type='measure', verbosity=3, **md):
        '''Measure data by triggering the area detectors.
        
        Parameters
        ----------
        exposure_time : float
            How long to collect data
        extra : string, optional
            Extra information about this particular measurement (which is typically
            included in the savename/filename).
        '''           
        
        #print('1') #0s
        #print(time.time())
        
        if exposure_time is not None:
            self.set_attribute('exposure_time', exposure_time)
        #else:
            #exposure_time = self.get_attribute('exposure_time')
            
        savename = self.get_savename(savename_extra=extra)
        
        #caput('XF:11BMB-ES{Det:SAXS}:cam1:FileName', savename)
        
        if verbosity>=2 and (get_beamline().current_mode != 'measurement'):
            print("WARNING: Beamline is not in measurement mode (mode is '{}')".format(get_beamline().current_mode))

        if verbosity>=1 and len(get_beamline().detector)<1:
            print("ERROR: No detectors defined in cms.detector")
            return
        
        #print('2') #0.0004s
        #print(time.time())       

        md_current = self.get_md()
        md_current['sample_savename'] = savename
        md_current['measure_type'] = measure_type
        
        md_current.update(self.get_measurement_md())
        #md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, md_current['detector_sequence_ID'])
        md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, RE.md['scan_id'])
        md_current.update(md)
        
        #print('3') #0.032s
        #print(time.time())
        
        self._test_expose(exposure_time, shutteronoff=shutteronoff, extra=extra, verbosity=verbosity, **md_current)

        #print('4') #5.04s
        #print(time.time())
        
        self.md['measurement_ID'] += 1
        
        #print('5') #5.0401
        #print(time.time())
        
    def _test_expose(self, exposure_time=None, extra=None, verbosity=3, poling_period=0.1, shutteronoff=True, **md):
        '''Internal function that is called to actually trigger a measurement.'''
        
        if 'measure_type' not in md:
            md['measure_type'] = 'expose'
        #self.log('{} for {}.'.format(md['measure_type'], self.name), **md)


        # Set exposure time
        if exposure_time is not None:
            for detector in get_beamline().detector:
                detector.setExposureTime(exposure_time, verbosity=verbosity)
        
        #print('1') #5e-5
        #print(self.clock())
        
        # Do acquisition
        # check shutteronoff, if 
        if shutteronoff == True: 
            get_beamline().beam.on()
        else:
            print('shutter is disabled')

        #print('2') #3.0
        #print(self.clock())
        
        md['plan_header_override'] = md['measure_type']
        start_time = time.time()
        print('2') #3.0
        print(self.clock())
        
        #uids = RE(count(get_beamline().detector, 1), **md)
        #uids = RE(count(get_beamline().detector), **md)
        yield from (count(get_beamline().detector))
        print('3') #4.3172
        print(self.clock())
        
        #get_beamline().beam.off()
        #print('shutter is off')

        # Wait for detectors to be ready
        max_exposure_time = 0
        for detector in get_beamline().detector:
            if detector.name is 'pilatus300' or 'pilatus2M':
                current_exposure_time = caget('XF:11BMB-ES{}:cam1:AcquireTime'.format(pilatus_Epicsname))
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            elif detector.name is 'PhotonicSciences_CMS':
                current_exposure_time = detector.exposure_time
                max_exposure_time = max(max_exposure_time, current_exposure_time)
            else:
                if verbosity>=1:
                    print("WARNING: Didn't recognize detector '{}'.".format(detector.name))
        
        print('4') #4.3193
        print(self.clock())

        if verbosity>=2:
            status = 0
            print('status1 = ', status)

            while (status==0) and (time.time()-start_time)<(max_exposure_time+20):
                percentage = 100*(time.time()-start_time)/max_exposure_time
                print( 'Exposing {:6.2f} s  ({:3.0f}%)      \r'.format((time.time()-start_time), percentage), end='')
                print('status2 = ', status)
                
                time.sleep(poling_period)
                
                status = 1
                for detector in get_beamline().detector:
                    if detector.name is 'pilatus300' or 'pilatus2M':
                        print('status2.5 = ', status)
                        if caget('XF:11BMB-ES{}:cam1:Acquire'.format(pilatus_Epicsname))==1:
                            status = 0
                            print('status3 = ', status)
                        print('status3.5 = ', status)

                    elif detector.name is 'PhotonicSciences_CMS':
                        if not detector.detector_is_ready(verbosity=0):
                            status = 0
                print('5') #3.0
                print(self.clock())
            print('6') #3.0
            print(self.clock())
                 
                
        else:
            time.sleep(max_exposure_time)
        
        #print('5') #4.4193
        #print(self.clock())

        if verbosity>=3 and caget('XF:11BMB-ES{}:cam1:Acquire'.format(pilatus_Epicsname))==1:
            print('Warning: Detector still not done acquiring.')
        
        if shutteronoff == True: 
            get_beamline().beam.off()
        else:
            print('shutter is disabled')

        #print('6') #4.9564
        #print(self.clock())
        
        for detector in get_beamline().detector:
            self.handle_file(detector, extra=extra, verbosity=verbosity, **md)
            
        #print('7') #4.9589
        #print(self.clock())

    def _test_measureSpots(self, num_spots=4, translation_amount=0.2, axis='y', exposure_time=None, extra=None, shutteronoff=True, measure_type='measureSpots', tiling=False, **md):
        '''Measure multiple spots on the sample.'''
        
        if 'spot_number' not in self.md:
            self.md['spot_number'] = 1
        
        start_time = time.time()
        
        for spot_num in range(num_spots):
        
            self._test_measure_single(exposure_time=exposure_time, extra=extra, measure_type=measure_type, shutteronoff=shutteronoff, tiling=tiling, **md)
            
            print(spot_num+1)
            print(time.time()-start_time)
            getattr(self, axis+'r')(translation_amount)
            self.md['spot_number'] += 1
            print('{:d} of {:d} is done'.format(spot_num+1,num_spots))
            print(time.time()-start_time)
        
    def measureSpots(self, num_spots=4, translation_amount=0.2, axis='y', exposure_time=None, extra=None, measure_type='measureSpots', tiling=False, **md):
        '''Measure multiple spots on the sample.'''
        
        if 'spot_number' not in self.md:
            self.md['spot_number'] = 1
        
        
        for spot_num in range(num_spots):
        
            self.measure(exposure_time=exposure_time, extra=extra, measure_type=measure_type, tiling=tiling, **md)
            
            getattr(self, axis+'r')(translation_amount)
            self.md['spot_number'] += 1
            print('{:d} of {:d} is done'.format(spot_num+1,num_spots))
        
        
    def measureTimeSeries(self, exposure_time=None, num_frames=10, wait_time=None, extra=None, measure_type='measureTimeSeries', verbosity=3, tiling=False, fix_name=True, **md):

        if fix_name and ('clock' not in self.naming_scheme):
            self.naming_scheme_hold = self.naming_scheme
            self.naming_scheme = self.naming_scheme_hold.copy()
            self.naming_scheme.insert(-1, 'clock')

        
        md['measure_series_num_frames'] = num_frames
        
        for i in range(num_frames):
            
            if verbosity>=3:
                print('Measuring frame {:d}/{:d} ({:.1f}% complete).'.format(i+1, num_frames, 100.0*i/num_frames))
                
            md['measure_series_current_frame'] = i+1
            self.measure(exposure_time=exposure_time, extra=extra, measure_type=measure_type, verbosity=verbosity, tiling=tiling, **md)
            if wait_time is not None:
                time.sleep(wait_time)
    
    #def measureTimeSeriesAngles(self, exposure_time=None, num_frames=10, wait_time=None, extra=None, measure_type='measureTimeSeries', verbosity=3, tiling=False, fix_name=True, **md):

        #if fix_name and ('clock' not in self.naming_scheme):
            #self.naming_scheme_hold = self.naming_scheme
            #self.naming_scheme = self.naming_scheme_hold.copy()
            #self.naming_scheme.insert(-1, 'clock')

        
        #md['measure_series_num_frames'] = num_frames
        
        #for i in range(num_frames):
            
            #if verbosity>=3:
                #print('Measuring frame {:d}/{:d} ({:.1f}% complete).'.format(i+1, num_frames, 100.0*i/num_frames))
                
            #md['measure_series_current_frame'] = i+1
            #print('Angles in measure include: {}'.format(sam.incident_angles_default))
            #self.measureIncidentAngles(exposure_time=exposure_time, extra=extra, **md)
            #if wait_time is not None:
                #time.sleep(wait_time)
            ##if (i % 2 ==0):
            ##    self.xr(-1)
            ##else:
            ##    self.xr(1)
            ##self.pos()

    def measureTimeSeriesAngles(self, exposure_time=None, num_frames=10, wait_time=None, extra=None, measure_type='measureTimeSeries', verbosity=3, tiling=False, fix_name=True, **md):

        if fix_name and ('clock' not in self.naming_scheme):
            self.naming_scheme_hold = self.naming_scheme
            self.naming_scheme = self.naming_scheme_hold.copy()
            self.naming_scheme.insert(-1, 'clock')

        
        md['measure_series_num_frames'] = num_frames
        
        for i in range(num_frames):
            
            if verbosity>=3:
                print('Measuring frame {:d}/{:d} ({:.1f}% complete).'.format(i+1, num_frames, 100.0*i/num_frames))
                
            md['measure_series_current_frame'] = i+1
            print('Angles in measure include: {}'.format(sam.incident_angles_default))
            self.measureIncidentAngles(exposure_time=exposure_time, extra=extra, **md)
            if wait_time is not None:
                time.sleep(wait_time)
        
        
    def measureTemperature(self, temperature, exposure_time=None, wait_time=None, temperature_probe='A', temperature_tolerance=0.4, extra=None, measure_type='measureTemperature', verbosity=3, tiling=False, poling_period=1.0, fix_name=True, **md):

        # Set new temperature
        self.setTemperature(temperature, temperature_probe=temperature_probe, verbosity=verbosity)
        
        # Wait until we reach the temperature
        while abs(self.temperature(temperature_probe=temperature_probe, verbosity=0) - temperature)>temperature_tolerance:
            if verbosity>=3:
                print('  setpoint = {:.3f}°C, Temperature = {:.3f}°C          \r'.format(self.temperature_setpoint(temperature_probe=temperature_probe)-273.15, self.temperature(verbosity=0)), end='')
            time.sleep(poling_period)
            
        # Allow for additional equilibration at this temperature
        if wait_time is not None:
            time.sleep(wait_time)
            
        # Measure
        #if fix_name and ('temperature' not in self.naming_scheme):
        #    self.naming_scheme_hold = self.naming_scheme
        #    self.naming_scheme = self.naming_scheme_hold.copy()
        #    self.naming_scheme.insert(-1, 'temperature')
            
            
        self.measure(exposure_time=exposure_time, extra=extra, measure_type=measure_type, verbosity=verbosity, tiling=tiling, **md)
        
        #self.naming_scheme = self.naming_scheme_hold


    def measureTemperatures(self, temperatures, exposure_time=None, wait_time=None, temperature_probe='A', temperature_tolerance=0.4, extra=None, measure_type='measureTemperature', verbosity=3, tiling=False, poling_period=1.0, fix_name=True, **md):
        
        for temperature in temperatures:
            self.measureTemperature(temperature, exposure_time=exposure_time, wait_time=wait_time, temperature_probe=temperature_probe, temperature_tolerance=temperature_tolerance, measure_type=measure_type, verbosity=verbosity, tiling=tiling, poling_period=poling_period, fix_name=fix_name, **md)
        

    def do(self, step=0, verbosity=3, **md):
        '''Performs the "default action" for this sample. This usually means 
        aligning the sample, and taking data.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''
        
        if verbosity>=4:
            print('  doing sample {}'.format(self.name))
        
        if step<=1:
            if verbosity>=5:
                print('    step 1: goto origin')
            self.xo() # goto origin
            self.yo()
            #self.gotoAlignedPosition()
            
        #if step<=5:
            #self.align()
            
        if step<=10:
            if verbosity>=5:
                print('    step 10: measuring')
            self.measure(**md)
                

    def scan_measure(self, motor, start, stop, num_frames, exposure_time=None, detectors=None, extra=None, per_step=None, wait_time=None, measure_type='Scan_measure', verbosity=3, fill_gaps=False, **md):
        """
        Scans the specified motor and record the detectors with shutter open during the scan.
        
        Parameters
        ----------
        motor : motor
            The axis/stage/motor that you want to move.
        start, stop : float
            The relative positions of the scan range.
        num_frames : int
            The number of scan points. 
        exposure_time: float
            The exposure time for single point
        md : dict, optional
            metadata        
        """
        #span = abs(stop-start)
        #positions, dp = np.linspace(start, stop, num, endpoint=True, retstep=True)

        if detectors is None:
            detectors = cms.detector
   
        if exposure_time is not None:
            self.set_attribute('exposure_time', exposure_time)

        bec.disable_plots()
        bec.disable_table()
        
        savename = self.get_savename(savename_extra=extra)
        if verbosity>=2 and (get_beamline().current_mode != 'measurement'):
            print("WARNING: Beamline is not in measurement mode (mode is '{}')".format(get_beamline().current_mode))
        if verbosity>=1 and len(cms.detector)<1:
            print("ERROR: No detectors defined in cms.detector")
            return
        
        #set exposure time
        for detector in get_beamline().detector:
            detector.setExposureTime(exposure_time, verbosity=verbosity)
        #set metadata
        md_current = self.get_md()
        md_current['sample_savename'] = savename
        md_current['measure_type'] = measure_type
        md_current['scan'] = 'scan_measure'
        md_current.update(self.get_measurement_md())
        md_current['measure_series_num_frames'] = num_frames
        md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, RE.md['scan_id'])
        md_current['measure_series_motor'] = motor.name
        md_current['measure_series_positions'] = [start, stop]
        md_current['exposure_time'] = exposure_time
        md_current.update(md)
        
        print(RE.md['scan_id'])
        
        # Perform the scan
        #get_beamline().beam._test_on(wait_time=0.1)
        get_beamline().beam.on()
        #RE(relative_scan(gs.DETS, motor, start, stop, num_frames+1, per_step=per_step, md=md_current))
        RE(relative_scan(cms.detector, motor, start, stop, num_frames+1, per_step=per_step,md=md_current), LiveTable([motor, 'motor_setpoint']))
     
        # if verbosity>=3 and caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
        stage = 1
        for detector in cms.detector:
            if detector.cam.acquire.get() == 1:
            # if verbosity>=3 and caget('XF:11BMB-ES{Det:SAXS}:cam1:Acquire')==1:
            
                print('Warning: Detector {} still not done acquiring.'.format(detector.name))
        # elif verbosity>=3 and caget('XF:11BMB-ES{Det:PIL2M}:cam1:Acquire')==1:
        #     print('Warning: Detector Pilatus2M still not done acquiring.')
        #get_beamline().beam._test_off(wait_time=0.1)
        get_beamline().beam.off()
        self.md['measurement_ID'] += 1
   
        #data collected, link uid to file name
        for detector in cms.detector:
            #print(detector.name)
            self.handle_fileseries(detector, num_frames=num_frames, extra=extra, verbosity=verbosity, **md)

    def series_measure(self, num_frames, exposure_time=None, exposure_period=None, detectors=None, extra=None, per_step=None, wait_time=None, measure_type='Series_measure', verbosity=3, fill_gaps=False, **md):
        
        """
        Continueous shots with internal trigger of detectors. (burst mode)
        
        Parameters
        ----------
        num_frames : int
            The number of data points. 
        exposure_time: float
            The exposure time for single point
        exposure_period: float
            The exposure period for single point. should be at least 0.05s longer than exposure_time
        md : dict, optional
            metadata        
        """
        #span = abs(stop-start)
        #positions, dp = np.linspace(start, stop, num, endpoint=True, retstep=True)

        if detectors is None:
            detectors = cms.detector
   
        if exposure_time is not None:
            self.set_attribute('exposure_time', exposure_time)
            
        # Set exposure time
        for detector in get_beamline().detector:
            if exposure_time != detector.cam.acquire_time.get():
                RE(detector.setExposureTime(exposure_time))
                # detector.cam.acquire_time.put(exposure_time)
            # detector.cam.acquire_period.put(exposure_period)
            # detector.cam.num_images.put(num_frames)
            RE(detector.setExposurePeriod(exposure_period))
            RE(detector.setExposureNumber(num_frames))

            # if detector.name is 'pilatus2M':

            #     if exposure_time != caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'):
            #         caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime', exposure_time)
            #     caput('XF:11BMB-ES{Det:PIL2M}:cam1:AcquirePeriod', exposure_period)
            #     caput('XF:11BMB-ES{Det:PIL2M}:cam1:NumImages', num_frames)
                
            # if detector.name is 'pilatus800':
            #     if exposure_time != caget('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime'):
            #         caput('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime', exposure_time)
            #     caput('XF:11BMB-ES{Det:PIL800K}:cam1:AcquirePeriod', exposure_period)
            #     caput('XF:11BMB-ES{Det:PIL800K}:cam1:NumImages', num_frames)

            # if detector.name is 'pilatus300' :
            #     if exposure_time != caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime'):
            #         caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', exposure_time)
            #     caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', exposure_period)
            #     caput('XF:11BMB-ES{Det:SAXS}:cam1:NumImages', num_frames)
                #extra wait time when changing the exposure time.  
                #time.sleep(2)
            #elif detector.name is 'PhotonicSciences_CMS':
                #detector.setExposureTime(exposure_time, verbosity=verbosity)
        
        #for detector in get_beamline().detector:
            #detector.cam.acquire_time.value=exposure_time
            #detector.cam.acquire_period.value=exposure_period
            #detector.cam.num_images.value=num_frames

        #bec.disable_plots()
        #bec.disable_table()
        
        savename = self.get_savename(savename_extra=extra)
        if verbosity>=2 and (get_beamline().current_mode != 'measurement'):
            print("WARNING: Beamline is not in measurement mode (mode is '{}')".format(get_beamline().current_mode))

        if verbosity>=1 and len(get_beamline().detector)<1:
            print("ERROR: No detectors defined in cms.detector")
            return
        
        md_current = self.get_md()
        md_current['sample_savename'] = savename
        md_current['measure_type'] = measure_type
        md_current['series'] = 'series_measure'
        md_current.update(self.get_measurement_md())
        #md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, md_current['detector_sequence_ID'])
        md_current['measure_series_num_frames'] = num_frames
        md_current['filename'] = '{:s}_{:04d}.tiff'.format(savename, RE.md['scan_id'])
        md_current['exposure_time'] = exposure_time
        #md_current['measure_series_motor'] = motor.name
        #md_current['measure_series_positions'] = [start, stop]

        #md_current['fileno'] = '{:s}_{:04d}.tiff'.format(savename, RE.md['scan_id'])
        md_current.update(md)
        
        print(RE.md['scan_id'])
        
        # Perform the scan
        #get_beamline().beam._test_on(wait_time=0.1)
        get_beamline().beam.on()
        RE(count(get_beamline().detector, md=md_current))
        get_beamline().beam.off()

        self.md['measurement_ID'] += 1
        #reset the num_frame back to 1
        for detector in get_beamline().detector:
            RE(detector.setExposureNumber(1))

        #data collected, link uid to file name
        for detector in cms.detector:
            print('handling the file names')
            self.handle_fileseries(detector, num_frames=num_frames, extra=extra, verbosity=verbosity, **md)


            # if detector.name is 'pilatus2M':
            #     caput('XF:11BMB-ES{Det:PIL2M}:cam1:NumImages', 1)                
            # if detector.name is 'pilatus300' :
            #     caput('XF:11BMB-ES{Det:SAXS}:cam1:NumImages', 1)
            # if detector.name is 'pilatus800' :
            #     caput('XF:11BMB-ES{Det:PIL800K}:cam1:NumImages', 1)
        
    def initialDetector(self):
                #reset the num_frame back to 1
        for detector in get_beamline().detector:
            detector.cam.num_images.put(1)
            # if detector.name is 'pilatus2M':
            #     caput('XF:11BMB-ES{Det:PIL2M}:cam1:NumImages', 1)                
            # if detector.name is 'pilatus300' :
            #     caput('XF:11BMB-ES{Det:SAXS}:cam1:NumImages', 1)
            # if detector.name is 'pilatus800' :
            #     caput('XF:11BMB-ES{Det:PIL800K}:cam1:NumImages', 1)

    def _old_handle_fileseries(self, detector, num_frames=None, extra=None, verbosity=3, subdirs=True, **md):
    
        subdir = ''
        
        if detector.name == 'pilatus300' or  detector.name == 'pilatus8002' :
            # chars = caget('XF:11BMB-ES{Det:SAXS}:TIFF1:FullFileName_RBV')
            # filename = ''.join(chr(char) for char in chars)[:-1]
            # filename_part1 = ''.join(chr(char) for char in chars)[:-13]

            filename = detector.tiff.full_file_name.get() #RL, 20210831

            print('pilatus300k data handling')
            # Alternate method to get the last filename
            #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

            #if verbosity>=3:
            #    print('  Data saved to: {}'.format(filename))

            if subdirs:
                subdir = '/maxs/raw/'

            #if md['measure_type'] is not 'snap':
            if True:
                
                # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime'))
                self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831                
                # Create symlink
                #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
                #savename = md['filename'][:-5]
                
                savename = self.get_savename(savename_extra=extra)
                link_name = '{}/{}{}_{:04d}_maxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                link_name_part1 = '{}/{}{}_{:04d}'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                
                if os.path.isfile(link_name):
                    i = 1
                    while os.path.isfile('{}.{:d}'.format(link_name,i)):
                        i += 1
                    os.rename(link_name, '{}.{:d}'.format(link_name,i))
                
                for num_frame in range(num_frames):
                    filename_new = '{}_{:06d}.tiff'.format(filename_part1, num_frame)
                    link_name_new= '{}_{:06d}_maxs.tiff'.format(link_name_part1, num_frame)
                    os.symlink(filename_new, link_name_new)                
                    if verbosity>=3:
                        if num_frame == 0 or num_frame == np.max(num_frames):
                            print('  Data {} linked as: {}'.format(filename_new, link_name_new))

        elif detector.name ==  'pilatus2M':
            # chars = caget('XF:11BMB-ES{Det:PIL2M}:TIFF1:FullFileName_RBV')
            # filename = ''.join(chr(char) for char in chars)[:-1]
            # filename_part1 = ''.join(chr(char) for char in chars)[:-13]


            filename = detector.tiff.full_file_name.get() #RL, 20210831
            filename_part1 = detector.tiff.file_path.get() + detector.tiff.file_name.get() 

            print('pilatus2M data handling')
            
            # Alternate method to get the last filename
            #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )
            #filename_part1 = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

            #if verbosity>=3:
            #    print('  Data saved to: {}'.format(filename))

            if subdirs:
                subdir = '/saxs/raw/'

            #if md['measure_type'] is not 'snap':
            if True:
                
                # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:PIL2M}:cam1:AcquireTime'))
                self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831
                
                # Create symlink
                #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
                #savename = md['filename'][:-5]
                
                savename = self.get_savename(savename_extra=extra)
                link_name = '{}/{}{}_{:04d}_saxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                link_name_part1 = '{}/{}{}_{:04d}'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                
                if os.path.isfile(link_name):
                    i = 1
                    while os.path.isfile('{}.{:d}'.format(link_name,i)):
                        i += 1
                    os.rename(link_name, '{}.{:d}'.format(link_name,i))
                
                for num_frame in range(num_frames):
                    filename_new = '{}_{:06d}.tiff'.format(filename_part1, num_frame)
                    link_name_new= '{}_{:06d}_saxs.tiff'.format(link_name_part1, num_frame)
                    os.symlink(filename_new, link_name_new)                
                    if verbosity>=3:
                        if num_frame == 0 or num_frame == np.max(num_frames):
                            print('  Data {} linked as: {}'.format(filename_new, link_name_new))

        #elif detector.name is  'pilatus800':
            #chars = caget('XF:11BMB-ES{Det:PIL800K}:TIFF1:FullFileName_RBV')
            #filename = ''.join(chr(char) for char in chars)[:-1]
            #filename_part1 = ''.join(chr(char) for char in chars)[:-13]

        elif detector.name == 'pilatus800':
            foldername = '/nsls2/xf11bm/'
            
            # chars = caget('XF:11BMB-ES{Det:PIL800K}:TIFF1:FullFileName_RBV')
            # filename = ''.join(chr(char) for char in chars)[:-1]
            # filename = foldername + filename
            # filename_part1 = foldername + ''.join(chr(char) for char in chars)[:-13]

            filename = pilatus800.tiff.full_file_name.get() #RL, 20210831
            filename_part1 = pilatus800.tiff.file_path.get() + pilatus800.tiff.file_name.get() 

            print('pilatus800 data handling')
            
            # Alternate method to get the last filename
            #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

            #if verbosity>=3:
            #    print('  Data saved to: {}'.format(filename))

            if subdirs:
                subdir = '/waxs/raw/'

            #if md['measure_type'] is not 'snap':
            if True:
                
                # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:PIL800K}:cam1:AcquireTime'))
                self.set_attribute('exposure_time', pilatus800.cam.acquire_time.get()) #RL, 20210831
                
                # Create symlink
                #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
                #savename = md['filename'][:-5]
                
                savename = self.get_savename(savename_extra=extra)
                link_name = '{}/{}{}_{:04d}_waxs.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                link_name_part1 = '{}/{}{}_{:04d}'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
                
                if os.path.isfile(link_name):
                    i = 1
                    while os.path.isfile('{}.{:d}'.format(link_name,i)):
                        i += 1
                    os.rename(link_name, '{}.{:d}'.format(link_name,i))
                
                for num_frame in range(num_frames):
                    filename_new = '{}_{:06d}.tiff'.format(filename_part1, num_frame)
                    link_name_new= '{}_{:06d}_waxs.tiff'.format(link_name_part1, num_frame)
                    os.symlink(filename_new, link_name_new)                
                    if verbosity>=3:
                        if num_frame == 0 or num_frame == np.max(num_frames):
                            print('  Data {} linked as: {}'.format(filename_new, link_name_new))
           
           
        else:
            if verbosity>=1:
                print("WARNING: Can't do file handling for detector '{}'.".format(detector.name))
                return

    def handle_fileseries(self, detector, num_frames=None, extra=None, verbosity=3, subdirs=True, **md):
    
        subdir = ''
        if subdirs:
            if detector.name == 'pilatus300' or  detector.name == 'pilatus8002' :
                subdir = '/maxs/raw/'
                detname = 'maxs'
                print('pilatus300k data handling')
            elif detector.name ==  'pilatus2M':
                subdir = '/saxs/raw/'
                detname = 'saxs'
                print('pilatus2M data handling')
            elif detector.name ==  'pilatus800':
                subdir = '/waxs/raw/'
                detname = 'waxs'
                print('pilatus800k data handling')
            else:
                if verbosity>=1:
                    print("WARNING: Can't do file handling for detector '{}'.".format(detector.name))
                    return           
        
        filename = detector.tiff.full_file_name.get() #RL, 20210831
        filename_part1 = '{:s}/{:s}'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

        
        # Alternate method to get the last filename
        #filename = '{:s}/{:s}.tiff'.format( detector.tiff.file_path.get(), detector.tiff.file_name.get()  )

        #if verbosity>=3:
        #    print('  Data saved to: {}'.format(filename))

        #if md['measure_type'] is not 'snap':
        if True:
            
            # self.set_attribute('exposure_time', caget('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime'))
            self.set_attribute('exposure_time', detector.cam.acquire_time.get()) #RL, 20210831                
            # Create symlink
            #link_name = '{}/{}{}'.format(RE.md['experiment_alias_directory'], subdir, md['filename'])
            #savename = md['filename'][:-5]
            
            savename = self.get_savename(savename_extra=extra)
            # link_name = '{}/{}{}_{:04d}_{}}.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1, detname)
            # link_name_part1 = '{}/{}{}_{:04d}'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id']-1)
            link_name = '{}/{}{}_{:04d}_{}.tiff'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id'], detname)
            link_name_part1 = '{}/{}{}_{:04d}'.format(RE.md['experiment_alias_directory'], subdir, savename, RE.md['scan_id'])
            
            if os.path.isfile(link_name):
                i = 1
                while os.path.isfile('{}.{:d}'.format(link_name,i)):
                    i += 1
                os.rename(link_name, '{}.{:d}'.format(link_name,i))
            
            for num_frame in range(num_frames):
                filename_new = '{}_{:06d}.tiff'.format(filename_part1, num_frame)
                link_name_new= '{}_{:06d}_{}.tiff'.format(link_name_part1, num_frame, detname)
                os.symlink(filename_new, link_name_new)                
                if verbosity>=3:
                    if num_frame == 0 or num_frame == np.max(num_frames):
                        print('  Data {} linked as: {}'.format(filename_new, link_name_new))

    # Control methods
    ########################################
    def setTemperature(self, temperature, output_channel='1', verbosity=3):
        #if verbosity>=1:
            #print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
        if output_channel == '1':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:1}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:1}T-SP', temperature+273.15)
        
        if output_channel == '2':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:2}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:2}T-SP', temperature+273.15)
        
        if output_channel == '3':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:3}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:3}T-SP', temperature+273.15)

        if output_channel == '4':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:4}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:4}T-SP', temperature+273.15)
            
            
    def temperature(self, temperature_probe='A', output_channel='1', RTDchan=2, verbosity=3):
        #if verbosity>=1:
            #print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
 
        if temperature_probe == 'A':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:A}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )            
        if temperature_probe == 'B':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:B}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )
        if temperature_probe == 'C':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:C}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )
        if temperature_probe == 'D':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:D}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )            
        if temperature_probe == 'E':
            try: 
                current_temperature = ioL.read(RTD[RTDchan])
            except TypeError:
                current_temperature = -273.15            
        return current_temperature

    def humidity(self, AI_chan=8, temperature=25, verbosity=3):        
        return ioL.readRH(AI_chan=8, temperature=temperature, verbosity=verbosity)
    
    def transmission_data_output(self, slot_pos):
        '''Output the tranmission of direct beam
        '''
        h = db[-1]
        dtable = h.table()
        
        #beam.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]
        scan_id = h.start['scan_id']     
        I_bim5 = h.start['beam_int_bim5']  #beam intensity from bim5
        I0 = dtable.pilatus2M_stats4_total
        filename = h.start['sample_name']
        exposure_time = h.start['sample_exposure_time']
        #I2 = dtable.pilatus2M_stats2_total
        #I3 = 2*dtable.pilatus2M_stats1_total - dtable.pilatus2M_stats2_total
        #In = I3 / beam.absorber_transmission_list[slot_pos] / exposure_time

        current_data = {'a_filename': filename,
                        'b_scanID': scan_id,
                        'c_I0': I0,
                        'd_I_bim5': I_bim5,
                        'e_absorber_slot': slot_pos,
                        #'f_absorber_ratio': beam.absorber_transmission_list[slot_pos],
                        'f_absorber_ratio': beam.absorber()[1],
                        'g_exposure_seconds': exposure_time}
        
        return pds.DataFrame(data=current_data)
        
    def intMeasure(self, output_file, exposure_time):
        '''Measure the transmission intensity of the sample by ROI4.
        The intensity will be saved in output_file
        '''        
        if abs(beam.energy(verbosity=0) - 13.5) < 0.1:
            beam.setAbsorber(4)
        elif abs(beam.energy(verbosity=0) - 17) < 0.1:
            beam.setAbsorber(6)

        print('Absorber is moved to position 4')

        #cms.setAbsorber(4)#armr.move(-31.100167+45) #slot 4 position 

        saxs_on()
        bsx.move(bsx.position+6)
        beam.setTransmission(1)
        cms.setDirectBeamROI(size=[10, 10])
        
        self.measure(exposure_time)
        
        temp_data = self.transmission_data_output(4)

        cms.modeMeasurement()
        beam.setAbsorber(0)
        #armr.move(-55) #default position with direct beam thru
       
        #output_data = output_data.iloc[0:0]

        #create a data file to save the INT data
        INT_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , output_file)            
        
        if os.path.isfile(INT_FILENAME):
            output_data = pds.read_csv(INT_FILENAME, index_col=0)
            output_data = output_data.append(temp_data, ignore_index=True)    
            output_data.to_csv(INT_FILENAME)
        else:
            temp_data.to_csv(INT_FILENAME)

    def temperature_setpoint(self, output_channel='1', verbosity=3):
        #if verbosity>=1:
            #print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
 
        if output_channel == '1':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:1}T-SP')
            
        if output_channel == '2':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:2}T-SP')

        if output_channel == '3':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:3}T-SP')

        if output_channel == '4':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:4}T-SP')
            
        return setpoint_temperature
        
    def monitor_scheme(self, scheme):
        '''monitor paramteres in the naming scheme and record it in the fucntion of time. 
           scheme = ['x', 'y', 'SAXSx', 'voltage']
        '''
        current_data = {}
        current_data['time'] = time.time()
        current_data['dt_time'] = datetime.fromtimestamp(time.time()) 
        for item in scheme:
            current_data['{}'.format(item)] = self.get_attribute(item)
        #print(current_data)
        return pds.DataFrame([current_data])    
        #return pds.Series(current_data).to_frame()

    def track_scheme(scheme, time_range, output_file, wait_time=5):
        '''monitor paramteres in the naming scheme and record it in the fucntion of time. 
           scheme : ['x', 'y', 'SAXSx', 'voltage']
           time_range : recording time, in section
           output_file : saved in /data/ folder. 
           wait_time :  interval time for data acquisition
        '''
        #create a data file to save the INT data
        data_folder = '{}/data/'.format(os.path.dirname(__file__))
        if os.path.exists(RE.md['experiment_alias_directory'])==False:
            return print('The path is NOT valid. Please create the data folder.')

        INT_FILENAME = '{}/data/{}.csv'.format(os.path.dirname(__file__) , output_file)    
        print(INT_FILENAME)
        time_range = time.time()+time_range
        while time.time()<time_range:
            temp_data = monitor_scheme(scheme=scheme)
            
            if os.path.isfile(INT_FILENAME):
                output_data = pds.read_csv(INT_FILENAME, index_col=0)
                output_data = output_data.append(temp_data, ignore_index=True)    
                output_data.to_csv(INT_FILENAME)
            else:
                temp_data.to_csv(INT_FILENAME)
            if wait_time>0:             
                time.sleep(wait_time)


class Stage(CoordinateSystem):
    
    pass


class SampleStage(Stage):
    
    def __init__(self, name='SampleStage', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        self._axes_definitions = [ {'name': 'x',
                            'motor': smx,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves stage left/outboard (beam moves right on sample)',
                            },
                            {'name': 'y',
                            'motor': smy,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves stage up (beam moves down on sample)',
                            },
                            {'name': 'th',
                            'motor': sth,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'deg',
                            'hint': 'positive tilts clockwise (positive incident angle)',
                            },
                        ]     
            
class Holder(Stage):
    '''The Holder() classes are used to define bars/stages that hold one or more 
    samples. This class can thus help to keep track of coordinate conversions, 
    to store the positions of multiple samples, and to automate the measurement 
    of multiple samples.'''

    # Core methods
    ########################################

    def __init__(self, name='Holder', base=None, **kwargs):
        
        if base is None:
            base = get_default_stage()
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._samples = {}
        self.reset_clock()

    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        self._axes_definitions = [ {'name': 'x',
                            'motor': None,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves stage left/outboard (beam moves right on sample)',
                            },
                            {'name': 'y',
                            'motor': None,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves stage up (beam moves down on sample)',
                            },
                            {'name': 'th',
                            'motor': None,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'deg',
                            'hint': 'positive tilts clockwise (positive incident angle)',
                            },
                        ]  

    def clock(self):
        '''Return the current value of the "clock" variable. This provides a
        way to set a clock/timer for a sample. For instance, you can call
        "reset_clock" when you initiate some change to the sample. Thereafter,
        the "clock" method lets you check how long it has been since that
        event.'''
        
        clock_delta = time.time() - self.clock_zero
        return clock_delta
        

    def reset_clock(self):
        '''Resets the sample's internal clock/timer to zero.'''
        
        self.clock_zero = time.time()
        
        return self.clock()  
    
    # Sample management
    ########################################
    
    def addSample(self, sample, sample_number=None):
        '''Add a sample to this holder/bar.'''
        
        if sample_number is None:
            if len(self._samples)==0:
                sample_number = 1
            else:
                ki = [ int(key) for key in self._samples.keys() ]
                sample_number = np.max(ki) + 1
                
                
        if sample_number in self._samples.keys():
            print('Warning: Sample number {} is already defined on holder "{:s}". Use "replaceSample" if you are sure you want to eliminate the existing sample from the holder.'.format(sample_number, self.name) )
            
        else:
            self._samples[sample_number] = sample
            
        self._samples[sample_number] = sample
        
        sample.set_base_stage(self)
        sample.md['holder_sample_number'] = sample_number

       
    def removeSample(self, sample_number):
        '''Remove a particular sample from this holder/bar.'''
        
        del self._samples[sample_number]
        
    
    def removeSamplesAll(self):
        
        self._samples = {}
        

    def replaceSample(self, sample, sample_number):
        '''Replace a given sample on this holder/bar with a different sample.'''
        
        self.removeSample(sample_number)
        self.addSample(sample, sample_number)
                
                
    def getSample(self, sample_number, verbosity=3):
        '''Return the requested sample object from this holder/bar.
        
        One can provide an integer, in which case the corresponding sample
        (from the holder's inventory) is returned. If a string is provided, 
        the closest-matching sample (by name) is returned.'''
        
        if type(sample_number) == int:
            if sample_number not in self._samples:
                if verbosity>=1:
                    print('Error: Sample {} not defined.'.format(sample_number))
                return None
            
            sample_match = self._samples[sample_number]

            if verbosity>=3:
                print('{}: {:s}'.format(sample_number, sample_match.name))
            
            return sample_match
        
            
        elif type(sample_number) == str:
            
            # First search for an exact name match
            matches = 0
            sample_match = None
            sample_i_match = None
            for sample_i, sample in sorted(self._samples.items()):
                if sample.name==sample_number:
                    matches += 1
                    if sample_match is None:
                        sample_match = sample
                        sample_i_match = sample_i
                    
            if matches==1:
                if verbosity>=3:
                    print('{}: {:s}'.format(sample_i_match, sample_match.name))
                return sample_match
                    
            elif matches>1:
                if verbosity>=2:
                    print('{:d} exact matches for "{:s}", returning sample {}: {:s}'.format(matches, sample_number, sample_i_match, sample_match.name))
                return sample_match
            
            
            # Try to find a 'start of name' match
            for sample_i, sample in sorted(self._samples.items()):
                if sample.name.startswith(sample_number):
                    matches += 1
                    if sample_match is None:
                        sample_match = sample
                        sample_i_match = sample_i
                        
            if matches==1:
                if verbosity>=3:
                    print('Beginning-name match: {}: {:s}'.format(sample_i_match, sample_match.name))
                return sample_match
                    
            elif matches>1:
                if verbosity>=2:
                    print('{:d} beginning-name matches for "{:s}", returning sample {}: {:s}'.format(matches, sample_number, sample_i_match, sample_match.name))
                return sample_match
            
            # Try to find a substring match
            for sample_i, sample in sorted(self._samples.items()):
                if sample_number in sample.name:
                    matches += 1
                    if sample_match is None:
                        sample_match = sample
                        sample_i_match = sample_i
                        
            if matches==1:
                if verbosity>=3:
                    print('Substring match: {}: {:s}'.format(sample_i_match, sample_match.name))
                return sample_match
                    
            elif matches>1:
                if verbosity>=2:
                    print('{:d} substring matches for "{:s}", returning sample {}: {:s}'.format(matches, sample_number, sample_i_match, sample_match.name))
                return sample_match
            
            if verbosity>=1:
                print('No sample has a name matching "{:s}"'.format(sample_number))
            return None
            
            
        else:
            
            print('Error: Sample designation "{}" not understood.'.format(sample_number))
            return None
    
    import string
    def getSamples(self, range=None, verbosity=3):
        '''Get the list of samples associated with this holder.
        
        If the optional range argument is provided (2-tuple), then only sample
        numbers within that range (inclusive) are run. If range is instead a 
        string, then all samples with names that match are returned.'''
        
        samples = []
        
        if range is None:
            for sample_number in sorted(self._samples):
                samples.append(self._samples[sample_number])
                
        elif type(range) is list:
            if type(range[0]) is int:
                if len(range) == 2:
                    start, stop = range
                    for sample_number in sorted(self._samples):
                        if sample_number>=start and sample_number<=stop:
                            samples.append(self._samples[sample_number])
                else: 
                    for sample_number in sorted(self._samples):
                        for ii in range: 
                            if sample_number == ii:
                                samples.append(self._samples[sample_number])                
 
            elif type(range[0]) is str: #For 96 well holder, format: A1, D2 ...
                for sample_number in sorted(self._samples):
                    sample_row = string.ascii_lowercase(sample_number[0])
                    sample_column = int(sample_number[1:])
                    sample_number = sample_row*12 + sample_column
                    samples.append(self._samples[sample_number])                 

        elif type(range) is str:
            for sample_number, sample in sorted(self._samples.items()):
                if range in sample.name:
                    samples.append(sample)
                    
        elif type(range) is int:
            samples.append(self._samples[range])
        
        else:
            if verbosity>=1:
                print('Range argument "{}" not understood.'.format(range))
            
            
        return samples
        
        
    def listSamples(self):
        '''Print a list of the current samples associated with this holder/
        bar.'''
        
        for sample_number, sample in sorted(self._samples.items()):
            print( '{}: {:s}'.format(sample_number, sample.name) )
        

    def gotoSample(self, sample_number):
        
        sample = self.getSample(sample_number, verbosity=0)
        sample.gotoAlignedPosition()
        
        return sample
        
        
    # Control methods
    ########################################
    def setTemperature(self, temperature, output_channel='1', verbosity=3):
        #if verbosity>=1:
            #print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
        if output_channel == '1':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:1}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:1}T-SP', temperature+273.15)
        
        if output_channel == '2':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:2}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:2}T-SP', temperature+273.15)
        
        if output_channel == '3':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:3}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:3}T-SP', temperature+273.15)

        if output_channel == '4':
            if verbosity>=2:
                print('  Changing temperature setpoint from {:.3f}°C  to {:.3f}°C'.format(caget('XF:11BM-ES{Env:01-Out:4}T-SP')-273.15, temperature))
            caput('XF:11BM-ES{Env:01-Out:4}T-SP', temperature+273.15)
            
            
    def temperature(self, temperature_probe='A', output_channel='1', verbosity=3):
        #if verbosity>=1:
            #print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
 
        if temperature_probe == 'A':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:A}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )
            
        if temperature_probe == 'B':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:B}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )

        if temperature_probe == 'C':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:C}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )

        if temperature_probe == 'D':
            current_temperature = caget('XF:11BM-ES{Env:01-Chan:D}T:C-I')
            if verbosity>=3:
                print('  Temperature = {:.3f}°C (setpoint = {:.3f}°C)'.format( current_temperature, self.temperature_setpoint(output_channel=output_channel)-273.15 ) )            
            
        return current_temperature

    def temperature_setpoint(self, output_channel='1', verbosity=3):
        #if verbosity>=1:
            #print('Temperature functions not implemented in {}'.format(self.__class__.__name__))
 
        if output_channel == '1':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:1}T-SP')
            
        if output_channel == '2':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:2}T-SP')

        if output_channel == '3':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:3}T-SP')

        if output_channel == '4':
            setpoint_temperature = caget('XF:11BM-ES{Env:01-Out:4}T-SP')
            
        return setpoint_temperature
        
        
        
    # Action (measurement) methods
    ########################################
                           
    def doSamples(self, range=None, verbosity=3, **md):
        '''Activate the default action (typically measurement) for all the samples.
        
        If the optional range argument is provided (2-tuple), then only sample
        numbers within that range (inclusive) are run. If range is instead a 
        string, then all samples with names that match are returned.'''
        
        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            sample.do(verbosity=verbosity, **md)
            
            
    def doTemperature(self, temperature, wait_time=None, temperature_probe='A', output_channel='1', temperature_tolerance=0.4, range=None, verbosity=3, poling_period=2.0, **md):
        
        # Set new temperature
        self.setTemperature(temperature, output_channel=output_channel, verbosity=verbosity)
        
        # Wait until we reach the temperature
        #while abs(self.temperature(verbosity=0) - temperature)>temperature_tolerance:
        while abs(self.temperature(temperature_probe=temperature_probe, verbosity=0) - temperature)>temperature_tolerance:
            if verbosity>=3:
                print('  setpoint = {:.3f}°C, Temperature = {:.3f}°C          \r'.format(self.temperature_setpoint()-273.15, self.temperature(verbosity=0)), end='')
            time.sleep(poling_period)
            
            
        # Allow for additional equilibration at this temperature
        if wait_time is not None:
            time.sleep(wait_time)
            
        self.doSamples(range=range, verbosity=verbosity, **md)
            

    def doTemperatures(self, temperatures,  wait_time=None, temperature_probe='A', output_channel='1', temperature_tolerance=0.4, range=None, verbosity=3, **md):
        
        for temperature in temperatures:
            
            self.doTemperature(temperature,  wait_time=wait_time, temperature_probe=temperature_probe, output_channel=output_channel, temperature_tolerance=temperature_tolerance, range=range, verbosity=verbosity, **md)
                
class PositionalHolder(Holder):
    '''This class is a sample holder that is one-dimensional. E.g. a bar with a
    set of samples lined up, or a holder with a set number of slots for holding
    samples. This class thus helps to associate each sample with its position
    on the bar.'''

    # Core methods
    ########################################

    def __init__(self, name='PositionalHolder', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        self.GaragePosition=[]
        
    # Sample management
    ########################################

    def slot(self, sample_number):
        '''Moves to the selected slot in the holder.'''
        
        getattr(self, self._positional_axis+'abs')( self.get_slot_position(sample_number) )
        
    
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        
        position = 0.0 + slot*1.0
        
        return position
        
        
    def addSampleSlot(self, sample, slot, detector_opt='SAXS'):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( [self._positional_axis], [self.get_slot_position(slot)] )
        sample.detector = detector_opt
        
    def addSampleSlotPosition(self, sample, slot, position, detector_opt='BOTH', incident_angles=None, transmission=1, exposure_time_SAXS = None, exposure_time_WAXS = None, tiling=None):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( [self._positional_axis], [position] )
        sample.detector = detector_opt
        sample.incident_angles = incident_angles
        sample.transmission = transmission
        sample.position = position
        #sample.exposure_time_SAXS = exposure_time_SAXS 
        #sample.exposure_time_WAXS = exposure_time_WAXS 
        #sample.exposure_time_MAXS = exposure_time_MAXS 
        #sample.tiling = tiling
        
        
        #TODO: list sample details including:
        # name, slot, position, detector_opt, incident_angles, transmission, exposure_time_SAXS, exposure_time_WAXS, exposure_time_MAXS, tiling
        # load it in a standard format, such as xls or pandas
        
    def listSamplesPositions(self):
        '''Print a list of the current samples associated with this holder/
        bar.'''
        
        for sample_number, sample in self._samples.items():
            #pos = getattr(sample, self._positional_axis+'pos')(verbosity=0)
            pos = sample.origin(verbosity=0)[self._positional_axis]
            print( '%s: %s (%s = %.3f)' % (str(sample_number), sample.name, self._positional_axis, pos) )

    def listSamplesDetails(self):
        '''Print a list of the current samples associated with this holder/
        bar.'''
        
        for sample_number, sample in self._samples.items():
            #pos = getattr(sample, self._positional_axis+'pos')(verbosity=0)
            pos = sample.origin(verbosity=0)[self._positional_axis]
            print( '%s: %s (%s = %.3f) %s' % (str(sample_number), sample.name, self._positional_axis, pos, sample.detector) )
            
    def addGaragePosition(self, shelf_num, spot_num):
        '''the position in garage'''
        if shelf_num not in range(1, 5) or spot_num not in range(1, 4):
            print('Out of the range in Garage (4 x 3)')
                    
        self.GaragePosition=[shelf_num, spot_num]

    def intMeasure(self, output_file, exposure_time):
        
        for sample in self.getSamples():
            sample.gotoOrigin()
            sample.intMeasure(output_file, exposure_time)

    def saveSampleStates(self, output_file = None):
        '''Print a list of the current samples associated with this holder/bar. 
        
        It can be saved in the output_file under setup'''
        
        states = {}
        for sample_number, sample in sorted(self._samples.items()):
            states[sample_number]  = sample.save_state()
        
        cms.samples_states = states
        if output_file is not None:
            with open(output_file, 'wb') as handle:
                pickle.dump(states, handle, protocol=pickle.HIGHEST_PROTOCOL)
                
        return states
    
    def restoreSampleStates(self, input_file = None):
        
        if input_file is not None:
            with open(input_file,'rb') as handle:
                cms.samples_states = pickle.load(handle)
            
        for sample_number, sample in sorted(self._samples.items()):            
            sample.restore_state(cms.samples_states[sample_number])
            print(sample.save_state())        

    
    def checkPositions(self):
        for sample in self.getSamples():
            sample.gotoOrigin()
            time.sleep(1)
            


stg = SampleStage()
def get_default_stage():
    return stg


if False:
    # For testing:
    # %run -i /opt/ipython_profiles/profile_collection/startup/94-sample.py
    sam = SampleGISAXS_Generic('testing_of_code')
    sam.mark('here')
    #sam.mark('XY_field', 'x', 'y')
    #sam.mark('specified', x=1, th=0.1)
    #sam.naming(['name', 'extra', 'clock', 'th', 'exposure_time', 'id'])
    #sam.thsetOrigin(0.5)
    #sam.marks()
    
    
    hol = CapillaryHolder(base=stg)
    hol.addSampleSlot( SampleGISAXS_Generic('test_sample_01'), 1.0 )
    hol.addSampleSlot( SampleGISAXS_Generic('test_sample_02'), 3.0 )
    hol.addSampleSlot( SampleGISAXS_Generic('test_sample_03'), 5.0 )
    
    sam = hol.getSample(1)



################################################################################
# Code for customer-made holders and sample stages, 
# Samples include : 
# 1. SampleTSAXS_Generic : TSAXS/TWAXS
# 2. SampleGISAXS_Generic : GISAXS/GIWAXS
# 3. SampleXR_WAXS : XR and th-2th scan
# 4. SampleCDSAXS_Generic : CD SAXS/GISAXS
# 5. SampleGonio_Generic : SmartAct Goniometer 
# 6. SampleSecondStage : 2nd sample stage

# Holders include : 
# 1. CapillaryHolder : TSAXS 
# 2. GIBar : GISAXS/GIWAXS bar
# 3. CapillaryHolderHeated :  heat stage for transmission
# 4. GIBar_long_thermal : heat stage for GI
# 5. WellPlateHolder: well plate
# 6. PaloniThermalStage: special stage made in brass by UCSB group. 
# 7. DSCStage : tranmission stage for DSC capsules
# 8. InstecStage60 : HCS 60, From Sam Sprunt (Kent State U. )
# 9. InstecStage402 : HCS 402, beamline owned
# 10.OffCenteredHoder: GTSAXS 
# 11.HumidityStage: GI humidity stage
# 12.HumidityTransmissionStage: Trans humidity stage
# 13.GIBar_Linkam : Linkam GI holder with N2 protective dome

# TODO: some clean-ups.
# 1. make rotational stage as custom stage with phi, strans, strans2, tilt, tilt2 stages. 
#  
################################################################################ 

# custmer-made samples. 
class SampleTSAXS_Generic(Sample_Generic):
    
    ################# Direct beam transmission measurement ####################
    def intMeasure(self, output_file, exposure_time):
        '''Measure the transmission intensity of the sample by ROI4.
        The intensity will be saved in output_file
        '''        
        if abs(beam.energy(verbosity=0) - 13.5) < 0.1:
            beam.setAbsorber(4)
        elif abs(beam.energy(verbosity=0) - 17) < 0.1:
            beam.setAbsorber(6)

        print('Absorber is moved to position {}'.format(beam.absorber()[0]))

        detselect([pilatus2M])
        if beam.absorber()[0]>=4:
            bsx.move(bsx.position+6)
            beam.setTransmission(1)
            
        self.measure(exposure_time)
        
        temp_data = self.transmission_data_output(beam.absorber()[0])

        cms.modeMeasurement()
        #beam.setAbsorber(0)
        beam.absorber_out()
       
        #output_data = output_data.iloc[0:0]

        #create a data file to save the INT data
        INT_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , output_file)            
        
        if os.path.isfile(INT_FILENAME):
            output_data = pds.read_csv(INT_FILENAME, index_col=0)
            output_data = output_data.append(temp_data, ignore_index=True)    
            output_data.to_csv(INT_FILENAME)
        else:
            temp_data.to_csv(INT_FILENAME)
            
    def transmission_data_output(self, slot_pos):
        '''Output the tranmission of direct beam
        '''
        h = db[-1]
        dtable = h.table()
        
        #beam.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]
        scan_id = h.start['scan_id']     
        I_bim5 = h.start['beam_int_bim5']  #beam intensity from bim5
        I0 = dtable.pilatus2M_stats4_total
        filename = h.start['sample_name']
        exposure_time = h.start['sample_exposure_time']
        #I2 = dtable.pilatus2M_stats2_total
        #I3 = 2*dtable.pilatus2M_stats1_total - dtable.pilatus2M_stats2_total
        #In = I3 / beam.absorber_transmission_list[slot_pos] / exposure_time

        current_data = {'a_filename': filename,
                        'b_scanID': scan_id,
                        'c_I0': I0,
                        'd_I_bim5': I_bim5,
                        'e_absorber_slot': slot_pos,
                        #'f_absorber_ratio': beam.absorber_transmission_list[slot_pos],
                        'f_absorber_ratio': beam.absorber()[1],
                        'g_exposure_seconds': exposure_time}
        
        return pds.DataFrame(data=current_data)


class SampleGISAXS_Generic(Sample_Generic):
    
    def __init__(self, name, base=None, **md):
        
        super().__init__(name=name, base=base, **md)
        self.naming_scheme = ['name', 'extra', 'th', 'exposure_time']
        self.incident_angles_default = [0.08, 0.10, 0.12, 0.15, 0.20]
        self.measure_setting={}
        self.alignDone=False
        
    def measureSpots(self, num_spots=2, translation_amount=0.1, axis='x', exposure_time=None, extra=None, measure_type='measureSpots', **md):
        super().measureSpots(num_spots=num_spots, translation_amount=translation_amount, axis=axis, exposure_time=exposure_time, extra=extra, measure_type=measure_type, **md)
    
    def measureIncidentAngle(self, angle, exposure_time=None, extra=None, tiling=None, **md):
         
        self.thabs(angle)
        while sth.moving==True:
            time.sleep(.1)
        self.measure(exposure_time=exposure_time, extra=extra, tiling=tiling, **md)
        
    def measureIncidentAngles(self, angles=None, exposure_time=None, extra=None, tiling=None, **md):
        
        #measure the incident angles first and then change the tiling features. 
        if angles is None:
            angles = self.incident_angles_default
        for angle in angles:
            self.measureIncidentAngle(angle, exposure_time=exposure_time, extra=extra, tiling=tiling, **md)

    def measureIncidentAngles_Stitch(self, angles=None, exposure_time=None, extra=None, tiling=None, verbosity=3, **md):
        
        #measure the incident angles first and then change the tiling features. 
        if tiling == None:
            if angles is None:
                angles = self.incident_angles_default
            for angle in angles:
                self.measureIncidentAngle(angle, exposure_time=exposure_time, extra=extra, tiling=tiling, **md)
                
        elif tiling=='ygaps': 
            if angles is None:
                angles = self.incident_angles_default
            #pos1 
            for angle in angles:
                self.thabs(angle)
                while sth.moving==True:
                    time.sleep(0.1)
                time.sleep(.5)
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            #pos2 
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value
            MAXSy_o = MAXSy.user_readback.value
            if pilatus2M in cms.detector:
                SAXSy.move(SAXSy_o + 5.16)
            if pilatus800 in cms.detector:
                WAXSy.move(WAXSy_o + 5.16)
            if pilatus300 in cms.detector:
                MAXSy.move(MAXSy_o + 5.16)
                
            for angle in angles:
                self.thabs(angle)
                while sth.moving==True:
                    time.sleep(0.1)
                time.sleep(.5)

                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)    
            if MAXSy.user_readback.value != MAXSy_o:
                MAXSy.move(MAXSy_o)                
                
        elif tiling == 'xygaps':
            if angles is None:
                angles = self.incident_angles_default
            #pos1 
            for angle in angles:
                self.thabs(angle)
                time.sleep(.5)
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower_left'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
            
            #pos2
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value
            #MAXSy_o = MAXSy.user_readback.value

            for angle in angles:
                self.thabs(angle)
                time.sleep(.2)
                if pilatus2M in cms.detector:
                    SAXSy.move(SAXSy_o + 5.16)
                if pilatus800 in cms.detector:
                    WAXSy.move(WAXSy_o + 5.16)
                if pilatus300 in cms.detector:
                    MAXSy.move(MAXSy_o + 5.16)

                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
               
            #pos4  #comment out to save time
            for angle in angles:
                self.thabs(angle)
                time.sleep(.2)

                if pilatus2M in cms.detector:
                    SAXSx.move(SAXSx_o + 5.16)
                    SAXSy.move(SAXSy_o + 5.16)
                if pilatus800 in cms.detector:
                    WAXSx.move(WAXSx_o - 5.16)
                    WAXSy.move(WAXSy_o + 5.16)
                extra_current = 'pos4' if extra is None else '{}_pos4'.format(extra)
                md['detector_position'] = 'upper_right'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
                  
            #pos3
            for angle in angles:
                self.thabs(angle)
                time.sleep(.2)

                if pilatus2M in cms.detector:
                    SAXSx.move(SAXSx_o + 5.16)
                    SAXSy.move(SAXSy_o)
                if pilatus800 in cms.detector:
                    WAXSx.move(WAXSx_o - 5.16)
                    WAXSy.move(WAXSy_o)

                extra_current = 'pos3' if extra is None else '{}_pos3'.format(extra)
                md['detector_position'] = 'lower_right'
                self.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)


            if WAXSx.user_readback.value != WAXSx_o:
                WAXSx.move(WAXSx_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)
            
            if SAXSx.user_readback.value != SAXSx_o:
                SAXSx.move(SAXSx_o)
            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)       

    ################# Direct beam transmission measurement ####################
    def intMeasure(self, output_file, exposure_time):
        '''Measure the transmission intensity of the sample by ROI4.
        The intensity will be saved in output_file
        '''        
        if abs(beam.energy(verbosity=0) - 13.5) < 0.1:
            beam.setAbsorber(4)
        elif abs(beam.energy(verbosity=0) - 17) < 0.1:
            beam.setAbsorber(6)

        print('Absorber is moved to position {}'.format(beam.absorber()[0]))

        detselect([pilatus2M])
        if beam.absorber()[0]>=4:
            bsx.move(bsx.position+6)
            beam.setTransmission(1)
            
        self.measure(exposure_time)
        
        temp_data = self.transmission_data_output(beam.absorber()[0])

        cms.modeMeasurement()
        #beam.setAbsorber(0)
        beam.absorber_out()
       
        #output_data = output_data.iloc[0:0]

        #create a data file to save the INT data
        INT_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , output_file)            
        
        if os.path.isfile(INT_FILENAME):
            output_data = pds.read_csv(INT_FILENAME, index_col=0)
            output_data = output_data.append(temp_data, ignore_index=True)    
            output_data.to_csv(INT_FILENAME)
        else:
            temp_data.to_csv(INT_FILENAME)
            
    def transmission_data_output(self, slot_pos):
        '''Output the tranmission of direct beam
        '''
        h = db[-1]
        dtable = h.table()
        
        #beam.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]
        scan_id = h.start['scan_id']     
        I_bim5 = h.start['beam_int_bim5']  #beam intensity from bim5
        I0 = dtable.pilatus2M_stats4_total
        filename = h.start['sample_name']
        exposure_time = h.start['sample_exposure_time']
        #I2 = dtable.pilatus2M_stats2_total
        #I3 = 2*dtable.pilatus2M_stats1_total - dtable.pilatus2M_stats2_total
        #In = I3 / beam.absorber_transmission_list[slot_pos] / exposure_time

        current_data = {'a_filename': filename,
                        'b_scanID': scan_id,
                        'c_I0': I0,
                        'd_I_bim5': I_bim5,
                        'e_absorber_slot': slot_pos,
                        #'f_absorber_ratio': beam.absorber_transmission_list[slot_pos],
                        'f_absorber_ratio': beam.absorber()[1],
                        'g_exposure_seconds': exposure_time}
        
        return pds.DataFrame(data=current_data)

    
    def _alignOld(self, step=0):
        '''Align the sample with respect to the beam. GISAXS alignment involves
        vertical translation to the beam center, and rocking theta to get the
        sample plane parralel to the beam.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''
        
        # TODO: Deprecate and delete
        
        if step<=0:
            # TODO: Check what mode we are in, change if necessary...
            # get_beamline().modeAlignment()
            beam.on()
        
        # TODO: Improve implementation
        if step<=2:
            #fit_scan(smy, 2.6, 35, fit='HM')
            fit_scan(smy, 2.6, 35, fit='sigmoid_r')
        
        
        if step<=4:
            #fit_scan(smy, 0.6, 17, fit='HM')
            fit_scan(smy, 0.6, 17, fit='sigmoid_r')
            fit_scan(sth, 1.2, 21, fit='max')

        #if step<=6:
        #    fit_scan(smy, 0.3, 17, fit='sigmoid_r')
        #    fit_scan(sth, 1.2, 21, fit='COM')

        if step<=8:
            fit_scan(smy, 0.2, 17, fit='sigmoid_r')
            fit_scan(sth, 0.8, 21, fit='gauss')
        
        if step<=9:
            #self._testing_refl_pos()
            #movr(sth,.1)
            #fit_scan(sth, 0.2, 41, fit='gauss')
            #fit_scan(smy, 0.2, 21, fit='gauss')
            #movr(sth,-.1)
            
            
            beam.off()
    
    
    
    def align(self, step=0, reflection_angle=0.12, verbosity=3):
        '''Align the sample with respect to the beam. GISAXS alignment involves
        vertical translation to the beam center, and rocking theta to get the
        sample plane parralel to the beam. Finally, the angle is re-optimized
        in reflection mode.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''

        if verbosity>=4:
            print('  Aligning {}'.format(self.name))
        
        if step<=0:
            # Prepare for alignment
            
            if RE.state!='idle':
                RE.abort()
                
            if get_beamline().current_mode!='alignment':
                #if verbosity>=2:
                    #print("WARNING: Beamline is not in alignment mode (mode is '{}')".format(get_beamline().current_mode))
                print("Switching to alignment mode (current mode is '{}')".format(get_beamline().current_mode))
                get_beamline().modeAlignment()
                
                
            get_beamline().setDirectBeamROI()
            
            beam.on()

        
        if step<=2:
            if verbosity>=4:
                print('    align: searching')
                
            # Estimate full-beam intensity
            value = None
            if True:
                # You can eliminate this, in which case RE.md['beam_intensity_expected'] is used by default
                self.yr(-2)
                #detector = gs.DETS[0]
                detector = get_beamline().detector[0]
                value_name = get_beamline().TABLE_COLS[0]
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                self.yr(+2)
            
            if 'beam_intensity_expected' in RE.md:
                if value<RE.md['beam_intensity_expected']*0.75:
                    print('WARNING: Direct beam intensity ({}) lower than it should be ({})'.format(value, RE.md['beam_intensity_expected']))
                
            # Find the step-edge
            self.ysearch(step_size=0.5, min_step=0.005, intensity=value, target=0.5, verbosity=verbosity, polarity=-1)
            
            # Find the peak
            self.thsearch(step_size=0.4, min_step=0.01, target='max', verbosity=verbosity)
        
        
        if step<=4:
            if verbosity>=4:
                print('    align: fitting')
            
            fit_scan(smy, 1.2, 21, fit='HMi')
            ##time.sleep(2)
            fit_scan(sth, 1.5, 21, fit='max')
            ##time.sleep(2)            
            
        #if step<=5:
        #    #fit_scan(smy, 0.6, 17, fit='sigmoid_r')
        #    fit_edge(smy, 0.6, 17)
        #    fit_scan(sth, 1.2, 21, fit='max')


        if step<=8:
            #fit_scan(smy, 0.3, 21, fit='sigmoid_r')
            
            fit_edge(smy, 0.6, 21)
            #time.sleep(2)
            #fit_edge(smy, 0.4, 21)
            fit_scan(sth, 0.8, 21, fit='COM')
            #time.sleep(2)            
            self.setOrigin(['y', 'th'])
        
        
        if step<=9 and reflection_angle is not None:
            # Final alignment using reflected beam
            if verbosity>=4:
                print('    align: reflected beam')
            get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0)
            #get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0, size=[12,2])
            
            self.thabs(reflection_angle)
            
            result = fit_scan(sth, 0.4, 41, fit='max') 
            #result = fit_scan(sth, 0.2, 81, fit='max') #it's useful for alignment of SmarAct stage
            sth_target = result.values['x_max']-reflection_angle
            
            if result.values['y_max']>50:
                th_target = self._axes['th'].motor_to_cur(sth_target)
                self.thsetOrigin(th_target)

            #fit_scan(smy, 0.2, 21, fit='max')
            #self.setOrigin(['y'])            

        if step<=10:
            self.thabs(0.0)
            beam.off()
            
    def _test_align(self, step=0, reflection_angle=0.12, verbosity=3):
        '''Align the sample with respect to the beam. GISAXS alignment involves
        vertical translation to the beam center, and rocking theta to get the
        sample plane parralel to the beam. Finally, the angle is re-optimized
        in reflection mode.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''

        if verbosity>=4:
            print('  Aligning {}'.format(self.name))
        
        if step<=0:
            # Prepare for alignment
            
            if RE.state!='idle':
                RE.abort()
                
            if get_beamline().current_mode!='alignment':
                #if verbosity>=2:
                    #print("WARNING: Beamline is not in alignment mode (mode is '{}')".format(get_beamline().current_mode))
                print("Switching to alignment mode (current mode is '{}')".format(get_beamline().current_mode))
                get_beamline().modeAlignment()
            get_beamline().setDirectBeamROI()
        #if step<=2:
            #if verbosity>=4:
                #print('    align: searching')
            #beam.on()
            ## Estimate full-beam intensity
            #value = None
            #if True:
                ## You can eliminate this, in which case RE.md['beam_intensity_expected'] is used by default
                #self.yr(-2)
                ##detector = gs.DETS[0]
                #detector = get_beamline().detector[0]
                #value_name = get_beamline().TABLE_COLS[0]
                #RE(count([detector]))
                #value = detector.read()[value_name]['value']
                #self.yr(+2)
            
            #if 'beam_intensity_expected' in RE.md and value<RE.md['beam_intensity_expected']*0.75:
                #print('WARNING: Direct beam intensity ({}) lower than it should be ({})'.format(value, RE.md['beam_intensity_expected']))
                
            ## Find the step-edge
            #self.ysearch(step_size=0.5, min_step=0.005, intensity=value, target=0.5, verbosity=verbosity, polarity=-1)
            
            ## Find the peak
            #self.thsearch(step_size=0.4, min_step=0.01, target='max', verbosity=verbosity)
        
        
        if step<=4:
            if verbosity>=4:
                print('    align: fitting')
            
            fit_scan(smy, 1.2, 21, fit='HMi')
            ##time.sleep(2)
            fit_scan(sth, 1.5, 21, fit='max')
            ##time.sleep(2)            
            

        #if step<=8 and reflection_angle==None:
            #fit_edge(smy, 0.6, 21)
            ##time.sleep(2)
            #fit_scan(sth, 0.8, 21, fit='COM')
            #self.setOrigin(['y', 'th'])
        
        
        if step<=9 and reflection_angle is not None:
            # Final alignment using reflected beam
            if verbosity>=4:
                print('    align: reflected beam')
            get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0)
            #sth scan
            self.thabs(reflection_angle)
            result = fit_scan(sth, 0.4, 41, fit='max') 
            sth_target = result.values['x_max']-reflection_angle
            
            if result.values['y_max']>50:
                th_target = self._axes['th'].motor_to_cur(sth_target)
                self.thsetOrigin(th_target)
            #y scan 
            fit_scan(smy, 0.2, 21, fit='max')
            self.setOrigin(['y'])            

        if step<=10:
            self.thabs(0.0)
            beam.off()
            
    def alignQuick(self, align_step=8, reflection_angle=0.08, verbosity=3):
        
        get_beamline().modeAlignment()
        #self.yo()
        self.tho()
        beam.on()
        self.align(step=align_step, reflection_angle=reflection_angle, verbosity=verbosity)
    
    def level(self, step=0,pos_x_left=-5, pos_x_right=5):
        
        #TODO: Move this code. (This should be a property of the GIBar object.)
        
        #level sample by checking bar height at pos_left and pos_right
        print('checking the level of Sample')
        if step<=1:
           cms.modeAlignment()
           self.tho()
           self.yo()
           
        self.xabs(pos_x_left)
        #beam.on()
        fit_edge(smy, .6, 17)  #it's better not to move smy after scan but only the center position
        time.sleep(1)
        pos_y_left=smy.position
        #pos_y_left=smy.user_readback.value
        print('BEFORE LEVEL: pos_y_left = {}'.format(pos_y_left))
        
        self.xabs(pos_x_right)
        fit_edge(smy, .6, 17)  #it's better not to move smy after scan but only the center position
        time.sleep(1)
        pos_y_right=smy.position
        print('BEFORE LEVEL: pos_y_right = {}'.format(pos_y_right))

        offset_schi=(pos_y_right-pos_y_left)/(pos_x_right-pos_x_left)*180/np.pi
        print('The schi offset is {} degrees'.format(offset_schi))
        schi.move(schi.position - offset_schi)
        
        
        #double-check the chi offset
        self.xabs(pos_x_left)
        fit_edge(smy, .6, 17)  #it's better not to move smy after scan but only the center position
        time.sleep(1)
        pos_y_left=smy.position
        print('AFTER LEVEL: pos_y_left = {}'.format(pos_y_left))
        
        self.xabs(pos_x_right)
        fit_edge(smy, .6, 17)  #it's better not to move smy after scan but only the center position
        time.sleep(1)
        pos_y_right=smy.position
        print('AFTER LEVEL: pos_y_right = {}'.format(pos_y_right))
        #beam.off()
        
        self.xo()
        offset_schi=(pos_y_right-pos_y_left)/(pos_x_right-pos_x_left)*180/np.pi

        if offset_schi<=0.1:
            print('schi offset is aligned successfully!')

        else:
            print('schi offset is WRONG. Please redo the level command')
        fit_edge(smy, .6, 17)  #it's better not to move smy after scan but only the center position
        self.setOrigin(['y'])
        
        
    
    def do(self, step=0, align_step=0, **md):
        
        if step<=1:
            get_beamline().modeAlignment()
            
        if step<=2:
            self.xo() # goto origin


        if step<=4:
            self.yo()
            self.tho()
        
        if step<=5:
            self.align(step=align_step, reflection_angle=0.12)
            #self.setOrigin(['y','th']) # This is done within align

        #if step<=7:
            #self.xr(0.2)

        if step<=8:
            get_beamline().modeMeasurement()
        
        if step<=10:
            #detselect([pilatus300, psccd])
            #detselect(psccd)
            #detselect(pilatus300)
            detselect(pilatus2M)
            for detector in get_beamline().detector:
                if detector.name == 'pilatus2M': 
                    RE(detector.setExposureTime(self.md['exposure_time']))
                else: 
                    detector.setExposureTime(self.md['exposure_time'])
            self.measureIncidentAngles(self.incident_angles_default, **md)
            self.thabs(0.0)

    def backup_do_SAXS(self, step=0, align_step=0, measure_setting=None, **md):
        
        if step<=1:
            saxs_on()
            get_beamline().modeAlignment()
            
        if step<=2:
            self.xo() # goto origin


        if step<=4:
            self.yo()
            self.tho()
        
        if step<=5:
            self.align(step=align_step, reflection_angle=0.12)
            #self.setOrigin(['y','th']) # This is done within align

        #if step<=7:
            #self.xr(0.2)

        if step<=8:
            get_beamline().modeMeasurement()
        
        if step<=10:
            if measure_setting==None:
                measure_setting=measure_setting
                
            if self.incident_angles==None:
                incident_angles = self.incident_angles_default
            else:
                incident_angles = self.incident_angles
            self.measureIncidentAngles_Stitch(incident_angles, exposure_time=self.SAXS_time, tiling='ygaps', **md)


    def do_SAXS(self, step=0, align_step=0, measure_setting=None, **md):
        
        if step<=1:
            saxs_on()
            get_beamline().modeAlignment()
            
        if step<=2:
            self.xo() # goto origin


        if step<=4:
            self.yo()
            self.tho()
        
        if step<=5:
            self.align(step=align_step, reflection_angle=0.12)
            #self.setOrigin(['y','th']) # This is done within align

        #if step<=7:
            #self.xr(0.2)

        if step<=8:
            get_beamline().modeMeasurement()
            self.alignDone=True
        
        if step<=10:

            if self.measure_setting['incident_angles']==None:
                incident_angles = self.incident_angles_default
            else:
                incident_angles = self.measure_setting['incident_angles']
            if self.measure_setting['exposure_time']==None:
                exposure_time = self.SAXS_time
            else:
                if type(self.measure_setting['exposure_time'])==list:
                    exposure_time = self.measure_setting['exposure_time'][0]
                else:      
                    exposure_time = self.measure_setting['exposure_time']
            tiling = self.measure_setting['tiling']

            self.measureIncidentAngles_Stitch(incident_angles, exposure_time=exposure_time, tiling=tiling, **md)
            
            
    def do_WAXS_only(self, step=0, align_step=0, **md):
        if step<5:
            self.xo()
            self.yo()
            self.tho()
            get_beamline().modeMeasurement()        
        if step<=10:
            if self.measure_setting['incident_angles']==None:
                incident_angles = self.incident_angles_default
            else:
                incident_angles = self.measure_setting['incident_angles']
            if self.measure_setting['exposure_time']==None:
                exposure_time = self.SAXS_time
            else:
                if type(self.measure_setting['exposure_time'])==list:
                    exposure_time = self.measure_setting['exposure_time'][0]
                else:      
                    exposure_time = self.measure_setting['exposure_time']
            tiling = self.measure_setting['tiling']
            waxs_on()
            self.measureIncidentAngles_Stitch(incident_angles, exposure_time=exposure_time, tiling=tiling, **md)
            self.thabs(0.0)            
 
    def _backup_do_WAXS(self, step=0, align_step=0, **md):
    
        if step<=1:
            saxs_on()
            get_beamline().modeAlignment()
            
        if step<=2:
            self.xo() # goto origin


        if step<=4:
            self.yo()
            self.tho()
        
        if step<=5:
            self.align(step=align_step, reflection_angle=0.12)
            #self.setOrigin(['y','th']) # This is done within align

        #if step<=7:
            #self.xr(0.2)

        if step<=8:
            get_beamline().modeMeasurement()
        
        if step<=10:
            if self.incident_angles==None:
                incident_angles = self.incident_angles_default
            else:
                incident_angles = self.incident_angles
                
            waxs_on() # edited from waxs_on 3/25/19 through a saxs_on error
            #for detector in get_beamline().detector:
                #detector.setExposureTime(self.MAXS_time)
            self._test2_measureIncidentAngles(incident_angles, exposure_time=self.WAXS_time, tiling='ygaps', **md)
            
            #if self.exposure_time_MAXS==None:
                #self.measureIncidentAngles(incident_angles, exposure_time=self.MAXS_time, tiling=self.tiling, **md)
            #else:
                #self.measureIncidentAngles(incident_angles, exposure_time=self.exposure_time_MAXS, tiling=self.tiling, **md)
            self.thabs(0.0)

    def do_WAXS(self, step=0, align_step=0, **md):
    
        if step<=1:
            saxs_on()
            get_beamline().modeAlignment()
            
        if step<=2:
            self.xo() # goto origin


        if step<=4:
            self.yo()
            self.tho()
        
        if step<=5:
            self.align(step=align_step, reflection_angle=0.12)
            #self.setOrigin(['y','th']) # This is done within align

        #if step<=7:
            #self.xr(0.2)

        if step<=8:
            get_beamline().modeMeasurement()
        
        if step<=10:
            if self.measure_setting['incident_angles']==None:
                incident_angles = self.incident_angles_default
            else:
                incident_angles = self.measure_setting['incident_angles']
            if self.measure_setting['exposure_time']==None:
                exposure_time = self.SAXS_time
            else:
                if type(self.measure_setting['exposure_time'])==list:
                    exposure_time = self.measure_setting['exposure_time'][0]
                else:      
                    exposure_time = self.measure_setting['exposure_time']
            tiling = self.measure_setting['tiling']
            waxs_on()
            self.measureIncidentAngles_Stitch(incident_angles, exposure_time=exposure_time, tiling=tiling, **md)
            self.thabs(0.0)            
 
  
class SampleCDSAXS_Generic(Sample_Generic):
    
    def __init__(self, name, base=None, **md):
        
        super().__init__(name=name, base=base, **md)
        self.naming_scheme = ['name', 'extra', 'phi', 'exposure_time']
        self.rot_angles_default = np.arange(-45, +45+1, +1)
        #self.rot_angles_default = np.linspace(-45, +45, num=90, endpoint=True)
        
    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        super()._set_axes_definitions()
        
        self._axes_definitions.append( {'name': 'phi',
                            'motor': srot,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'deg',
                            'hint': None,
                            } )
        
    def measureAngle(self, angle, exposure_time=None, extra=None, measure_type='measure', **md):
        self.phiabs(angle)
        self.measure(exposure_time=exposure_time, extra=extra, measure_type=measure_type, **md)
        
        
    def measureAngles(self, angles=None, exposure_time=None, extra=None, measure_type='measureAngles', **md):
        if angles is None:
            angles = self.rot_angles_default
        for angle in angles:
            self.measureAngle(angle, exposure_time=exposure_time, extra=extra, measure_type=measure_type, **md)
        

class SampleXR_WAXS(SampleGISAXS_Generic):

    ################# Specular reflectivity (XR) measurement ####################

    def XR_scan(self, scan_type='theta_scan', theta_range=[0,1.6], theta_delta=0.1, theta_list=None, qz_list=None, roi_size=[12,30], exposure_time=1, threshold=20000, max_exposure_time=10, extra='XR_scan', output_file=None, **md):
        ''' Run x-ray reflectivity measurement for thin film samples on WAXS pilatus800k. 
        There will be two WAXSy positions for XR. 
        The 1st position is the beam shining directly on the detector with maximum attenuation.
        This position is defined by cms.WAXS.setCalibration([734, 1090],0.255, [-65, -73])
        The 2nd position is the beam out of the WAXS detector. 
        The detector will be moved to the 2nd position when the reflected beam out of beam stop. 
        
        Parameters
        ----------
        scan_type : list
            theta_scan: in step of theta
            q_scan: in step of q
        theta_range: list 
            The scanning range. It can be single section or multiple sections with various step_size.
            Examples:  
            [0, 1.6] or 
            [[0, .3],[0.3, 1], [1, 1.6]]                    
        theta_delta: float or list
            The scaning step. Examples:
            0.02    or
            [0.005, 0.1, 0.2]
        roi_size: float
            The szie of ROI1.
        exposure_time: float
            The mininum exposure time
        min_step : float
            The final (minimum) step size to try
        intensity : float
            The expected full-beam intensity readout
        threshold : float
            The threshold of minimum intensity. Exposure time increases automatically if < max_exposure_time 
        max_exposure_time : float
            The maximum of exposure time to limit the total time.
 
        '''
        #TODO:
        #if theta_end < theta_start:
        #    print("The theta_end is larger than theta_start!!!")
        
        #disable the besteffortcallback and plot all ROIs
        #bec.disable_table()
        cms.modeXRMeasurement()
        cms.definePos(size=roi_size)
        
        bec.disable_plots()
        
        
        cms.WAXS.detector.stats1.total.kind = 'hinted'
        cms.WAXS.detector.stats2.total.kind = 'hinted'

        self.naming_scheme_hold = self.naming_scheme
        self.naming_scheme = ['name', 'extra', 'x', 'th', 'exposure_time']
        #default_WAXSy = WAXSy.position
        
        #move in absorber and move out the beamstop
        slot_pos = 4
        beam.setAbsorber(slot_pos)
        if beam.absorber()[0]>=4:
            bsx.move(bsx.position+6)
            beam.setTransmission(1)
        
        #create a clean dataframe and a direct beam images
        self.yr(-2)
        self.tho()
        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:
            direct_beam_slot = 4
        #Energy = 17kev
        if abs(beam.energy(verbosity=1)-17) < 0.1:
            direct_beam_slot = 6
            slot_pos = 6

        #Energy = 17kev
        if abs(beam.energy(verbosity=1)-10) < 0.1:
            direct_beam_slot = 3

        beam.setAbsorber(direct_beam_slot)
        #TODO:move detector to the 1st position and setROI
        get_beamline().setWAXSpos(total_angle=0, roi=cms.XR_pos1)
        get_beamline().setXRROI(total_angle=0,size=roi_size,default_WAXSy=None)
        self.measure(exposure_time, extra='direct_beam')
        self.yo()
        
        output_data = self.XR_data_output(direct_beam_slot, exposure_time)
        #output_data = output_data.iloc[0:0]

        #create a data file to save the XRR data
        if output_file is None:
            header = db[-1]
            #XR_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , header.get('start').get('scan_id')+1)
            #XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], header.get('start').get('scan_id')+1)
            #XR_FILENAME='{}/data/{}_{}.csv'.format(header.start['experiment_alias_directory'],header.start['sample_name'], header.get('start').get('scan_id')+1)
            XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], header.start['filename'])   
            print('FILENAME= {}'.format(XR_FILENAME))
        else:
            XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], output_file)            

        #load theta positions in scan
        if scan_type == 'theta_scan':
            #list the sth positions in scan
            if theta_list==None:
                theta_list=np.arange(theta_range[0], theta_range[1], theta_delta)
            else:
                theta_list = theta_list
            
            #
            '''
            if np.size(theta_range) == 2:
                theta_list=np.arange(theta_range[0], theta_range[1], theta_delta)
            #multiple sections for measurement
            else: 
                theta_list=[]
                if np.shape(theta_range)[0] != np.size(theta_delta):
                    print("The theta_range does not match theta_delta")
                    return
                if np.shape(theta_range)[-1] != 2:
                    print("The input of theta_range is incorrect.")
                    return                
                for number, item in enumerate(theta_range):
                    theta_list_temp = np.arange(item[0], item[1], theta_delta[number])
                    theta_list.append(theta_list_temp)
                theta_list = np.hstack(theta_list)
            
            '''
        elif scan_type == 'qz_scan':
            if qz_list is not None:
                qz_list = qz_list
            else:
               qz_list = self.qz_list_default
            theta_list = np.rad2deg(np.arcsin(qz_list * header.start['calibration_wavelength_A']/4/np.pi))

       
        pos_flag = 0
        for theta in theta_list:

            self.thabs(theta)
            #get_beamline().setSpecularReflectivityROI(total_angle=theta*2,size=roi_size,default_SAXSy=-73)
            
            #if cms.out_of_beamstop(total_angle=theta*2, size=roi_size):
            if cms.beamOutXR(total_angle=theta*2,roi=cms.XR_pos2)==False:
                get_beamline().setWAXSpos(total_angle=0, roi=cms.XR_pos1)
                get_beamline().setXRROI(total_angle=theta*2,size=roi_size)
                print('WAXS in POS1 for XR')
            elif pos_flag == 0:
                get_beamline().setWAXSpos(total_angle=0, roi=cms.XR_pos2)
                get_beamline().setXRROI(total_angle=theta*2,size=roi_size)
                print('WAXS in POS2 for XR')
                pos_flag=1
            else: 
                get_beamline().setXRROI(total_angle=theta*2,size=roi_size)
                print('WAXS in POS2 for XR')
                pos_flag=1
                
            self.measure(exposure_time, extra=extra)
            temp_data = self.XR_data_output(slot_pos, exposure_time)
            print('data = {}'.format(temp_data))
            #initial exposure period
            N = 1
            N_last = 1
            if threshold is not None and type(threshold) == int :                    
                while temp_data['e_I1'][temp_data.index[-1]] < threshold and N < max_exposure_time:   
                    if slot_pos > 0:
                        if temp_data['e_I1'][temp_data.index[-1]] < threshold: #The count is too small to evaluate the next slot_pos.
                            slot_pos = slot_pos - 1
                        else:
                           slot_current = beam.absorber_transmission_list[slot_pos]*threshold/temp_data['e_I1'][temp_data.index[-1]]
                           for slot_no in np.arange(5, 0, -1):
                               if slot_current > beam.absorber_transmission_list[slot_no]:
                                   slot_pos = slot_no - 1 
                              
                        beam.setAbsorber(slot_pos)
                        print('The absorber is slot {}\n'.format(slot_pos))
                        print('The theta is {}\n'.format(theta))
                        self.measure(exposure_time, extra=extra)
                        temp_data = self.XR_data_output(slot_pos, exposure_time)
                    else:
                        if threshold/float(temp_data['e_I1'][temp_data.index[-1]]) < max_exposure_time and N_last < max_exposure_time:
                            N = np.ceil(N_last*threshold/float(temp_data['e_I1'][temp_data.index[-1]]))
                            print('e_I1={}'.format(float(temp_data['e_I1'][temp_data.index[-1]])))
                            print('N={}'.format(N))
                            print('exposure time  = {}'.format(N*exposure_time))
                        else:  
                            N = max_exposure_time
                            print('exposure time is MAX')
                        print('The absorber is slot {}\n'.format(slot_pos))
                        print('The theta is {}\n'.format(theta))


                        self.measure(N*exposure_time, extra=extra)                        
                        temp_data = self.XR_data_output(slot_pos, N*exposure_time)
                        N_last = N
                        
            elif len(threshold)>1 and temp_data['e_I1'][temp_data.index[-1]] > threshold[-1]:
                slot_pos = slot_pos+1
                print('The absorber is slot {}\n'.format(slot_pos))
                print('The theta is {}\n'.format(theta))
                beam.setAbsorber(slot_pos)
                self.measure(exposure_time, extra=extra)
                temp_data = self.XR_data_output(slot_pos, exposure_time)


            output_data = output_data.append(temp_data, ignore_index=True)    
            #save to file 
            output_data.to_csv(XR_FILENAME)
        
        #reset the changed items
        bec.enable_plots()
        #bec.enable_table()
        self.naming_scheme = self.naming_scheme_hold
        #remove the absorber completely out of the beam
        beam.absorber_out()

    def XR_abort(self):        
        '''Reset the beamline status back to origin before XRR measurement.
        '''        
        beam.off()        
        cms.modeMeasurement()
        beam.setAbsorber(0)
        #remove the absorber completely out of the beam
        beam.absorber_out()
        
        self.xo()
        self.yo()
        self.tho()

        bec.enable_plots()
        bec.enable_table()
        pilatus_name.hints = {'fields': ['pilatus800_stats3_total', 'pilatus800_stats4_total']}

        
    def XR_data_output(self, slot_pos, exposure_time):
        '''XRR data output in DataFrame format, including: 
                        'a_qz': qz,                  #qz
                        'b_th':sth_pos,              #incident angle 
                        'c_scanID': scan_id,         #scan ID
                        'd_I0': I0,                  #bim5 flux
                        'e_I1': I1,                  #ROI1
                        'f_I2': I2,                  #ROI2
                        'g_I3': I3,                  #2*ROI1-ROI2
                        'h_In': In,                  #reflectivity
                        'i_absorber_slot': slot_pos, #absorption slot No.
                        'j_exposure_seconds': exposure_time}   #exposure time
        '''
        
        h = db[-1]
        dtable = h.table()
        
        #beam.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]

        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_13p5kev

        #Energy = 17kev
        elif abs(beam.energy(verbosity=1)-17) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_17kev

        elif abs(beam.energy(verbosity=1)-10) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_10kev        
        else: 
            print("The absorber has not been calibrated under current Energy!!!")
            
            
        sth_pos = h.start['sample_th']
        qz = 4*np.pi*np.sin(np.deg2rad(sth_pos))/h.start['calibration_wavelength_A']
        scan_id = h.start['scan_id']     
        I0 = h.start['beam_int_bim5']  #beam intensity from bim5
        I1 = dtable.pilatus800_stats1_total
        I2 = dtable.pilatus800_stats2_total
        I3 = 2*dtable.pilatus800_stats1_total - dtable.pilatus800_stats2_total
        In = I3 / beam.absorber_transmission_list[slot_pos] / exposure_time

        current_data = {'a_qz': qz,                  #qz
                        'b_th':sth_pos,              #incident angle 
                        'c_scanID': scan_id,         #scan ID
                        'd_I0': I0,                  #bim5 flux
                        'e_I1': I1,                  #ROI1
                        'f_I2': I2,                  #ROI2
                        'g_I3': I3,                  #2*ROI1-ROI2
                        'h_In': In,                  #reflectivity
                        'i_absorber_slot': slot_pos, #absorption slot No.
                        'j_exposure_seconds': exposure_time}   #exposure time

        return pds.DataFrame(data=current_data)
        
    def XR_align(self, step=0, reflection_angle=0.15, verbosity=3):
        '''Specific alignment for XRR
        
        Align the sample with respect to the beam. XR alignment involves
        vertical translation to the beam center, and rocking theta to get the
        sample plane parralel to the beam. Finally, the angle is re-optimized
        in reflection mode.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''

        
        #

        if verbosity>=4:
            print('  Aligning {}'.format(self.name))
        
        if step<=0:
            cms.modeXRAlignment()
            cms.modeAlignment()
            beam.setTransmission(1e-4)
            detselect(pilatus2M)
            # Prepare for alignment
            if RE.state!='idle':
                RE.abort()
            if get_beamline().current_mode!='alignment':
                if verbosity>=2:
                    print("WARNING: Beamline is not in alignment mode (mode is '{}')".format(get_beamline().current_mode))
                #get_beamline().modeAlignment()
            get_beamline().setDirectBeamROI()
            beam.on()
        
        if step<=2:
            if verbosity>=4:
                print('    align: searching')
                
            # Estimate full-beam intensity
            value = None
            if True:
                # You can eliminate this, in which case RE.md['beam_intensity_expected'] is used by default
                self.yr(-2)
                #detector = gs.DETS[0]
                detector = get_beamline().detector[0]
                value_name = get_beamline().TABLE_COLS[0]
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                self.yr(+2)
            
            if 'beam_intensity_expected' in RE.md and value<RE.md['beam_intensity_expected']*0.75:
                print('WARNING: Direct beam intensity ({}) lower than it should be ({})'.format(value, RE.md['beam_intensity_expected']))
                
            # Find the step-edge
            self.ysearch(step_size=0.5, min_step=0.005, intensity=value, target=0.5, verbosity=verbosity, polarity=-1)
            
            # Find the peak
            self.thsearch(step_size=0.4, min_step=0.01, target='max', verbosity=verbosity)
        
        
        if step<=4:
            if verbosity>=4:
                print('    align: fitting')
            
            fit_scan(smy, 1.2, 21, fit='HMi')
            #time.sleep(2)
            fit_scan(sth, 1.5, 21, fit='max')
            #time.sleep(2)            
            
        if step<=8:
            
            #fit_scan(smy, 0.6, 21, fit='sigmoid_r')
            
            fit_edge(smy, 0.6, 21)
            #time.sleep(2)
            #fit_edge(smy, 0.4, 21)
            fit_scan(sth, 0.8, 21, fit='COM')
            #time.sleep(2)            
            self.setOrigin(['y', 'th'])
        
        
        if step<=9 and reflection_angle is not None:
            # Final alignment using reflected beam
            if verbosity>=4:
                print('    align: reflected beam')
                
            if abs(beam.energy(verbosity)-17)<0.1:
                reflection_angle = 0.15

            get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0)
            #get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0, size=[12,2])
            
            self.thabs(reflection_angle)
            
            result = fit_scan(sth, 0.1, 41, fit='max') 
            #result = fit_scan(sth, 0.2, 81, fit='max') #it's useful for alignment of SmarAct stage
            sth_target = result.values['x_max']-reflection_angle
            
            if result.values['y_max']>50:
                th_target = self._axes['th'].motor_to_cur(sth_target)
                self.thsetOrigin(th_target)

            #fit_scan(smy, 0.2, 21, fit='max')
            #self.setOrigin(['y'])            

        if step<=10:
            self.thabs(0.0)
            beam.off()
            detselect(pilatus800)

    def XR_check_alignment(self, th_angle=1, exposure_time=1, roi_size=[10, 10]):
        ''' Check the alignment of the XR.
        The total_angle is the incident angle. 
        The reflection spot should be located in the center of ROI2'''
        cms.modeXRMeasurement()
        #TODO: set a default position
        get_beamline().setWAXSpos(total_angle=0, roi=cms.XR_pos2)
        get_beamline().setXRROI(total_angle=th_angle*2,size=roi_size)
        #sam.xo()
        sam.yo()
        sam.thabs(th_angle)
        sam.measure(exposure_time)
        print('===========sam.th moves to {}deg and ROI1 is set at {}deg. ============'.format(th_angle, th_angle*2))
        print('======Please check the ROI whether at the reflected position. =======')
        print('========If not, modify sam.th or schi to meet the reflected beam. ===========')

    #define a theta-2theta scan by rotating sample by sth and accordingly changing roi1 and roi2 at 2theta position
    
    def th2thscan(self, scan_type='theta_scan', theta_range=[1,4], theta_delta=0.1, qz_list=None, roi_size=[10,10], exposure_time=1, threshold=20000, max_exposure_time=10, extra='th2th_scan', output_file=None):
        ''' Run x-ray reflectivity measurement for thin film samples on WAXS pilatus800k. 
        There will be two WAXSy positions for XR. 
        The 1st position is the beam shining directly on the detector with maximum attenuation.
        This position is defined by cms.WAXS.setCalibration([734, 1090],0.255, [-65, -73])
        The 2nd position is the beam out of the WAXS detector. 
        The detector will be moved to the 2nd position when the reflected beam out of beam stop. 
        
        Parameters
        ----------
        scan_type : list
            theta_scan: in step of theta
            q_scan: in step of q
            
        theta_range: list 
            The scanning range. It can be single section or multiple sections with various step_size.
            Examples:  
            [0, 1.6] or 
            [[0, .3],[0.3, 1], [1, 1.6]]                    
        theta_delta: float or list
            The scaning step. Examples:
            0.02    or
            [0.005, 0.1, 0.2]
        roi_size: float
            The szie of ROI1.
        exposure_time: float
            The mininum exposure time
        min_step : float
            The final (minimum) step size to try
        intensity : float
            The expected full-beam intensity readout
        threshold : float
            The threshold of minimum intensity. Exposure time increases automatically if < max_exposure_time 
        max_exposure_time : float
            The maximum of exposure time to limit the total time.
 
        '''
        #TODO:
        
        
        [theta_start, theta_end] = theta_range
        if theta_end < theta_start:
            print("The theta_end is larger than theta_start!!!")
        if theta_start<.25:
            print("For th2th scan, the start of the scan has to be larger than 0.5deg")
            return 
        
        #disable the besteffortcallback and plot all ROIs
        #bec.disable_table()
        cms.modeXRMeasurement()
        cms.definePos(size=roi_size)
        
        bec.disable_plots()
        
        
        cms.WAXS.detector.stats1.total.kind = 'hinted'
        cms.WAXS.detector.stats2.total.kind = 'hinted'

        self.naming_scheme_hold = self.naming_scheme
        self.naming_scheme = ['name', 'extra', 'th', 'exposure_time']
        #default_WAXSy = WAXSy.position
        
        #move in absorber and move out the beamstop
        slot_pos = 6
        beam.setAbsorber(slot_pos)
        if beam.absorber()[0]>=4:
            bsx.move(bsx.position+6)
            beam.setTransmission(1)
        
        #create a clean dataframe and a direct beam images
        self.yr(-2)
        self.tho()
        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:
            direct_beam_slot = 4
        #Energy = 17kev
        if abs(beam.energy(verbosity=1)-17) < 0.1:
            direct_beam_slot = 5
            slot_pos = 5
        beam.setAbsorber(direct_beam_slot)
        #move detector to the 1st position and setROI
        get_beamline().setWAXSpos(total_angle=0, roi=cms.XR_pos1)
        get_beamline().setXRROI(total_angle=0,size=roi_size,default_WAXSy=None)
        self.measure(exposure_time, extra='direct_beam')
        self.yo()
        #move detector to POS2 and start the th2th scan
        get_beamline().setWAXSpos(total_angle=0, roi=cms.XR_pos2)
        
        output_data = self.XR_data_output(direct_beam_slot, exposure_time)
        #output_data = output_data.iloc[0:0]

        #create a data file to save the XRR data
        if output_file is None:
            header = db[-1]
            #XR_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , header.get('start').get('scan_id')+1)
            #XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], header.get('start').get('scan_id')+1)
            th2th_FILENAME='{}/data/{}_{}.csv'.format(header.start['experiment_alias_directory'],header.start['sample_name'], header.get('start').get('scan_id')+1)
        else:
            th2th_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], output_file)            

        #load theta positions in scan
        if scan_type == 'theta_scan':
            #list the sth positions in scan
            theta_list=np.arange(theta_start, theta_end+0.001, theta_delta)
        elif scan_type == 'qz_scan':
            if qz_list is not None:
                qz_list = qz_list
            else:
               qz_list = self.qz_list_default
            theta_list = np.rad2deg(np.arcsin(qz_list * header.start['calibration_wavelength_A']/4/np.pi))

       
        pos_flag = 0
        for theta in theta_list:

            self.thabs(theta)
            #th2th scan starts with POS2 directly
            get_beamline().setXRROI_update(total_angle=theta*2,size=roi_size)
                
            self.measure(exposure_time, extra=extra)
            temp_data = self.XR_data_output(slot_pos, exposure_time)
            
            #initial exposure period
            if threshold is not None and type(threshold) == int :                    
                if slot_pos > 0:
                    if temp_data['e_I1'][temp_data.index[-1]] < 10: #The count is too small to evaluate the next slot_pos.
                        slot_pos = slot_pos - 1
                    else:
                        slot_current = beam.absorber_transmission_list[slot_pos]*threshold/temp_data['e_I1'][temp_data.index[-1]]
                        for slot_no in np.arange(5, 0, -1):
                            if slot_current > beam.absorber_transmission_list[slot_no]:
                                slot_pos = slot_no - 1 
                            
                    beam.setAbsorber(slot_pos)
                    print('The absorber is slot {}\n'.format(slot_pos))
                    print('The theta is {}\n'.format(theta))
                    self.measure(exposure_time, extra=extra)
                    temp_data = self.XR_data_output(slot_pos, exposure_time)
                #else:
                    ##self.measure(exposure_time, extra=extra)                        
                    #temp_data = self.XR_data_output(slot_pos, exposure_time)
                        
            elif len(threshold)>1 and temp_data['e_I1'][temp_data.index[-1]] > threshold[-1]:
                slot_pos = slot_pos+1
                print('The absorber is slot {}\n'.format(slot_pos))
                print('The theta is {}\n'.format(theta))
                beam.setAbsorber(slot_pos)
                self.measure(exposure_time, extra=extra)
                temp_data = self.XR_data_output(slot_pos, exposure_time)


            output_data = output_data.append(temp_data, ignore_index=True)    
            #save to file 
            output_data.to_csv(th2th_FILENAME)
        
        #reset the changed items
        bec.enable_plots()
        #bec.enable_table()
        self.naming_scheme = self.naming_scheme_hold
        #remove the absorber completely out of the beam
        beam.absorber_out()

class SampleGonio_Generic(SampleGISAXS_Generic):
    '''Goniometer stage made by SmarAct
    '''
    def __init__(self, name='Goniometer', base=None, **md):
       
       super().__init__(name=name, base=base, **md)
       self._axes['x'].origin = -17.7
       self._axes['y'].origin = 9

    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        super()._set_axes_definitions()
        # The _axes_definitions array holds a list of dicts, each defining an axis
        self._axes_definitions.append = [ {'name': 'phi',
                            'motor': srot,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'deg',
                            'hint': None,
                            },
                            {'name': 'trans',
                            'motor': strans,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': None,
                            },
                            {'name': 'trans2',
                            'motor': strans2,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': None,
                            },
                            ]              
     

class SampleSecondStage(SampleGISAXS_Generic):
    ''' The second sample stage with the large open space
        Note: steps to initiallize it. 
        1. Break vacuum of both chamber and pipe. 
        2. Remove the connected tubing and 
        3. open 10-motors.py. set beamline_stage = 'open_MAXS' 
    '''
    def __init__(self, name, base=None, **md):
        
       super().__init__(name=name, base=base, **md)
       self._axes['x'].origin = -1.9
       self._axes['y'].origin = 18.97
       self._axes['th'].origin = 0.348 

# custmer-made holders

class GIBar(PositionalHolder):
    '''This class is a sample bar for grazing-incidence (GI) experiments.'''
    
    # Core methods
    ########################################

    def __init__(self, name='GIBar', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        
        self.xsetOrigin(-71.89405)
        #self.ysetOrigin(10.37925)
        self.ysetOrigin(5.38)
        
        self.mark('right edge', x=+108.2)
        self.mark('left edge', x=0)
        self.mark('center', x=54.1, y=0)
             
        #measurement measure_settings
        self.detector=None
        self.exposure_time = None
        self.incident_angles = None
        self.tiling = None
        self.measure_setting={}
        
    def _backup_addSampleSlotPosition(self, sample, slot, position, detector_opt='SAXS', incident_angles=None, account_substrate=True, exposure_time=None, thickness=0):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        super().addSampleSlotPosition(sample=sample, slot=slot, position=position, detector_opt=detector_opt, incident_angles=incident_angles)

        # Adjust y-origin to account for substrate thickness
        if account_substrate and 'substrate_thickness' in sample.md:
            sample.ysetOrigin( -1.0*sample.md['substrate_thickness'] )
        
        sample.detector=detector_opt
        sample.exposure_time=exposure_time
        sample.thickness=exposure_time

        # Adjust y-origin to account for substrate thickness
        if thickness !=0:
            sample.ysetOrigin( -1.0*thickness )

    def addSampleSlotPosition(self, sample, slot, position, detector_opt=None, incident_angles=None, exposure_time=None, tiling=None, thickness=0):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        super().addSampleSlotPosition(sample=sample, slot=slot, position=position, detector_opt=detector_opt, incident_angles=incident_angles)
        # Adjust y-origin to account for substrate thickness
        if thickness !=0:
            sample.ysetOrigin( -1.0*thickness )
        
        if detector_opt==None:
            sample.measure_setting['detector'] = self.detector
        else: 
            sample.measure_setting['detector'] = detector_opt
        if exposure_time==None:
            sample.measure_setting['exposure_time'] = self.exposure_time
        else:
            sample.measure_setting['exposure_time'] = exposure_time
        if incident_angles==None:
            sample.measure_setting['incident_angles'] =self.incident_angles
        else:
            sample.measure_setting['incident_angles'] =incident_angles
        if tiling==None:
            sample.measure_setting['tiling'] = self.tiling
        else:
            sample.measure_setting['tiling'] = tiling
    
    def setMeasure(self, detector, incident_angles, exposure_time, tiling):
        '''define the measurement setting for the holder, including:
        detector:  'SAXS', 'WAXS', or 'BOTH';
        incident_angles: [0.05, 0.10.2];
        exposure_time: in second, corresponding to the detector setting;
        tiling: 'x', 'y', 'xy', None
        
        '''
        if detector == 'BOTH':
            detector = ['SAXS', 'WAXS']
            if type(exposure_time) == int:
                exposure_time = [exposure_time, exposure_time]
        self.measure_setting['detector'] = detector
        self.measure_setting['incident_angles'] = incident_angles
        self.measure_setting['exposure_time'] = exposure_time
        self.measure_setting['tiling'] = tiling
        self.detector = detector
        self.incident_angles = incident_angles
        self.exposure_time = exposure_time
        self.tiling = tiling
        
        return self.measure_setting
    
    def alignSamples(self, range=None, step=0, align_step=0, x_offset=0, verbosity=3, **md):
        '''Iterates through the samples on the holder, aligning each one.'''
        
        if step<=0:
            get_beamline().modeAlignment()
        
        
        if step<=5:
            for sample in self.getSamples(range=range):
                sample.gotoOrigin(['x','y','th'])
                sample.gotoOrigin(['x'])
                sample.xr(x_offset)
                sample.align(step=align_step, reflection_angle=0.12)
            
            
        if step<=10:
            if verbosity>=3:
                print('Alignment complete.')
                for i, sample in enumerate(self.getSamples()):
                    print('Sample {} ({})'.format(i+1, sample.name))
                    print(sample.save_state())


    def alignSamplesQuick(self, range=None, step=0, x_offset=0, verbosity=3, **md):
        '''Iterates through the samples on the holder, aligning each one.'''
        
        if step<=0:
            get_beamline().modeAlignment()
        
        
        if step<=5:
            for sample in self.getSamples(range=range):
                sample.gotoOrigin(['x','y','th'])
                sample.gotoOrigin(['x'])
                sample.xr(x_offset)
                sample.alignQuick(reflection_angle=0.12) #=0.07)
            
            
        if step<=10:
            if verbosity>=3:
                print('Alignment complete.')
                for i, sample in enumerate(self.getSamples()):
                    print('Sample {} ({})'.format(i+1, sample.name))
                    print(sample.save_state())
                

    def alignSamplesVeryQuick(self, range=None, step=0, x_offset=0, verbosity=3, **md):
        '''Iterates through the samples on the holder, aligning each one.'''
        
        if step<=0:
            get_beamline().modeAlignment()
            beam.on()
            caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquireTime', 0.25)
            caput('XF:11BMB-ES{Det:SAXS}:cam1:AcquirePeriod', 0.30)
        
        
        if step<=5:
            for sample in self.getSamples(range=range):
                sample.gotoOrigin(['x','y','th'])
                sample.gotoOrigin(['x'])
                sample.xr(x_offset)
                sample.alignVeryQuick(intensity=INTENSITY_EXPECTED_025, mode_control=False)

        if step<=8:
            beam.off()                
             
        if step<=10:
            if verbosity>=3:
                print('Alignment complete.')
                for i, sample in enumerate(self.getSamples()):
                    print('Sample {} ({})'.format(i+1, sample.name))
                    print(sample.save_state())
                

                
    def measureSamples(self, range=None, step=0, angles=None, exposure_time=15, x_offset=0, verbosity=3, **md):
        '''Measures all the samples.
        
        If the optional range argument is provided (2-tuple), then only sample
        numbers within that range (inclusive) are run. If range is instead a 
        string, then all samples with names that match are returned.'''

        if step<=0:
            get_beamline().modeMeasurement()

        if step<=5:
            for sample in self.getSamples(range=range):
                if verbosity>=3:
                    print('Measuring sample {}...'.format(sample.name))
                
                sample.gotoOrigin(['x','y','th'])
                sample.gotoOrigin(['x'])
                sample.xr(x_offset)
                sample.measureIncidentAngles(angles=angles, verbosity=verbosity, exposure_time=exposure_time, **md)
            
    def printSaveStates(self, range=None, verbosity=3, **md):
        
        if range is None:
            range_start = 0
        else:
            range_start = range[0]
        
        save_string = 'origins = [\n'
        
        for i, sample in enumerate(self.getSamples(range=range)):
            
            sample_id = range_start + i + 1
            
            save_string += '    {} , # Sample {}\n'.format(sample.save_state(), sample_id)
            #save_string += '    {} , # Sample {} ({})\n'.format(sample.save_state(), sample_id, sample.name)
            
            
        save_string += '    ]\n'
        save_string += 'for origin, sample in zip(origins, hol.getSamples()):\n'
        save_string += '    sample.restore_state(origin)\n'
        
        print(save_string)
             
    def _backup_doSamples(self, range=None, verbosity=3):

        #saxs_on()
        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if sample.detector=='SAXS' or sample.detector=='BOTH':
                sample.do_SAXS()

        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if sample.detector=='BOTH':
                sample.do_WAXS_only()

        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if sample.detector=='WAXS':
                sample.do_WAXS()    

    def doSamples(self, range=None, verbosity=3):

        #saxs_on()
        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if 'SAXS' in sample.detector or sample.detector=='BOTH':
                sample.do_SAXS()

        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if 'SAXS' in sample.detector and 'WAXS' in sample.detector:
                sample.do_WAXS_only()
            elif sample.detector=='BOTH':
                sample.do_WAXS_only()
                
        for sample in self.getSamples(range=range):
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if sample.detector=='WAXS':
                sample.do_WAXS()    
                
    def doSamples_Stitch(self, angles=None, exposure_time=None, extra=None, tiling=None, verbosity=3, **md):
        
        if exposure_time == None:
            exposure_time = self.exposure_time

        #measure the incident angles first and then change the tiling features. 
        if tiling == None:
            if angles is None:
                if sample.incident_angles==None:
                    incident_angles = self.incident_angles_default
                else:
                    incident_angles = self.incident_angles
            for angle in angles:
                self.measureIncidentAngle(angle, exposure_time=exposure_time, extra=extra, tiling=tiling, **md)
                
        elif tiling=='ygaps': 
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value

            #pos1
            for sample in self.getSamples():
                sample.gotoOrigin()
                if angles is None:
                    if sample.incident_angles==None:
                        incident_angles = self.incident_angles_default
                    else:
                        incident_angles = self.incident_angles
                for angle in angles:
                    sample.thabs(angle)
                    time.sleep(.5)
                    extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                    md['detector_position'] = 'lower'
                    sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            #pos2 
            #MAXSy_o = MAXSy.user_readback.value
            if pilatus2M in cms.detector:
                SAXSy.move(SAXSy_o + 5.16)
            if pilatus800 in cms.detector:
                WAXSy.move(WAXSy_o + 5.16)
            if pilatus300 in cms.detector:
                MAXSy.move(MAXSy_o + 5.16)

            for sample in self.getSamples():
                sample.gotoOrigin()
                if angles is None:
                    if sample.incident_angles==None:
                        incident_angles = self.incident_angles_default
                    else:
                        incident_angles = self.incident_angles
                for angle in angles:
                    sample.thabs(angle)
                    time.sleep(.5)
                    extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                    md['detector_position'] = 'upper'
                    sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)    
            #if MAXSy.user_readback.value != MAXSy_o:
                #MAXSy.move(MAXSy_o)                
                
        elif tiling == 'xygaps':
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value

            #pos1 
            for sample in self.getSamples():
                if angles is None:
                    if sample.incident_angles==None:
                        incident_angles = self.incident_angles_default
                    else:
                        incident_angles = self.incident_angles
                        
                sample.gotoOrigin()
                for angle in angles:
                    sample.thabs(angle)
                    time.sleep(.5)
                    extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                    md['detector_position'] = 'lower_left'
                    sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
            
            #pos2
            if pilatus2M in cms.detector:
                SAXSy.move(SAXSy_o + 5.16)
            if pilatus800 in cms.detector:
                WAXSy.move(WAXSy_o + 5.16)
            if pilatus300 in cms.detector:
                MAXSy.move(MAXSy_o + 5.16)
            for sample in self.getSamples():
                sample.gotoOrigin()
                for angle in angles:
                    sample.thabs(angle)
                    time.sleep(.2)
                    extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                    md['detector_position'] = 'upper'
                    sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
               
            #pos4  #comment out to save time
            if pilatus2M in cms.detector:
                SAXSx.move(SAXSx_o + 5.16)
                SAXSy.move(SAXSy.o + 5.16)
            if pilatus800 in cms.detector:
                WAXSx.move(WAXSx_o - 5.16)
                WAXSy.move(WAXSy_o + 5.16)
            for sample in self.getSamples():
                sample.gotoOrigin()
                if angles is None:
                    if sample.incident_angles==None:
                        incident_angles = self.incident_angles_default
                    else:
                        incident_angles = self.incident_angles
                for angle in angles:
                    sample.thabs(angle)
                    time.sleep(.2)
                    extra_current = 'pos4' if extra is None else '{}_pos4'.format(extra)
                    md['detector_position'] = 'upper_right'
                    sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
                  
            #pos3
            if pilatus2M in cms.detector:
                SAXSx.move(SAXSx_o + 5.16)
                SAXSy.move(SAXSy_o)
            if pilatus800 in cms.detector:
                WAXSx.move(WAXSx_o - 5.16)
                WAXSy.move(WAXSy_o)
            for sample in self.getSamples():
                sample.gotoOrigin()
                if angles is None:
                    if sample.incident_angles==None:
                        incident_angles = self.incident_angles_default
                    else:
                        incident_angles = self.incident_angles
                for angle in angles:
                    sample.thabs(angle)
                    time.sleep(.2)
                    extra_current = 'pos3' if extra is None else '{}_pos3'.format(extra)
                    md['detector_position'] = 'lower_right'
                    sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)


            if WAXSx.user_readback.value != WAXSx_o:
                WAXSx.move(WAXSx_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)
            
            if SAXSx.user_readback.value != SAXSx_o:
                SAXSx.move(SAXSx_o)
            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)       


class CapillaryHolder(PositionalHolder):
    '''This class is a sample holder that has 15 slots for capillaries.'''

    # Core methods
    ########################################

    def __init__(self, name='CapillaryHolder', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        
        self.x_spacing = 6.342 # 3.5 inches / 14 spaces
        
        # slot  1; smx = +26.60
        # slot  8; smx = -17.80
        # slot 15; smx = -61.94
        
        # Set the x and y origin to be the center of slot 8
        #self.xsetOrigin(-16.7)
        #self.ysetOrigin(-2.36985)
        #self.ysetOrigin(-2.36985)  
        #self.xsetOrigin(-16.7+-0.3)
        self.ysetOrigin(-1.8)  
        self.xsetOrigin(-17.2)
        
        self.mark('right edge', x=+54.4)
        self.mark('left edge', x=-54.4)
        self.mark('bottom edge', y=-12.71)
        self.mark('center', x=0, y=0)
                
                
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        
        return +1*self.x_spacing*(slot-8)
        
    def measure_Stitch(self, exposure_time=None, extra=None, tiling=None, verbosity=3, **md):
        
        #measure the incident angles first and then change the tiling features. 
        if tiling == None:
            for sample in self.getSamples():
                sample.gotoOrigin()
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
                
        elif tiling=='ygaps': 
            #pos1 
            for sample in self.getSamples():
                sample.gotoOrigin()
                time.sleep(.2)
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower'
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            #pos2 
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value
            #MAXSy_o = MAXSy.user_readback.value

            for sample in self.getSamples():
                sample.gotoOrigin()
                time.sleep(.2)

                if pilatus2M in cms.detector:
                    SAXSy.move(SAXSy_o + 5.16)
                if pilatus800 in cms.detector:
                    WAXSy.move(WAXSy_o + 5.16)
                if pilatus300 in cms.detector:
                    MAXSy.move(MAXSy_o + 5.16)

                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)

            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)    
            #if MAXSy.user_readback.value != MAXSy_o:
                #MAXSy.move(MAXSy_o)                
                
        elif tiling == 'xygaps':
            #pos1 
            for sample in self.getSamples():
                sample.gotoOrigin()
                time.sleep(.2)
                extra_current = 'pos1' if extra is None else '{}_pos1'.format(extra)
                md['detector_position'] = 'lower_left'
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
            
            #pos2
            SAXSy_o = SAXSy.user_readback.value
            SAXSx_o = SAXSx.user_readback.value
            WAXSy_o = WAXSy.user_readback.value
            WAXSx_o = WAXSx.user_readback.value
            #MAXSy_o = MAXSy.user_readback.value

            for sample in self.getSamples():
                sample.gotoOrigin()
                time.sleep(.2)
                if pilatus2M in cms.detector:
                    SAXSy.move(SAXSy_o + 5.16)
                if pilatus800 in cms.detector:
                    WAXSy.move(WAXSy_o + 5.16)
                if pilatus300 in cms.detector:
                    MAXSy.move(MAXSy_o + 5.16)

                extra_current = 'pos2' if extra is None else '{}_pos2'.format(extra)
                md['detector_position'] = 'upper'
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
               
            #pos4  #comment out to save time
            for sample in self.getSamples():
                sample.gotoOrigin()
                time.sleep(.2)

                if pilatus2M in cms.detector:
                    SAXSx.move(SAXSx_o + 5.16)
                    SAXSy.move(SAXSy_o + 5.16)
                if pilatus800 in cms.detector:
                    WAXSx.move(WAXSx_o - 5.16)
                    WAXSy.move(WAXSy_o + 5.16)
                extra_current = 'pos4' if extra is None else '{}_pos4'.format(extra)
                md['detector_position'] = 'upper_right'
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)
                  
            #pos3
            for sample in self.getSamples():
                sample.gotoOrigin()
                time.sleep(.2)

                if pilatus2M in cms.detector:
                    SAXSx.move(SAXSx_o + 5.16)
                    SAXSy.move(SAXSy_o)
                if pilatus800 in cms.detector:
                    WAXSx.move(WAXSx_o - 5.16)
                    WAXSy.move(WAXSy_o)

                extra_current = 'pos3' if extra is None else '{}_pos3'.format(extra)
                md['detector_position'] = 'lower_right'
                sample.measure_single(exposure_time=exposure_time, extra=extra_current, verbosity=verbosity, stitchback=True,**md)


            if WAXSx.user_readback.value != WAXSx_o:
                WAXSx.move(WAXSx_o)
            if WAXSy.user_readback.value != WAXSy_o:
                WAXSy.move(WAXSy_o)
            
            if SAXSx.user_readback.value != SAXSx_o:
                SAXSx.move(SAXSx_o)
            if SAXSy.user_readback.value != SAXSy_o:
                SAXSy.move(SAXSy_o)       
        
    def measureSamples(self, range=None, step=0, angles=None, exposure_time=15, x_offset=0, verbosity=3, **md):
        '''Measures all the samples.
        
        If the optional range argument is provided (2-tuple), then only sample
        numbers within that range (inclusive) are run. If range is instead a 
        string, then all samples with names that match are returned.'''

        if step<=0:
            get_beamline().modeMeasurement()

        if step<=5:
            for sample in self.getSamples(range=range):
                if verbosity>=3:
                    print('Measuring sample {}...'.format(sample.name))
                
                sample.gotoOrigin(['x','y'])
                sample.gotoOrigin(['x'])
                sample.xr(x_offset)
                sample.measureIncident(exposure_time=exposure_time, verbosity=verbosity, **md)

class CapillaryHolderThreeRows(CapillaryHolder):
    '''This class is a sample holder that has 15x3 slots for transmission geometry.'''

    # Core methods
    ########################################

    def __init__(self, name='CapillaryHolderThreeRows', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        # Set the x and y origin to be the center of slot 8
        
        self.mark('right edge', x=+54.4)
        self.mark('left edge', x=-54.4)
        self.mark('bottom edge', y=-12.71)
        self.mark('center', x=0, y=0)

        self._positional_axis = ['x','y']

        self._axes['y'].origin = -1.8  #The origin is the #8 hole in the top row
        self._axes['x'].origin = -16.9
        
        self.x_spacing = 6.342 # 3.5 inches / 14 spaces
        self.y_spacing = 0.25*25.4 # 2.5 inches / 14 spaces

        
    # def _set_axes_definitions(self):
    #     '''Internal function which defines the axes for this stage. This is kept
    #     as a separate function so that it can be over-ridden easily.'''
        
    #     # The _axes_definitions array holds a list of dicts, each defining an axis
    #     super()._set_axes_definitions()

    #     self._axes_definitions.append ( {'name': 'yy',
    #                         'motor': smy2,
    #                         'enabled': True,
    #                         'scaling': +1.0,
    #                         'units': 'mm',
    #                         'hint': 'positive moves stage up',
    #                         } )
                        

    def slot(self, sample_number):
        '''Moves to the selected slot in the holder.'''
        
        getattr(self, self._positional_axis[0]+'abs')( self.get_slot_position(sample_number) )
        
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        # This is the critical to define the position for the 10 samples. 
        
        position_y = int((slot-1)/15)
        position_x = (slot-1)%15-7

        return position_x*self.x_spacing,  position_y*self.y_spacing

       
    def addSampleSlot(self, sample, slot):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
 
       
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( ['x'], [self.get_slot_position(slot)[0]] )
        sample.setOrigin( ['y'], [self.get_slot_position(slot)[1]] )



class CapillaryHolderHeated(CapillaryHolder):
    
    def update_sample_names(self):
        
        for sample in self.getSamples():
            if 'temperature' not in sample.naming_scheme:
                sample.naming_scheme.insert(-1, 'temperature')

    def doHeatCool(self, heat_temps, cool_temps, exposure_time=None, stabilization_time=120, temp_tolerance=0.5, step=1):
        if step<=1:
            for temperature in heat_temps:
                try:
                    self.setTemperature(temperature)
                    
                    while self.temperature(verbosity=0) < temperature-temp_tolerance:
                        time.sleep(5)
                    time.sleep(stabilization_time)
                    
                    for sample in self.getSamples():
                        sample.gotoOrigin()
                        sample.xr(-0.05)
                        sample.measure(exposure_time)
                        
                except HTTPError:
                    pass


        if step<=5:
            
            for temperature in heat_temps:
                try:
                    self.setTemperature(temperature)
                
                    self.setTemperature(temperature)
                
                    while self.temperature(verbosity=0) > temperature+temp_tolerance:
                        time.sleep(5)
                    time.sleep(stabilization_time)

                    for sample in self.getSamples():
                        sample.gotoOrigin()
                        sample.xr(0.1)
                        sample.measure(exposure_time)
                        
                except HTTPError:
                    pass
        
class GIBar_long_thermal(GIBar):
    '''This class is a sample bar with heating/cooling feature and 6" long bar for grazing-incidence (GI) experiments.'''
    
    # Core methods
    ########################################

    def __init__(self, name='GIBar', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        
        # Set the x and y origin to be the center of slot 8

        #self.xsetOrigin(-71.89405-22.1) # TODO: Update this value
        #self._axes['y'].origin = 7.06
        self._axes['y'].origin = 2.06
        
        self.mark('right edge', x=+152.4)
        self.mark('left edge', x=0)
        self.mark('center', x=76.2, y=0)

    def alignSamples(self, step=0, align_step=0, verbosity=3, **md):
    
        for sample in self.getSamples():
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))

            if step<=1:
                saxs_on()
                get_beamline().modeAlignment()
                
            if step<=2:
                sample.xo() # goto origin
            if step<=4:
                sample.yo()
                sample.tho()
            
            if step<=5:
                sample.align(step=align_step)   


    def alignSamples_Custom(self, step=0, align_step=8, verbosity=3, **md):
    
        #first_sample = self.getSamples()
        #hol_xcenter = 4.3*25.4/2
        cali_sample = self.getSample(1) 

        sample_pos_list = []
        
        for sample in self.getSamples():
            sample_pos_list.append(sample.position)
        hol_xcenter = min(sample_pos_list)/2+max(sample_pos_list)/2
        
        print(sample_pos_list)
        
        #locate the sample for alignning the holder
        for sample in self.getSamples():
            if abs(sample.position-hol_xcenter) < abs(cali_sample.position-hol_xcenter):
                cali_sample = sample
            print('The current calibraion sample is {}'.format(cali_sample.name))

        print('The calibraion sample is {}'.format(cali_sample.name))
                
        #full alignment on cali_sample
        #cali_sample.align()
        if verbosity>=3:
            print('Doing holder on sample {}...'.format(cali_sample.name))

        saxs_on()
        get_beamline().modeAlignment()
        
        cali_sample.xo() # goto origin
        cali_sample.yo()
        cali_sample.tho()
        cali_sample.align(step=0)           
        
        cali_sample.xo()
        cali_sample.yo()
        cali_sample.tho()
        
        for sample in self.getSamples():
            sample.setOrigin(['th', 'y'])
        
        for sample in self.getSamples():
            if verbosity>=3:
                print('Doing sample {}...'.format(sample.name))
            if step<=1:
                saxs_on()
                get_beamline().modeAlignment()
            if step<=2:
                sample.xo() # goto origin
                sample.yo()
                sample.tho()
            
            if step<=5:
                sample.align(step=align_step)   


    def measureSamples(self, det='SWAXS', tiling=None, verbosity=3, **md):
        
        cms.modeMeasurement()
        
        if det == 'SAXS':
            saxs_on()
            for sample in self.getSamples():
                sample.gotoOrigin()
                
                if sample.incident_angles==None:
                    incident_angles = sample.incident_angles_default
                else:
                    incident_angles = sample.incident_angles
                
                sample.measureIncidentAngles_Stitch(incident_angles, exposure_time=sample.SAXS_time, tiling=tiling, **md)

        elif det == 'WAXS':
            waxs_on() # edited from waxs_on 3/25/19 through a saxs_on error
            for sample in self.getSamples():
                sample.gotoOrigin()
                
                if sample.incident_angles==None:
                    incident_angles = sample.incident_angles_default
                else:
                    incident_angles = sample.incident_angles
                #for detector in get_beamline().detector:
                    #detector.setExposureTime(self.MAXS_time)
                sample.measureIncidentAngles_Stitch(incident_angles, exposure_time=sample.WAXS_time, tiling=tiling, **md)
                
                sample.gotoOrigin()

        elif det == 'SWAXS':

            swaxs_on()
            for sample in self.getSamples():
                sample.gotoOrigin()
                
                if sample.incident_angles==None:
                    incident_angles = sample.incident_angles_default
                else:
                    incident_angles = sample.incident_angles
                
                sample.measureIncidentAngles_Stitch(incident_angles, exposure_time=sample.SWAXS_time, tiling=tiling, **md)
                
        elif det == 'BOTH':

            saxs_on()
            for sample in self.getSamples():
                sample.gotoOrigin()
                
                if sample.incident_angles==None:
                    incident_angles = sample.incident_angles_default
                else:
                    incident_angles = sample.incident_angles
                
                sample.measureIncidentAngles_Stitch(incident_angles, exposure_time=sample.SAXS_time, tiling=tiling, **md)
            waxs_on() # edited from waxs_on 3/25/19 through a saxs_on error
            for sample in self.getSamples():
                sample.gotoOrigin()
                
                if sample.incident_angles==None:
                    incident_angles = sample.incident_angles_default
                else:
                    incident_angles = sample.incident_angles
                #for detector in get_beamline().detector:
                    #detector.setExposureTime(self.MAXS_time)
                sample.measureIncidentAngles_Stitch(incident_angles, exposure_time=sample.WAXS_time, tiling=tiling, **md)
                
                sample.gotoOrigin()

        else:
            print('Wrong det input. Options are SAXS/WAXS/SWAXS/BOTH')
            
    def doTemperatures(self, temperature_list=None, output_file='Transmission_output', int_measure=False, wait_time=600, WAXS_expo_time=5, temperature_probe='A', output_channel='1', temperature_tolerance=1, range=None, verbosity=3, poling_period=2.0, **md):

        #cms.modeMeasurement()
        if temperature_list==None:
            temperature_list = self.temperature_list
            
            
        for index, temperature in enumerate(temperature_list):
            # Set new temperature
            #self.setTemperature(temperature, output_channel=output_channel, verbosity=verbosity)
            
            # Wait until we reach the temperature
            #while abs(self.temperature(verbosity=0) - temperature)>temperature_tolerance:
            while abs(self.temperature(temperature_probe=temperature_probe, verbosity=0) - temperature)>temperature_tolerance:
                if verbosity>=3:
                    print('  setpoint = {:.3f}°C, Temperature = {:.3f}°C          \r'.format(self.temperature_setpoint()-273.15, self.temperature(temperature_probe=temperature_probe, verbosity=0)), end='')
                time.sleep(poling_period)
                
            # Allow for additional equilibration at this temperature
            
            if index%4 == 0:
                self.alignSamples_Custom()
                #self.alignSamples()
            elif wait_time is not None:
                time.sleep(wait_time)
                
            post_to_slack('set to Temperature {}'.format(temperature))
            self.measureSamples()
            #self.doSamples(SAXS_expo_time=SAXS_expo_time, verbosity=verbosity, **md)
            if int_measure:
                self.intMeasure(output_file=output_file)   

        self.setTemperature(25)

class GIBar_Linkam(GIBar):
    '''This class is a sample bar with heating/cooling feature and 6" long bar for grazing-incidence (GI) experiments.'''
    
    # Core methods
    ########################################

    def __init__(self, name='GIBar', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        
        # Set the x and y origin to be the center of slot 8

        #self.xsetOrigin(-71.89405-22.1) # TODO: Update this value
        self._axes['y'].origin = -16.8
        self._axes['y'].origin = 2.06
        

class WellPlateHolder(PositionalHolder):
    '''This class is a sample holder for 96 well plate. 
       row: A--E; column: 1--12
       The sample names are like: 'A1', 'D3', 'E12'
       It uses two stages, smx and smy2 to locate the sample.
       
    '''

    # Core methods
    ########################################

    def __init__(self, name='CapillaryHolder', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = ['x','yy']

        self._axes['y'].origin = -5  #smy stage should be set with the limit [-5.5, -5]
        self._axes['x'].origin = -49.25
        self._axes['yy'].origin = 3.3
        
            
        self.x_spacing = 9 # 9mm seperation both in x and yy direction
        self.yy_spacing = 9 
        
        
    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        super()._set_axes_definitions()

        self._axes_definitions.append ( {'name': 'yy',
                            'motor': smy2,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves stage up',
                            } )
                        

    def slot(self, sample_number):
        '''Moves to the selected slot in the holder.'''
        
        getattr(self, self._positional_axis[0]+'abs')( self.get_slot_position(sample_number) )
        
    
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        # slot is like 'A1', 'D12'
        

        sample_row = ord(slot[0])-ord('A')
        sample_column = int(slot[1:])-1
        #sample_number = sample_row*12 + sample_column
               
        return sample_column*self.x_spacing,  sample_row*self.yy_spacing
        
        
    def addSample(self, sample, sample_number=None):
        '''Add a sample to this holder/bar.'''
        
        if sample_number is None:
            if len(self._samples)==0:
                sample_number = 1
            else:
                ki = [ int(key) for key in self._samples.keys() ]
                sample_number = np.max(ki) + 1
                
                
        if sample_number in self._samples.keys():
            print('Warning: Sample number {} is already defined on holder "{:s}". Use "replaceSample" if you are sure you want to eliminate the existing sample from the holder.'.format(sample_number, self.name) )
            
        else:
            self._samples[sample_number] = sample
            
        self._samples[sample_number] = sample
        
        sample.set_base_stage(self)
        sample.md['holder_sample_number'] = sample_number
        
        
    def addSampleSlot(self, sample, slot):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
 
       
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( ['x'], [self.get_slot_position(slot)[0]] )
        sample.setOrigin( ['yy'], [self.get_slot_position(slot)[1]] )

                
    def listSamplesPositions(self):
        '''Print a list of the current samples associated with this holder/
        bar.'''
        
        for sample_number, sample in self._samples.items():
            pos = getattr(sample, self._positional_axis+'pos')(verbosity=0)
            print( '%s: %s (%s = %.3f)' % (str(sample_number), sample.name, self._positional_axis, pos) )


    def listSamples(self):
        '''Print a list of the current samples associated with this holder/
        bar.'''
         
        for sample_number, sample in sorted(self._samples.items()):
            print( '{}: {:s}'.format(sample_number, sample.name) )
            
            
    def gotoAlignedPosition(self):
        '''Goes to the currently-defined 'aligned' position for this stage. If
        no specific aligned position is defined, then the zero-point for the stage
        is used instead.'''
        
        # TODO: Optional offsets? (Like goto mark?)
        self.gotoOrigin(axes=self._positional_axis)
        #time.sleep(10)

    def getSample(self, sample_number, verbosity=3):
        '''Return the requested sample object from this holder/bar.
        
        One can provide an integer, in which case the corresponding sample
        (from the holder's inventory) is returned. If a string is provided, 
        the closest-matching sample (by name) is returned.'''
        
        if sample_number not in self._samples:
            if verbosity>=1:
                print('Error: Sample {} not defined.'.format(sample_number))
            return None
        
        sample_match = self._samples[sample_number]

        if verbosity>=3:
            print('{}: {:s}'.format(sample_number, sample_match.name))
        
        return sample_match            
        
    def namingWellPlate(name,row_range=['A', 'G'], column_range=[1, 12]):
        '''Name the samples in the well plate.  
        The format is 'NAME_A05_'
        '''
        md = {
            'owner' : 'J. Paloni (MIT) group' ,
            'series' : 'various' ,
            }
            
        for row_number in range(ord(row_range[0]), ord(row_range[1])+1):
            row=chr(row_number)
            #print(row)
            for column in range(column_range[0], column_range[1]+1):
                #print(column)
                sample_name = '{}_{}{}'.format(name, row, column)
                position = '{}'.format(row)+'{0:0=2d}'.format(column)
                self.addSampleSlot( SampleTSAXS( sample_name), position )

class PaloniThermalStage(CapillaryHolder):
    '''This class is a sample holder made by Jason Paloni. 
       It's made by copper with chiller cooling. 
       The stage has 5(x) by 2(z) = 10 samples in total. 
       It uses two stages, smx and smy2 to locate the sample.
       
       Note: need to enable the smy2 stage (~4inch travel distance in y direction). 
       
       1. %mov smy -5, set the limit as -5 
       2. mount the special smy2 stage onto the sample stage and connect the smy2 motor
       3. enable ('yy') in sam._set_axes_definitions of 94-sample.py
    '''    
    def __init__(self, name='CapillaryHolder', base=None, **kwargs):
        super().__init__(name=name, base=base, **kwargs)
 
        #self._axes['y'].origin -= 0.5357125
        self._positional_axis = ['x','yy']

        self._axes['y'].origin = -5
        self._axes['x'].origin = -.25
        self._axes['yy'].origin = 1.5
        
        self.x_spacing = 1.375 *25.4 # 1.375 seperation in x
        self.yy_spacing = 32.13 + 23.25 # 2.25 seperation in y
        #self.yy_spacing = 2.25 *25.4 # 2.25 seperation in y
        

    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        super()._set_axes_definitions()

        self._axes_definitions.append ( {'name': 'yy',
                            'motor': smy2,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves stage up',
                            } )
                        

    def slot(self, sample_number):
        '''Moves to the selected slot in the holder.'''
        
        getattr(self, self._positional_axis[0]+'abs')( self.get_slot_position(sample_number) )
        
    
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        # This is the critical to define the position for the 10 samples. 
        
        if slot < 5.5:
            position_x = 0.0 + slot - 3
        if slot > 5.5:
            position_x = 0.0 + slot -5 -3
        position_yy = 0.0 + int(slot/6)*1.0
        
        return position_x*self.x_spacing,  position_yy*self.yy_spacing
        
        
    def addSampleSlot(self, sample, slot):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( ['x'], [self.get_slot_position(slot)[0]] )
        sample.setOrigin( ['yy'], [self.get_slot_position(slot)[1]] )

class DSCStage(CapillaryHolder):
    '''This class is a sample holder for DSC pans. 
       The stage has 11(x) by 2(z) = 22 samples in total. 
       It has the same dimension as the regular capillary holder.
       It uses two stages, smx and smy to locate the sample.
       X origin is the center. Y origin is the top rack.
    '''    
    def __init__(self, name='CapillaryHolder', base=None, **kwargs):
        super().__init__(name=name, base=base, **kwargs)
        #TODO: search the origin position and check the spacing
        self._axes['y'].origin = -2.2
        self.x_spacing = 9.2  #0.325 *25.4 # 0.375 seperation in x
        self.y_spacing = 12.7 # 1/2 inch seperation in y

    def slot(self, sample_number):
        '''Moves to the selected slot in the holder.'''
        
        getattr(self, self._positional_axis[0]+'abs')( self.get_slot_position(sample_number) )
        
    
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        # This is the critical to define the position for the 10 samples. 
        
        if slot < 11.5:
            position_x = 0.0 + slot - 6
        elif slot > 11.5:
            position_x = 0.0 + slot -11 -6
        position_y = 0.0 + int(slot/11.5)*1.0
        
        return position_x*self.x_spacing,  position_y*self.y_spacing
        
        
    def addSampleSlot(self, sample, slot):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( ['x'], [self.get_slot_position(slot)[0]] )
        sample.setOrigin( ['y'], [self.get_slot_position(slot)[1]] )

class CapillaryHolderThermal(CapillaryHolder):
    '''This class is a sample holder for 2row capillary holder. 
       The stage has 15(x) by 2(y) = 39 samples in total. 
       It has the same dimension as the regular capillary holder.
       It uses two stages, smx and smy to locate the sample.
       X origin is the center (#8). Y origin is the top rack.
    '''    
    def __init__(self, name='CapillaryHolder', base=None, **kwargs):
        super().__init__(name=name, base=base, **kwargs)
        #TODO: search the origin position and check the spacing
        self._axes['y'].origin = 8.65
        # self.x_spacing = 9.2  #0.325 *25.4 # 0.375 seperation in x
        self.y_spacing = 12.7 # 1/2 inch seperation in y

    def slot(self, sample_number):
        '''Moves to the selected slot in the holder.'''
        
        getattr(self, self._positional_axis[0]+'abs')( self.get_slot_position(sample_number) )
        
    
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        # This is the critical to define the position for the 10 samples. 
        
        if slot < 15.5:
            position_x = 0.0 + slot - 8
        elif slot > 15.5:
            position_x = 0.0 + slot -15 -6

        position_y = 0.0 + int(slot/15.5)*1.0
        
        return position_x*self.x_spacing,  position_y*self.y_spacing
        
        
    def addSampleSlot(self, sample, slot):
        '''Adds a sample to the specified "slot" (defined/numbered sample 
        holding spot on this holder).'''
        
        self.addSample(sample, sample_number=slot)
        sample.setOrigin( ['x'], [self.get_slot_position(slot)[0]] )
        sample.setOrigin( ['y'], [self.get_slot_position(slot)[1]] )

class GIBarSecondStage(GIBar):
    '''This class is a sample bar for grazing-incidence (GI) experiments at the 2nd sample stage.'''
    
    # Core methods
    ########################################

    def __init__(self, name='GIBar', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._axes['x'].origin = 8.65
        self._axes['y'].origin = 22.35
        self._axes['th'].origin = 0.348

class HumidityStage(GIBar):
    '''This class is for the humidity stage for multiple samples.'''
    
    def __init__(self, name='GIBar', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._axes['x'].origin = -64.4
        self._axes['y'].origin = 10
        self._axes['th'].origin = 0

    def humidity(self, AI_chan=7, temperature=25, verbosity=3):        
        #AI_chan=7, the independent sensor
        #AI_chan=3, the integrated sensor in the flow control panel
        return ioL.readRH(AI_chan=AI_chan, temperature=temperature, verbosity=verbosity)

    def setFlow(self, channel, voltage=0):
        #device = 'A1'
        ioL.set(AO[channel], 0)
        time.sleep(1)
        ioL.set(AO[channel], voltage)
        #MFC.setMode(channeldevice=device, mode=1)

class HumidityTransmissionStage(CapillaryHolder):
    '''This class is for the humidity transmission stage for multiple samples.'''
    
    def __init__(self, name='HumidityTransmissionStage', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        
        self.x_spacing = 6.43
        
        # slot  1; smx = +26.60
        # slot  8; smx = -17.80
        # slot 15; smx = -61.94
        
        self._axes['x'].origin = -64.4
        self._axes['y'].origin = 10
        self._axes['th'].origin = 0

    def humidity(self, AI_chan=8, temperature=25, verbosity=3):        
        #AI_chan=7, the independent sensor
        #AI_chan=3, the integrated sensor in the flow control panel
        return ioL.readRH(AI_chan=AI_chan, temperature=temperature, verbosity=verbosity)

    def setFlow(self, channel, voltage=0):
        #device = 'A1'
        ioL.set(AO[channel], 0)
        time.sleep(1)
        ioL.set(AO[channel], voltage)
        #MFC.setMode(channeldevice=device, mode=1)

class InstecStage60(CapillaryHolder):
    
    def __init__(self, name='CapillaryHolder', base=None, **kwargs):
        super().__init__(name=name, base=base, **kwargs)
        
        self._axes['y'].origin = 13.4     #smy position for slot 4 of 7-capillary cassette
        self._axes['x'].origin = -15.6     #smx position for slot 4 of 7-capillary cassette
        
        
        self.y_pos_default = []

        self.x_spacing = 0.2 *25.4 # 0.2" seperation in x
    
    
        
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        # This method should be over-ridden in sub-classes, so as to properly
        # implement the positioning appropriate for that holder.
        
        position_x = 0.0 + slot - 4
        
        return position_x*self.x_spacing

    def tscan(self, temperature_start, temperature_final, num_intervals, wait_time, temp_update_time=5, exposure_time=0):

        if temperature_start == None or temperature_start < 0.0 or temperature_start >= 250:
            print('temperature_start must be set between 0 and 250 degC.\n')
            return 0
        
        if temperature_final == None or temperature_final < 0.0 or temperature_final >= 250:
            print('temperature_final must be set between 0 and 250 degC.\n')
            return 0
        
        temperature_step = (temperature_final - temperature_start)/abs(num_intervals)

        if temperature_final < temperature_start:
            temperature_series = np.arange(temperature_start, temperature_final-0.0001, temperature_step)
        else:
            temperature_series = np.arange(temperature_start, temperature_final+0.0001, temperature_step)

        tscan_zero_time = time.time()
        self.tscan_seconds = []
        self.tscan_degC = []
        self.tscan_data = []

        #dump all the (seconds, degC) data into a file; use filename like "<sam.name>_tscan_<first_ID>-<last_ID>.csv" under *user/tscan directory
        self.tscan_filename = '{}/tscan/{}_tscan_{}.csv'.format(RE.md['experiment_alias_directory'], self.name, RE.md['scan_id'])
        self.tscan_data = pds.DataFrame(columns=['scan_id', 'degC', 'seconds'])
        #f=open(filename,'w')
        
        for temperature_setpoint in temperature_series:
            self.setTemperature(temperature_setpoint, output_channel='3')
            self.temperature(temperature_probe='C', output_channel='3')
            #f.write('# scan_ID seconds degC\n')
            
            for t_wait in np.arange(0, wait_time, temp_update_time):
                time.sleep(temp_update_time)
                current_time = time.time() - tscan_zero_time
                current_temperature = self.temperature(temperature_probe='C', output_channel='3', verbosity=2)
                self.tscan_seconds.append(current_time)
                self.tscan_degC.append(current_temperature)
                print('{:.3f} {:.3f}'.format(current_time, current_temperature))
                #f.write('{:d} {:.3f} {:.3f}\n'.format(RE.md['scan_id'], current_time, current_temperature))
                self.tscan_data = self.tscan_data.append({'scan_id':RE.md['scan_id'], 'degC':current_temperature, 'seconds':current_time}, ignore_index=True)

            #while self.IC_int() == False:
                #print('The beam intensity is lower than it should be. Beam may be lost.')
                #sleep(120)
                
            if exposure_time > 0:
                self.measure(exposure_time)
        
        self.tscan_data.to_csv(self.tscan_filename)
        #f.close()
        
    #def tscan_save to recover tscan data when prematurely terminated
    def tscan_save(self):
        #filename = '{}/tscan/{}_tscan_{}.csv'.format(RE.md['experiment_alias_directory'], self.name, RE.md['scan_id']-1)
        ##I'm not sure whether tscan_data is saved or not when terminating tscans. If not, try to load the data into datafrme again.  
        #tscan_data = pds.DataFrame(columns=['scan_id', 'degC', 'seconds'])
        #for ii in len(self.tscan_seconds):
            #tscan_data = tscan_data.append({'scan_id':RE.md['scan_id']-1-len(self.tscan_seconds)+ii, 'degC':self.tscan_degC, 'seconds':self.tscan_seconds}, ignore_index=True)
        self.tscan_data.to_csv(self.tscan_filename)    
        
        
class OffCenteredHoder(GIBar):
    '''The special sample holder for GTSAXS and TSAXS along thin film edges.
       It contains 17 slots with fixed position, similar to Capillary Holders. But the holder dimensions and functions are similar to GIBar. 
       
    '''
        
    def __init__(self, name='OffCenteredHoder', base=None, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._positional_axis = 'x'
        
        self.x_spacing = 6.342 # 3.5 inches / 16 spaces
        
        # slot  1; smx = +26.60
        # slot  8; smx = -17.80
        # slot 15; smx = -61.94
        
        # Set the x and y origin to be the center of slot 8
        self._axes['x'].origin = -17.2    # -0.3
        self._axes['y'].origin = 5.38   # -0.1
        #self.ysetOrigin(5.38)
        #self.xsetOrigin(-17.2)
        
        self.mark('right edge', x=+54.4)
        self.mark('left edge', x=-54.4)
        self.mark('bottom edge', y=-12.71)
        self.mark('center', x=0, y=0)
                
        #measurement measure_settings
        self.detector=None
        self.exposure_time = None
        self.incident_angles = None
        self.tiling = None
        self.measure_setting={}
                
    def get_slot_position(self, slot):
        '''Return the motor position for the requested slot number.'''
        
        return +1*self.x_spacing*(slot-8)
        
"""#abandoned code
class SampleXR(SampleGISAXS_Generic):

    ################# Specular reflectivity (XR) measurement by SAXS detector ####################

    def XR_scan(self, scan_type='theta_scan', theta_range=[0,1.6], theta_delta=0.1, qz_list=None, roi_size=[12,30], exposure_time=1, threshold=20000, max_exposure_time=10, extra='XR_scan', output_file=None):
        ''' Run x-ray reflectivity measurement for thin film samples. 
        Parameters
        ----------
        scan_type : list
            theta_scan: in step of theta
            q_scan: in step of q
        theta_range: list 
            The scanning range. It can be single section or multiple sections with various step_size.
            Examples:  
            [0, 1.6] or 
            [[0, .3],[0.3, 1], [1, 1.6]]                    
        theta_delta: float or list
            The scaning step. Examples:
            0.02    or
            [0.005, 0.1, 0.2]
        roi_size: float
            The szie of ROI1.
        exposure_time: float
            The mininum exposure time
        min_step : float
            The final (minimum) step size to try
        intensity : float
            The expected full-beam intensity readout
        threshold : float
            The threshold of minimum intensity. Exposure time increases automatically if < max_exposure_time 
        max_exposure_time : float
            The maximum of exposure time to limit the total time.
 
        '''
        #TODO:
        #if theta_end < theta_start:
        #    print("The theta_end is larger than theta_start!!!")
        
        #disable the besteffortcallback and plot all ROIs
        #bec.disable_table()
        cms.modeMeasurement()
        
        bec.disable_plots()

        pilatus_name.stats1.total.kind = 'hinted'
        pilatus_name.stats2.total.kind = 'hinted'

        self.naming_scheme_hold = self.naming_scheme
        self.naming_scheme = ['name', 'extra', 'x', 'th', 'exposure_time']
        default_SAXSy = SAXSy.position
        #initial exposure period
        #N = 1
        
        #move in absorber and move out the beamstop
        slot_pos = 6
        beam.setAbsorber(slot_pos)
        if beam.absorber()[0]>=4:
            bsx.move(bsx.position+6)
            beam.setTransmission(1)
        
        #create a clean dataframe and a direct beam images
        self.yr(-2)
        self.tho()
        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:
            direct_beam_slot = 4
        #Energy = 17kev
        if abs(beam.energy(verbosity=1)-17) < 0.1:
            direct_beam_slot = 5
            slot_pos = 5
        beam.setAbsorber(direct_beam_slot)
        get_beamline().setSpecularReflectivityROI(total_angle=0,size=roi_size,default_SAXSy=-73)
        self.measure(exposure_time, extra='direct_beam')
        self.yo()
        
        output_data = self.XR_data_output(direct_beam_slot, exposure_time)
        #output_data = output_data.iloc[0:0]

        #create a data file to save the XRR data
        if output_file is None:
            header = db[-1]
            #XR_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , header.get('start').get('scan_id')+1)
            #XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], header.get('start').get('scan_id')+1)
            XR_FILENAME='{}/data/{}_{}.csv'.format(header.start['experiment_alias_directory'],header.start['sample_name'], header.get('start').get('scan_id')+1)
        else:
            XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], output_file)            

        #load theta positions in scan
        if scan_type == 'theta_scan':
            #list the sth positions in scan
            theta_list=np.arange(theta_range[0], theta_range[1], theta_delta)
            
            #
            '''
            if np.size(theta_range) == 2:
                theta_list=np.arange(theta_range[0], theta_range[1], theta_delta)
            #multiple sections for measurement
            else: 
                theta_list=[]
                if np.shape(theta_range)[0] != np.size(theta_delta):
                    print("The theta_range does not match theta_delta")
                    return
                if np.shape(theta_range)[-1] != 2:
                    print("The input of theta_range is incorrect.")
                    return                
                for number, item in enumerate(theta_range):
                    theta_list_temp = np.arange(item[0], item[1], theta_delta[number])
                    theta_list.append(theta_list_temp)
                theta_list = np.hstack(theta_list)
            
            '''
        elif scan_type == 'qz_scan':
            if qz_list is not None:
                qz_list = qz_list
            else:
               qz_list = self.qz_list_default
            theta_list = np.rad2deg(np.arcsin(qz_list * header.start['calibration_wavelength_A']/4/np.pi))

       
        for theta in theta_list:

            self.thabs(theta)
            #get_beamline().setSpecularReflectivityROI(total_angle=theta*2,size=roi_size,default_SAXSy=-73)

            get_beamline().setSpecularReflectivityROI_update(total_angle=theta*2,size=roi_size,default_SAXSy=-73)


            if cms.out_of_beamstop(total_angle=theta*2, size=roi_size):
                cms.modeMeasurement()       
                print('=========The beamstop is inserted to block the direct beam.=============')
            
            self.measure(exposure_time, extra=extra)
            temp_data = self.XR_data_output(slot_pos, exposure_time)
            
            #initial exposure period
            N = 1
            N_last = 1
            if threshold is not None and type(threshold) == int :
                    
                    
                while temp_data['e_I1'][temp_data.index[-1]] < threshold and N < max_exposure_time:   
                    if slot_pos > 0:
                        if temp_data['e_I1'][temp_data.index[-1]] < 10: #The count is too small to evaluate the next slot_pos.
                            slot_pos = slot_pos - 1
                        else:
                           slot_current = beam.absorber_transmission_list[slot_pos]*threshold/temp_data['e_I1'][temp_data.index[-1]]
                           for slot_no in np.arange(5, 0, -1):
                               if slot_current > beam.absorber_transmission_list[slot_no]:
                                   slot_pos = slot_no - 1 
                              
                        beam.setAbsorber(slot_pos)
                        print('The absorber is slot {}\n'.format(slot_pos))
                        print('The theta is {}\n'.format(theta))
                        self.measure(exposure_time, extra=extra)
                        temp_data = self.XR_data_output(slot_pos, exposure_time)
                    else:
                        if threshold/float(temp_data['e_I1'][temp_data.index[-1]]) < max_exposure_time and N_last < max_exposure_time:
                            N = np.ceil(N_last*threshold/float(temp_data['e_I1'][temp_data.index[-1]]))
                            print('e_I1={}'.format(float(temp_data['e_I1'][temp_data.index[-1]])))
                            print('N={}'.format(N))
                            print('exposure time  = {}'.format(N*exposure_time))
                        else:  
                            N = max_exposure_time
                            print('exposure time is MAX')
                        print('The absorber is slot {}\n'.format(slot_pos))
                        print('The theta is {}\n'.format(theta))


                        self.measure(N*exposure_time, extra=extra)                        
                        temp_data = self.XR_data_output(slot_pos, N*exposure_time)
                        N_last = N
                        
            elif len(threshold)>1 and temp_data['e_I1'][temp_data.index[-1]] > threshold[-1]:
                slot_pos = slot_pos+1
                print('The absorber is slot {}\n'.format(slot_pos))
                print('The theta is {}\n'.format(theta))
                beam.setAbsorber(slot_pos)
                self.measure(exposure_time, extra=extra)
                temp_data = self.XR_data_output(slot_pos, exposure_time)


            output_data = output_data.append(temp_data, ignore_index=True)    
            #save to file 
            output_data.to_csv(XR_FILENAME)
        
        #reset the changed items
        bec.enable_plots()
        #bec.enable_table()
        self.naming_scheme = self.naming_scheme_hold
        #remove the absorber completely out of the beam
        beam.absorber_out()

        pilatus_name.stats3.total.kind = 'hinted'
        pilatus_name.stats4.total.kind = 'hinted'
        
        SAXSy.move(default_SAXSy)

    def XR_abort(self):        
        '''Reset the beamline status back to origin before XRR measurement.
        '''        
        beam.off()        
        cms.modeMeasurement()
        beam.setAbsorber(0)
        #remove the absorber completely out of the beam
        beam.absorber_out()
        
        self.xo()
        self.yo()
        self.tho()

        bec.enable_plots()
        bec.enable_table()
        pilatus_name.hints = {'fields': ['pilatus2M_stats3_total', 'pilatus2M_stats4_total']}

        
    def XR_data_output(self, slot_pos, exposure_time):
        '''XRR data output in DataFrame format, including: 
                        'a_qz': qz,                  #qz
                        'b_th':sth_pos,              #incident angle 
                        'c_scanID': scan_id,         #scan ID
                        'd_I0': I0,                  #bim5 flux
                        'e_I1': I1,                  #ROI1
                        'f_I2': I2,                  #ROI2
                        'g_I3': I3,                  #2*ROI1-ROI2
                        'h_In': In,                  #reflectivity
                        'i_absorber_slot': slot_pos, #absorption slot No.
                        'j_exposure_seconds': exposure_time}   #exposure time
        '''
        
        h = db[-1]
        dtable = h.table()
        
        #beam.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]

        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_13p5kev

        #Energy = 17kev
        elif abs(beam.energy(verbosity=1)-17) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_17kev
        
        else: 
            print("The absorber has not been calibrated under current Energy!!!")
            
            
        sth_pos = h.start['sample_th']
        qz = 4*np.pi*np.sin(np.deg2rad(sth_pos))/h.start['calibration_wavelength_A']
        scan_id = h.start['scan_id']     
        I0 = h.start['beam_int_bim5']  #beam intensity from bim5
        I1 = dtable.pilatus2M_stats1_total
        I2 = dtable.pilatus2M_stats2_total
        I3 = 2*dtable.pilatus2M_stats1_total - dtable.pilatus2M_stats2_total
        In = I3 / beam.absorber_transmission_list[slot_pos] / exposure_time

        current_data = {'a_qz': qz,                  #qz
                        'b_th':sth_pos,              #incident angle 
                        'c_scanID': scan_id,         #scan ID
                        'd_I0': I0,                  #bim5 flux
                        'e_I1': I1,                  #ROI1
                        'f_I2': I2,                  #ROI2
                        'g_I3': I3,                  #2*ROI1-ROI2
                        'h_In': In,                  #reflectivity
                        'i_absorber_slot': slot_pos, #absorption slot No.
                        'j_exposure_seconds': exposure_time}   #exposure time

        return pds.DataFrame(data=current_data)
        
    def XR_align(self, step=0, reflection_angle=0.15, verbosity=3):
        '''Specific alignment for XRR
        
        Align the sample with respect to the beam. XR alignment involves
        vertical translation to the beam center, and rocking theta to get the
        sample plane parralel to the beam. Finally, the angle is re-optimized
        in reflection mode.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''

        cms.modeAlignment()

        if verbosity>=4:
            print('  Aligning {}'.format(self.name))
        
        if step<=0:
            # Prepare for alignment
            cms.modeAlignment()
            if RE.state!='idle':
                RE.abort()
            if get_beamline().current_mode!='alignment':
                if verbosity>=2:
                    print("WARNING: Beamline is not in alignment mode (mode is '{}')".format(get_beamline().current_mode))
                #get_beamline().modeAlignment()
            get_beamline().setDirectBeamROI()
            beam.on()
        
        if step<=2:
            if verbosity>=4:
                print('    align: searching')
                
            # Estimate full-beam intensity
            value = None
            if True:
                # You can eliminate this, in which case RE.md['beam_intensity_expected'] is used by default
                self.yr(-2)
                #detector = gs.DETS[0]
                detector = get_beamline().detector[0]
                value_name = get_beamline().TABLE_COLS[0]
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                self.yr(+2)
            
            if 'beam_intensity_expected' in RE.md and value<RE.md['beam_intensity_expected']*0.75:
                print('WARNING: Direct beam intensity ({}) lower than it should be ({})'.format(value, RE.md['beam_intensity_expected']))
                
            # Find the step-edge
            self.ysearch(step_size=0.5, min_step=0.005, intensity=value, target=0.5, verbosity=verbosity, polarity=-1)
            
            # Find the peak
            self.thsearch(step_size=0.4, min_step=0.01, target='max', verbosity=verbosity)
        
        
        if step<=4:
            if verbosity>=4:
                print('    align: fitting')
            
            fit_scan(smy, 1.2, 21, fit='HMi')
            #time.sleep(2)
            fit_scan(sth, 1.5, 21, fit='max')
            #time.sleep(2)            
            
        if step<=8:
            
            #fit_scan(smy, 0.6, 21, fit='sigmoid_r')
            
            fit_edge(smy, 0.6, 21)
            #time.sleep(2)
            #fit_edge(smy, 0.4, 21)
            fit_scan(sth, 0.8, 21, fit='COM')
            #time.sleep(2)            
            self.setOrigin(['y', 'th'])
        
        
        if step<=9 and reflection_angle is not None:
            # Final alignment using reflected beam
            if verbosity>=4:
                print('    align: reflected beam')
                
            if abs(beam.energy(verbosity)-17)<0.1:
                reflection_angle = 0.15

            get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0)
            #get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0, size=[12,2])
            
            self.thabs(reflection_angle)
            
            result = fit_scan(sth, 0.1, 41, fit='max') 
            #result = fit_scan(sth, 0.2, 81, fit='max') #it's useful for alignment of SmarAct stage
            sth_target = result.values['x_max']-reflection_angle
            
            if result.values['y_max']>50:
                th_target = self._axes['th'].motor_to_cur(sth_target)
                self.thsetOrigin(th_target)

            #fit_scan(smy, 0.2, 21, fit='max')
            #self.setOrigin(['y'])            

        if step<=10:
            self.thabs(0.0)
            beam.off()

    def XR_check_alignment(self, int_angle=1, exposure_time=1, roi_size=[12, 30]):
        ''' Check the alignment of the XR.
        The total_angle is the incident angle. 
        The reflection spot should be located in the center of ROI2'''
        cms.modeMeasurement()
        cms.setSpecularReflectivityROI(total_angle=int_angle*2, size=roi_size,  default_SAXSy=-73)                    
        #sam.xo()
        sam.yo()
        sam.thabs(int_angle)
        sam.measure(exposure_time)
        print('===========sam.th moves to {}deg and ROI1 is set at {}deg. ============'.format(int_angle, int_angle*2))
        print('======Please check the ROI whether at the reflected position. =======')
        print('========If not, modify sam.th or schi to meet the reflected beam. ===========')

#test code for pilatus800 
class SampleXR_test(SampleGISAXS_Generic):

    ################# Specular reflectivity (XR) measurement ####################

    def XR_scan(self, scan_type='theta_scan', theta_range=[0,1.6], theta_delta=0.1, qz_list=None, roi_size=[12,30], exposure_time=1, threshold=20000, max_exposure_time=10, extra='XR_scan', output_file=None):
        ''' Run x-ray reflectivity measurement for thin film samples. 
        Parameters
        ----------
        scan_type : list
            theta_scan: in step of theta
            q_scan: in step of q
        theta_range: list 
            The scanning range. It can be single section or multiple sections with various step_size.
            Examples:  
            [0, 1.6] or 
            [[0, .3],[0.3, 1], [1, 1.6]]                    
        theta_delta: float or list
            The scaning step. Examples:
            0.02    or
            [0.005, 0.1, 0.2]
        roi_size: float
            The szie of ROI1.
        exposure_time: float
            The mininum exposure time
        min_step : float
            The final (minimum) step size to try
        intensity : float
            The expected full-beam intensity readout
        threshold : float
            The threshold of minimum intensity. Exposure time increases automatically if < max_exposure_time 
        max_exposure_time : float
            The maximum of exposure time to limit the total time.
 
        '''
        #TODO:
        #if theta_end < theta_start:
        #    print("The theta_end is larger than theta_start!!!")
        
        #disable the besteffortcallback and plot all ROIs
        #bec.disable_table()
        cms.modeXRMeasurement()
        
        bec.disable_plots()

        pilatus_name.stats1.total.kind = 'hinted'
        pilatus_name.stats2.total.kind = 'hinted'

        self.naming_scheme_hold = self.naming_scheme
        self.naming_scheme = ['name', 'extra', 'th', 'exposure_time']
        default_SAXSy = SAXSy.position
        #initial exposure period
        #N = 1
        
        #move in absorber and move out the beamstop
        slot_pos = 6
        beam.setAbsorber(slot_pos)
        if beam.absorber()[0]>=4:
            bsx.move(bsx.position+6)
            beam.setTransmission(1)
        
        #create a clean dataframe and a direct beam images
        self.yr(-2)
        self.tho()
        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:
            direct_beam_slot = 4
        #Energy = 17kev
        if abs(beam.energy(verbosity=1)-17) < 0.1:
            direct_beam_slot = 5
            slot_pos = 5
        beam.setAbsorber(direct_beam_slot)
        get_beamline().setSpecularReflectivityROI(total_angle=0,size=roi_size,default_SAXSy=-73)
        self.measure(exposure_time, extra='direct_beam')
        self.yo()
        
        output_data = self.XR_data_output(direct_beam_slot, exposure_time)
        #output_data = output_data.iloc[0:0]

        #create a data file to save the XRR data
        if output_file is None:
            header = db[-1]
            #XR_FILENAME='{}/data/{}.csv'.format(os.path.dirname(__file__) , header.get('start').get('scan_id')+1)
            #XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], header.get('start').get('scan_id')+1)
            #XR_FILENAME='{}/data/{}_{}.csv'.format(header.start['experiment_alias_directory'],header.start['sample_name'], header.get('start').get('scan_id')+1)
            XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'],md['filename'])
            
        else:
            XR_FILENAME='{}/data/{}.csv'.format(header.start['experiment_alias_directory'], output_file)            

        #load theta positions in scan
        if scan_type == 'theta_scan':
            #list the sth positions in scan
            theta_list=np.arange(theta_range[0], theta_range[1], theta_delta)
            
            #
            '''
            if np.size(theta_range) == 2:
                theta_list=np.arange(theta_range[0], theta_range[1], theta_delta)
            #multiple sections for measurement
            else: 
                theta_list=[]
                if np.shape(theta_range)[0] != np.size(theta_delta):
                    print("The theta_range does not match theta_delta")
                    return
                if np.shape(theta_range)[-1] != 2:
                    print("The input of theta_range is incorrect.")
                    return                
                for number, item in enumerate(theta_range):
                    theta_list_temp = np.arange(item[0], item[1], theta_delta[number])
                    theta_list.append(theta_list_temp)
                theta_list = np.hstack(theta_list)
            
            '''
        elif scan_type == 'qz_scan':
            if qz_list is not None:
                qz_list = qz_list
            else:
               qz_list = self.qz_list_default
            theta_list = np.rad2deg(np.arcsin(qz_list * header.start['calibration_wavelength_A']/4/np.pi))

       
        for theta in theta_list:

            self.thabs(theta)
            #get_beamline().setSpecularReflectivityROI(total_angle=theta*2,size=roi_size,default_SAXSy=-73)

            get_beamline().setSpecularReflectivityROI_update(total_angle=theta*2,size=roi_size,default_WAXSy=-73)


            if cms.beamOutXR(total_angle=theta*2, size=roi_size):
                
                
                
                cms.modeXRMeasurement()       
                print('=========The beamstop is inserted to block the direct beam.=============')
            
            self.measure(exposure_time, extra=extra)
            temp_data = self.XR_data_output(slot_pos, exposure_time)
            
            #initial exposure period
            N = 1
            N_last = 1
            if threshold is not None and type(threshold) == int :
                    
                    
                while temp_data['e_I1'][temp_data.index[-1]] < threshold and N < max_exposure_time:   
                    if slot_pos > 0:
                        if temp_data['e_I1'][temp_data.index[-1]] < 10: #The count is too small to evaluate the next slot_pos.
                            slot_pos = slot_pos - 1
                        else:
                           slot_current = beam.absorber_transmission_list[slot_pos]*threshold/temp_data['e_I1'][temp_data.index[-1]]
                           for slot_no in np.arange(5, 0, -1):
                               if slot_current > beam.absorber_transmission_list[slot_no]:
                                   slot_pos = slot_no - 1 
                              
                        beam.setAbsorber(slot_pos)
                        print('The absorber is slot {}\n'.format(slot_pos))
                        print('The theta is {}\n'.format(theta))
                        self.measure(exposure_time, extra=extra)
                        temp_data = self.XR_data_output(slot_pos, exposure_time)
                    else:
                        if threshold/float(temp_data['e_I1'][temp_data.index[-1]]) < max_exposure_time and N_last < max_exposure_time:
                            N = np.ceil(N_last*threshold/float(temp_data['e_I1'][temp_data.index[-1]]))
                            print('e_I1={}'.format(float(temp_data['e_I1'][temp_data.index[-1]])))
                            print('N={}'.format(N))
                            print('exposure time  = {}'.format(N*exposure_time))
                        else:  
                            N = max_exposure_time
                            print('exposure time is MAX')
                        print('The absorber is slot {}\n'.format(slot_pos))
                        print('The theta is {}\n'.format(theta))


                        self.measure(N*exposure_time, extra=extra)                        
                        temp_data = self.XR_data_output(slot_pos, N*exposure_time)
                        N_last = N
                        
            elif len(threshold)>1 and temp_data['e_I1'][temp_data.index[-1]] > threshold[-1]:
                slot_pos = slot_pos+1
                print('The absorber is slot {}\n'.format(slot_pos))
                print('The theta is {}\n'.format(theta))
                beam.setAbsorber(slot_pos)
                self.measure(exposure_time, extra=extra)
                temp_data = self.XR_data_output(slot_pos, exposure_time)


            output_data = output_data.append(temp_data, ignore_index=True)    
            #save to file 
            output_data.to_csv(XR_FILENAME)
        
        #reset the changed items
        bec.enable_plots()
        #bec.enable_table()
        self.naming_scheme = self.naming_scheme_hold
        #remove the absorber completely out of the beam
        beam.absorber_out()

        pilatus_name.stats3.total.kind = 'hinted'
        pilatus_name.stats4.total.kind = 'hinted'
        
        SAXSy.move(default_SAXSy)

    def XR_abort(self):        
        '''Reset the beamline status back to origin before XRR measurement.
        '''        
        beam.off()        
        cms.modeXRMeasurement()
        beam.setAbsorber(0)
        #remove the absorber completely out of the beam
        beam.absorber_out()
        
        self.xo()
        self.yo()
        self.tho()

        bec.enable_plots()
        bec.enable_table()
        pilatus_name.hints = {'fields': ['pilatus800_stats3_total', 'pilatus800_stats4_total']}

        
    def XR_data_output(self, slot_pos, exposure_time):
        '''XRR data output in DataFrame format, including: 
                        'a_qz': qz,                  #qz
                        'b_th':sth_pos,              #incident angle 
                        'c_scanID': scan_id,         #scan ID
                        'd_I0': I0,                  #bim5 flux
                        'e_I1': I1,                  #ROI1
                        'f_I2': I2,                  #ROI2
                        'g_I3': I3,                  #2*ROI1-ROI2
                        'h_In': In,                  #reflectivity
                        'i_absorber_slot': slot_pos, #absorption slot No.
                        'j_exposure_seconds': exposure_time}   #exposure time
        '''
        
        h = db[-1]
        dtable = h.table()
        
        #beam.absorber_transmission_list = [1, 0.041, 0.0017425, 0.00007301075, 0.00000287662355, 0.000000122831826, 0.00000000513437]

        #Energy = 13.5kev
        if abs(beam.energy(verbosity=1)-13.5) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_13p5kev

        #Energy = 17kev
        elif abs(beam.energy(verbosity=1)-17) < 0.1:        
            beam.absorber_transmission_list = beam.absorber_transmission_list_17kev
        
        else: 
            print("The absorber has not been calibrated under current Energy!!!")
            
            
        sth_pos = h.start['sample_th']
        qz = 4*np.pi*np.sin(np.deg2rad(sth_pos))/h.start['calibration_wavelength_A']
        scan_id = h.start['scan_id']     
        I0 = h.start['beam_int_bim5']  #beam intensity from bim5
        I1 = dtable.pilatus800_stats1_total
        I2 = dtable.pilatus800_stats2_total
        I3 = 2*dtable.pilatus800_stats1_total - dtable.pilatus800_stats2_total
        In = I3 / beam.absorber_transmission_list[slot_pos] / exposure_time

        current_data = {'a_qz': qz,                  #qz
                        'b_th':sth_pos,              #incident angle 
                        'c_scanID': scan_id,         #scan ID
                        'd_I0': I0,                  #bim5 flux
                        'e_I1': I1,                  #ROI1
                        'f_I2': I2,                  #ROI2
                        'g_I3': I3,                  #2*ROI1-ROI2
                        'h_In': In,                  #reflectivity
                        'i_absorber_slot': slot_pos, #absorption slot No.
                        'j_exposure_seconds': exposure_time}   #exposure time

        return pds.DataFrame(data=current_data)
        
    def XR_align(self, step=0, reflection_angle=0.15, verbosity=3):
        '''Specific alignment for XRR
        
        Align the sample with respect to the beam. XR alignment involves
        vertical translation to the beam center, and rocking theta to get the
        sample plane parralel to the beam. Finally, the angle is re-optimized
        in reflection mode.
        
        The 'step' argument can optionally be given to jump to a particular
        step in the sequence.'''

        cms.modeAlignment()

        if verbosity>=4:
            print('  Aligning {}'.format(self.name))
        
        if step<=0:
            # Prepare for alignment
            cms.modeAlignment()
            if RE.state!='idle':
                RE.abort()
            if get_beamline().current_mode!='alignment':
                if verbosity>=2:
                    print("WARNING: Beamline is not in alignment mode (mode is '{}')".format(get_beamline().current_mode))
                #get_beamline().modeAlignment()
            get_beamline().setDirectBeamROI()
            beam.on()
        
        if step<=2:
            if verbosity>=4:
                print('    align: searching')
                
            # Estimate full-beam intensity
            value = None
            if True:
                # You can eliminate this, in which case RE.md['beam_intensity_expected'] is used by default
                self.yr(-2)
                #detector = gs.DETS[0]
                detector = get_beamline().detector[0]
                value_name = get_beamline().TABLE_COLS[0]
                RE(count([detector]))
                value = detector.read()[value_name]['value']
                self.yr(+2)
            
            if 'beam_intensity_expected' in RE.md and value<RE.md['beam_intensity_expected']*0.75:
                print('WARNING: Direct beam intensity ({}) lower than it should be ({})'.format(value, RE.md['beam_intensity_expected']))
                
            # Find the step-edge
            self.ysearch(step_size=0.5, min_step=0.005, intensity=value, target=0.5, verbosity=verbosity, polarity=-1)
            
            # Find the peak
            self.thsearch(step_size=0.4, min_step=0.01, target='max', verbosity=verbosity)
        
        
        if step<=4:
            if verbosity>=4:
                print('    align: fitting')
            
            fit_scan(smy, 1.2, 21, fit='HMi')
            #time.sleep(2)
            fit_scan(sth, 1.5, 21, fit='max')
            #time.sleep(2)            
            
        if step<=8:
            
            #fit_scan(smy, 0.6, 21, fit='sigmoid_r')
            
            fit_edge(smy, 0.6, 21)
            #time.sleep(2)
            #fit_edge(smy, 0.4, 21)
            fit_scan(sth, 0.8, 21, fit='COM')
            #time.sleep(2)            
            self.setOrigin(['y', 'th'])
        
        
        if step<=9 and reflection_angle is not None:
            # Final alignment using reflected beam
            if verbosity>=4:
                print('    align: reflected beam')
                
            if abs(beam.energy(verbosity)-17)<0.1:
                reflection_angle = 0.15

            get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0)
            #get_beamline().setReflectedBeamROI(total_angle=reflection_angle*2.0, size=[12,2])
            
            self.thabs(reflection_angle)
            
            result = fit_scan(sth, 0.1, 41, fit='max') 
            #result = fit_scan(sth, 0.2, 81, fit='max') #it's useful for alignment of SmarAct stage
            sth_target = result.values['x_max']-reflection_angle
            
            if result.values['y_max']>50:
                th_target = self._axes['th'].motor_to_cur(sth_target)
                self.thsetOrigin(th_target)

            #fit_scan(smy, 0.2, 21, fit='max')
            #self.setOrigin(['y'])            

        if step<=10:
            self.thabs(0.0)
            beam.off()

    def XR_check_alignment(self, int_angle=1, exposure_time=1, roi_size=[12, 30]):
        ''' Check the alignment of the XR.
        The total_angle is the incident angle. 
        The reflection spot should be located in the center of ROI2'''
        cms.modeXRMeasurement()
        #cms.setXRROI(total_angle=int_angle*2, size=roi_size, default_WAXSy=-73)                    
        self.yo()
        self.thabs(int_angle)
        self.measure(exposure_time)
        print('===========sam.th moves to {}deg and ROI1 is set at {}deg. ============'.format(int_angle, int_angle*2))
        print('======Please check the ROI whether at the reflected position. =======')
        print('========If not, modify sam.th or schi to meet the reflected beam. ===========')
"""#abandoned code#!/usr/bin/python
# -*- coding: utf-8 -*-
# vi: ts=4 sw=4




################################################################################
#  Classes for controlling the robotics and automation on the beamline.
################################################################################
# Known Bugs:
#  N/A
################################################################################
# TODO:
#  Search for "TODO" below.
#
# Config file or globalstore to save information.
################################################################################





class SampleExchangeRobot(Stage):
    
    def __init__(self, name='SampleExchangeRobot', base=None, use_gs=True, **kwargs):
        
        super().__init__(name=name, base=base, **kwargs)
        
        self._sample = None
        self.moving = False
        
        # The region can be:
        #  'safe' : arm won't collid with anything, it is near the (+,+,+) limit of its travel.
        #  'parking' : arm is close to the parking lot (movement may hit a sample)
        #  'stage' : arm is close to the sample stage/stack (movement may collide with stack, on-axis camera, or downstream window)
        #  'undefined' : position is unknown (do not assume it is safe to move!)
        self._region = 'undefined'
        
   
        self._status = 'inGarage'
        
        # self.yabs(-82.0) # Good height for 'slotted approach'
        # self.yabs(-77.0) # Good height for 'grip' (grip-screws sitting at bottom of wells)
        # self.yabs(-67.0) # Good height for 'hover' (sample held above stage)
        self._delta_y_hover = 5.0
        self._delta_y_slot = 4.0

        #'SAFE' position of gripper
        self._position_safe = [0, -104.9, 0.0, +90] # x, y, z, r, phi
        
        #self._position_sample_gripped = [-100, -104.9, -94.8, 18.0, +90] # x, y, z, r, phi
        #self._position_hold = [0, -104.9, -94.8, 0.0, +90] # x, y, z, r, phi
        
        #default position of gripper to pick up from Stage
        #self._position_sample_gripped = [ -100.49986249999999, -102.89986875, -93.7, 17.5, 90.0 ] # x, y, z, r, phi
        #self._position_hold = [ 0, -106.89986875, -94.04984999999999, 0, 90.0 ] # x, y, z, r, phi
        
        #tested without SmarAct stage. smx=50; smy=-2.37
        #self._position_sample_gripped = [ -99, -107, -94, 0.0, 91 ] # x, y, z, r, phi
        #self._position_hold = [ 0, -107, -94, 0, 91 ] # x, y, z, r, phi

        ##tested with the gripper with spring. smx=50; smy=-2.37
        #self._position_sample_gripped = [ -98, -103, -94.5, 0.0, 91 ] # x, y, z, r, phi
        #self._position_hold = [ 0, -103, -94.5, 0, 91 ] # x, y, z, r, phi

        #tested with the gripper with spring. smx=50; smy=-2.37
        self._position_sample_gripped = [ -98, -103, -94.5, 91 ] # x, y, z,  phi
        self._position_hold = [ 0, -103, -94.5, 91 ] # x, y, z,  phi

        #defacult position of gripper to pick up from Garage(1,1)
        #self._position_garage = [-96, -200, -129.5, 0.0, 0.0] # x, y, z, r, phi
        #self._position_garage = [ -97.5, -201.000121875, -129.9003625, -0.412427, 0.0 ] # x, y, z, r, phi
        #self._position_garage = [ -98.999675, -198, -130.000375, -0.621273, 0.0 ] # x, y, z, r, phi
        #self._position_garage = [ -98, -200, -128, 0.0, 1 ] # x, y, z, r, phi

        #tested with the gripper with spring. smx=50; smy=-2.37
        #self._position_garage = [ -96, -197.5, -127, 0.0, 1 ] # x, y, z, r, phi
        
        # Manual tweak KY (2017-11-28)
        self._position_garage = [ -96, -197.5-0.5, -128.5, 1 ] # x, y, z, phi
        
        

        #default position for stage
        #self._position_stg_exchange = [+30.0, -2.37] # smx, smy
        #self._position_stg_safe = [-30.0, -2.37] # smx, smy
        #self._position_stg_measure = [] # smx, smy

        #default position for stage without SmarAct motor
        #self._position_stg_exchange = [+50.0, -2.37] # smx, smy
        self._position_stg_exchange = [+51.5, -1.87] # smx, smy # Manual tweak KY (2017-11-28)
        self._position_stg_safe = [-30.0, -2.37] # smx, smy
        self._position_stg_measure = [] # smx, smy
        
        #garage structure parameter 
        self._delta_garage_x = 44.45 # 1.75 inch = 44.45 mm
        self._delta_garage_y = 63.5 # 2.5 inch = 63.5 mm
        
        #if use_gs and hasattr(gs, 'robot'):
            #if '_position_sample_gripped' in gs.robot:
                #self._position_sample_gripped = gs.robot['_position_sample_gripped']
            #if '_position_hold' in gs.robot:
                #self._position_hold = gs.robot['_position_hold']
            #if '_position_garage' in gs.robot:
                #self._position_garage = gs.robot['_position_garage']
        #else:
            #gs.robot = {}
        
        for axis_name, axis in self._axes.items():
            axis._move_settle_max_time = 30.0
        

        
    def _set_axes_definitions(self):
        '''Internal function which defines the axes for this stage. This is kept
        as a separate function so that it can be over-ridden easily.'''
        
        # The _axes_definitions array holds a list of dicts, each defining an axis
        self._axes_definitions = [ {'name': 'x',
                            'motor': armx,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves left/outboard',
                            },
                            #{'name': 'r',
                            #'motor': armr,
                            ##'motor': strans,
                            #'enabled': True,
                            #'scaling': +1.0,
                            #'units': 'mm',
                            #'hint': 'positive moves radial arm outwards',
                            #},        
                            {'name': 'y',
                            'motor': army,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves arm up',
                            },
                            {'name': 'z',
                            'motor': armz,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves arm downstream',
                            },
                            {'name': 'phi',
                            'motor': armphi,
                            'enabled': True,
                            'scaling': +1.0,
                            'units': 'mm',
                            'hint': 'positive moves arm downstream',
                            },
                            
                        ]      
                            


                                
                            
    def home_y(self, verbosity=3, delays=0.5, retries=5, max_wait=2.0):
        
        if retries<1:
            print('ERROR: home_y failed (too many retries).')
            return False
        
        # Activate homing
        caput('XF:11BMB-ES{SM:1-Ax:Y}Start:Home-Cmd', 1)
        
        # Make sure homing actually started
        start_time = time.time()
        while caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Homing-Sts')!=1 and time.time()-start_time<max_wait:
            time.sleep(.01)
            if verbosity>=5:
                print( 'phase, status, homing = {}, {}, {}'.format( caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Home-Sts'), caget('XF:11BMB-ES{SM:1-Ax:Y}Pgm:Home-Sts'), caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Homing-Sts') ) )
            
        
        if time.time()-start_time>max_wait:
            # Retry
            self.home_y(verbosity=verbosity, delays=delays, retries=retries-1, max_wait=max_wait)
            
            
        # Wait for motion to be complete
        time.sleep(delays)
        while army.moving or caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Homing-Sts')!=0:
            time.sleep(delays)
            
        
        if abs(self.yabs(verbosity=0)-0)>0.1:
            print("ERROR: y didn't home (position = {})".format(self.yabs(verbosity=0)))
            return False
        
        if caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Home-Sts')!=7 or caget('XF:11BMB-ES{SM:1-Ax:Y}Pgm:Home-Sts')!=0 or caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Homing-Sts')!=0:
            print( 'phase, status, homing = {}, {}, {}'.format( caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Home-Sts'), caget('XF:11BMB-ES{SM:1-Ax:Y}Pgm:Home-Sts'), caget('XF:11BMB-ES{SM:1-Ax:Y}Sts:Homing-Sts') ) )
            print('ERROR: y homing failed.')
            return False
        
        return True
            
        
            
            
        
    def home(self, verbosity=3, delays=0.5):
        '''Home the axes, so that one can now trust the position values.'''
        
        if not self.checkSafe():
            return
        
        if self._sample is not None:
            print("ERROR: You shouldn't home the robot with a sample in the gripper.")
            return
        
        if verbosity>=3:
            print('Homing robot')
        

        # army to positive limit (moves arm to top of vertical range); set this to be zero
        success = self.home_y(verbosity=verbosity, delays=delays)
        if not success:
            return False
        
        # armx to positive limit; set this to be zero
        self.xabs(0)
        caput('XF:11BMB-ES{SM:1-Ax:X}Start:Home-Cmd', 1)
        time.sleep(delays)
        while armx.moving:
            time.sleep(delays)
        
        # Rotate arm so that it doesn't collide when doing a +z scan
        self.phiabs(+90) # gripper pointing -x (towards sample stack)
        time.sleep(delays)
        while armphi.moving:
            time.sleep(delays)
            
        # Home armphi 
        caput('XF:11BMB-ES{SM:1-Ax:Yaw}Start:Home-Cmd', 1)
        time.sleep(delays)
        while armphi.moving and caget('XF:11BMB-ES{SM:1-Ax:Yaw}Sts:Homing-Sts')!=0:
            time.sleep(delays)
        
        # Rotate arm so that it doesn't collide when doing a +z scan
        self.phiabs(+90) # gripper pointing -x (towards sample stack)
        time.sleep(delays)
        while armphi.moving:
            time.sleep(delays)
        
        
        # armz to positive limit (moves arm to downstream of range); set this to be zero
        caput('XF:11BMB-ES{SM:1-Ax:Z}Start:Home-Cmd', 1)
        time.sleep(delays)
        while armz.moving:
            time.sleep(delays)
        
        
        #caput('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr.HOMF',1) # armr home forward
        #caput('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr.HOMR',1) # armr home reverse
        #time.sleep(delays)
        #while self._axes['r'].motor.moving:
            #time.sleep(delays)
        
        self._region = 'safe'
        return True

    def checkMove(self, verbosity=3):
        if armx.motor_done_move.value!=1 or army.motor_done_move.value!=1 or armz.motor_done_move.value!=1 or armphi.motor_done_move.value!=1:
            if verbosity >=3: 
                print('Robot is moving!')
            return self.moving == True
        else:
            if verbosity >=3: 
                print('Robot is NOT moving!')
            return self.moving == False

    def checkSafe(self, check_stage=True):

        if self._region is not 'safe':
            print("ERROR: Robot arm must start in the 'safe' region of the chamber (current region is '{}'). Move the robot to the safe region (and/or set _region to 'safe').".format(self._region))
            return False
        
        #smx_safe, smy_safe = self._position_stg_safe
        #if check_stage and smx.user_readback.value > (smx_safe+0.1):
            #print("ERROR: smx ({}) is in an unsafe position.".format(smx.user_readback.value))
            #return False
        
        return True
        
        
        
    def setReferenceSampleGripped(self):
        """The position when the sample (on the stage) is gripped."""
        
        x = self.xpos(verbosity=0)
        y = self.ypos(verbosity=0)
        z = self.zpos(verbosity=0)
        #r = self.rpos(verbosity=0)
        phi = self.phipos(verbosity=0)
        self._position_sample_gripped = x, y, z, phi # x, y, z, phi

        print("self._position_sample_gripped = [ {}, {}, {}, {} ] # x, y, z, phi".format(x, y, z, phi))

        #if hasattr(gs, 'robot'):
            #gs.robot['_position_sample_gripped'] = self._position_sample_gripped

        
        self._position_hold = 0, y, z, phi # x, y, z, phi
        
        print("self._position_hold = [ {}, {}, {}, {} ] # x, y, z, phi".format(0, y, z, phi))

        #if hasattr(gs, 'robot'):
            #gs.robot['_position_hold'] = self._position_hold

        
    def setReferenceGarage(self):
        """The position when the lower-left (1,1) sample of the garage is gripped."""
        
        x = self.xpos(verbosity=0)
        y = self.ypos(verbosity=0)
        z = self.zpos(verbosity=0)
        #r = self.rpos(verbosity=0)
        phi = self.phipos(verbosity=0)
        
        self._position_garage = x, y, z, phi # x, y, z, phi
        
        print("self._position_garage = [ {}, {}, {}, {} ] # x, y, z, phi".format(x, y, z, phi))

        #if hasattr(gs, 'robot'):
            #gs.robot['_position_garage'] = self._position_garage
        
        
    def motionSlot(self, direction):
        self.yr(direction*self._delta_y_slot)

    def motionHover(self, direction):
        self.yr(direction*self._delta_y_hover)
        
    def sequenceGotoSafe(self, verbosity=3):
        
        x, y, z, phi = self._position_safe
        
        #if abs( self.phipos(verbosity=verbosity) - 90 ) < 0.1:
            ## phi = 90deg, prongs pointed at stage
            #pass
        #elif abs( self.phipos(verbosity=verbosity) - 0 ) < 0.1:
            ## phi = 0deg, prongs pointed at stage
            #pass
        #else:
            #pass
            
        self.phiabs(phi)
        self.yabs(y)
        self.xabs(x)
        self.zabs(z)
            
        self._region = 'safe'


    def sequenceGotoSampleStageSlotted(self, x_motion=True, verbosity=3):
        
        if self._sample is not None:
            print("ERROR: There is already a sample being gripped by robot arm (sample {}.".format(self._sample.name))
            return
        
        if not self.checkSafe():
            return
        
        if verbosity>=3:
            print('TBD')
        
        
        # Move sample stage
        x, y = self._position_stg_exchange # smx, smy
        #mov([smx, smy], [x,y])
        smx.move(x)
        smy.move(y)
        
        
        x, y, z, phi = self._position_sample_gripped
        
        # Pre-align the arm in (y,z)
        self.phiabs(phi, verbosity=verbosity)
        self.zabs(z, verbosity=verbosity)
        self.yabs(y-self._delta_y_slot, verbosity=verbosity)
        
        self._region = 'stage'
        if x_motion:
            # Move arm so that it is slotted over the sample
            self.xabs(x, verbosity=verbosity)
            #self.rabs(r, verbosity=verbosity)
        
        
    def sequencePutSampleOntoStage(self, gotoSafe=True, verbosity=3):
        
        if self._sample is None:
            print("ERROR: No sample currently being gripped by robot arm.")
            return
        
        if not self.checkSafe(check_stage=False):
            return
        
        if verbosity>=3:
            print('Putting sample onto stage')
        
        
        # Move sample stage
        x, y = self._position_stg_exchange # smx, smy
        #mov([smx, smy], [x,y])
        smx.move(x)
        smy.move(y)
        sth.move(0)
        
        x, y, z, phi = self._position_sample_gripped
        
        # Pre-align the arm in (y,z)
        self.phiabs(phi, verbosity=verbosity)
        self.zabs(z, verbosity=verbosity)
        self.yabs(y+self._delta_y_hover, verbosity=verbosity)
        
        self._region = 'stage'
        # Push the sample out so that it is hovering above the stage
        # r is removed without SmarAct motor
        #mov([armx, self._axes['r'].motor], [x, r])
        #mov(armx,x)
        armx.move(x)

        # Move sample down (-y)
        self.yr(-self._delta_y_hover, verbosity=verbosity) # Now in contact with stage
        
        # De-grip
        self.yr(-self._delta_y_slot, verbosity=verbosity)

        self._sample = None
        self._status = 'onStage'
        
        # Move away from stage
        x, y, z, phi = self._position_hold
        #mov([armx, self._axes['r'].motor], [x, r])
        # r is removed without SmarAct motor
        #mov(armx, x)
        armx.move(x)
        
        if gotoSafe==True:
            self.sequenceGotoSafe(verbosity=verbosity)
        else:
            self._region = 'stage'
            
        
        

    def sequenceGetSampleFromStage(self, gotoSafe=True, verbosity=3):
        
        if self._sample is not None:
            print("ERROR: There is already a sample being gripped by robot arm (sample {}.".format(self._sample.name))
            return
        
        if not self.checkSafe():
            return
        
        if verbosity>=3:
            print('Getting sample from stage')
        
        
        # Move sample stage
        x, y = self._position_stg_exchange # smx, smy
        #mov([smx, smy], [x,y])
        smx.move(x)
        smy.move(y)
        sth.move(0)
        
        x, y, z, phi = self._position_sample_gripped
        
        # Pre-align the arm in (y,z)
        self.phiabs(phi, verbosity=verbosity)
        self.zabs(z, verbosity=verbosity)
        self.yabs(y-self._delta_y_slot, verbosity=verbosity)
        
        self._region = 'stage'
        # Move arm so that it is slotted over the sample
        self.xabs(x, verbosity=verbosity)
        # self.rabs(r, verbosity=verbosity)
        
        # Grip sample
        self.yr(+self._delta_y_slot, verbosity=verbosity)
        
        self._sample = 'exists' # TODO: Fix
        self._status = 'onRobot'
        
        # Pick sample up (+y)
        self.yr(+self._delta_y_hover, verbosity=verbosity)
        
        # Move away from stage
        x, y, z, phi = self._position_hold
        #mov([armx, self._axes['r'].motor], [x, r])
        # r is removed without SmarAct motor
        #mov(armx, x)
        armx.move(x)
       
        if gotoSafe==True:
            self.sequenceGotoSafe(verbosity=verbosity)
        
        
        
    def sequenceGetSampleFromGarage(self, shelf_num, spot_num, gotoSafe=True, verbosity=3):
        
        if shelf_num<1 or shelf_num>4:
            print("ERROR: Invalid shelf {}".format(shelf_num))
            return
        if spot_num<1 or spot_num>3:
            print("ERROR: Invalid spot {}".format(spot_num))
            return
        
        if self._sample is not None:
            print("ERROR: There is already a sample being gripped by robot arm (sample {}.".format(self._sample.name))
            return
        
        if verbosity>=3:
            print('Getting sample from garage ({}, {})'.format(shelf_num, spot_num))
        
        
        x, y, z, phi = self._position_garage
        
        self.phiabs(phi)
        
        # Align ourselves with this parking spot
        success = self.sequencePrepGarageXY(shelf_num, spot_num, verbosity=verbosity)
        if not success:
            return
        x = self.xpos(verbosity=0)
        y = self.ypos(verbosity=0)
        
        # Lower so that the slot is aligned
        self.yr(-self._delta_y_slot, verbosity=verbosity)
        
        # Move towards parking lot
        self._region = 'parking'
        self.zabs(z, verbosity=verbosity)
        
        # Grip sample
        self.yr(+self._delta_y_slot, verbosity=verbosity)
        
        self._sample = 'exists' # TODO: Fix
        self._status = 'onRobot'
        
        # Pick sample up (+y)
        self.yr(+self._delta_y_hover, verbosity=verbosity)

        # Move away from parking
        self.zabs(0, verbosity=verbosity)
        self.xabs(0, verbosity=verbosity)
        self.yabs(self._position_safe[1], verbosity=verbosity)
        if gotoSafe==True:
            self.sequenceGotoSafe(verbosity=verbosity)
        

    def sequencePutSampleInGarage(self, shelf_num, spot_num, gotoSafe=True, verbosity=3):
        
        if shelf_num<1 or shelf_num>4:
            print("ERROR: Invalid shelf {}".format(shelf_num))
            return
        if spot_num<1 or spot_num>3:
            print("ERROR: Invalid spot {}".format(spot_num))
            return
        
        if self._sample is None:
            print("WARNING: There is no sample being gripped by robot arm.")
        
        if verbosity>=3:
            print('Putting sample into garage ({}, {})'.format(shelf_num, spot_num))
        
        
        x, y, z, phi = self._position_garage
        
        self.phiabs(phi)
        
        # Align ourselves with this parking spot
        success = self.sequencePrepGarageXY(shelf_num, spot_num, verbosity=verbosity)
        if not success:
            return
        x = self.xpos(verbosity=0)
        y = self.ypos(verbosity=0)
        
        # Hover
        self.yr(+self._delta_y_hover, verbosity=verbosity)
        
        # Move towards parking lot
        self._region = 'parking'
        self.zabs(z, verbosity=verbosity)
        
        # Deposit sample
        self.yr(-self._delta_y_hover, verbosity=verbosity)
        self.yr(-self._delta_y_slot, verbosity=verbosity)
        
        self._sample = None
        self._status = 'inGarage'

        # Move away from parking
        self.zabs(0, verbosity=verbosity)
        self.xabs(0, verbosity=verbosity)
        if gotoSafe==True:
            self.sequenceGotoSafe(verbosity=verbosity)


    def sequencePrepGarageXY(self, shelf_num, spot_num, verbosity=3):
        
        if shelf_num<1 or shelf_num>4:
            print("ERROR: Invalid shelf {}".format(shelf_num))
            return
        if spot_num<1 or spot_num>3:
            print("ERROR: Invalid spot {}".format(spot_num))
            return

        if not self.checkSafe():
            return
        
        if verbosity>=3:
            print('  Going to garage ({}, {})'.format(shelf_num, spot_num))
        
        if self.zpos(verbosity=0)<-10:
            print("ERROR: z ({}) position unsafe.".format(self.zpos(verbosity=0)))

        if abs(self.phipos(verbosity=0))>1:
            print("ERROR: phi ({}) position unsafe.".format(self.phipos(verbosity=0)))
        
        x, y, z, phi = self._position_garage
        
        x += (spot_num-1)*self._delta_garage_x
        y += (shelf_num-1)*self._delta_garage_y
        
        if verbosity>=4:
            print('    Going to (x,y) = ({}, {})'.format(x, y))
        
        
        # Do y first to avoid catching cables
        self.yabs(y)
        self.xabs(x)
        
        xactual = self.xpos(verbosity=0)
        yactual = self.ypos(verbosity=0)
        
        if abs(x-xactual)>0.2:
            print('ERROR: x did not reach requested position (request = {}, actual = {})'.format(x, xactual))
            return False
        
        if abs(y-yactual)>0.2:
            print('ERROR: y did not reach requested position (request = {}, actual = {})'.format(y, yactual))
            return False
        
        return True
        
        
    def loadSample(self, shelf_num, spot_num, verbosity=3):
        
        # Check if a sample is on stage
        # Unload sample if necessary
        
        self.sequenceGetSampleFromGarage(shelf_num, spot_num, verbosity=verbosity)
        self.sequencePutSampleOntoStage()
    
    
    def calibrationStage(self, verbosity=3):
        
        if self._sample is not None:
            print("ERROR: Calibration cannot be done with sample on robot arm.")
            return
        
        if not self.checkSafe(check_stage=False):
            return
        
        if verbosity>=3:
            print('Approaching to stage')
        
        # Move sample stage
        x, y = self._position_stg_exchange # smx, smy
        #mov([smx, smy], [x,y])
        smx.move(x)
        smy.move(y)        
        
        x, y, z, phi = self._position_sample_gripped
        
        # Pre-align the arm in (y,z)
        self.phiabs(phi, verbosity=verbosity)
        self.zabs(z, verbosity=verbosity)
        self.yabs(y-self._delta_y_slot, verbosity=verbosity)
        
        # Move to a position x is away from sample bar
        self.xabs(-40, verbosity=verbosity)
        #self.rabs(0, verbosity=verbosity)
         
    def calibrationGarage(self, verbosity=3):
        
        #use Garage(1,1) to calibration the gripper position
        shelf_num=1
        spot_num=1
  
        if self._sample is not None:
            print("ERROR: Calibration cannot be done with sample on robot arm. ")
            return
        
        if verbosity>=3:
            print('Approaching to garage ({}, {})'.format(shelf_num, spot_num))
        
        
        x, y, z, phi = self._position_garage
        
        self.phiabs(phi)
        
        # Align ourselves with this parking spot
        success = self.sequencePrepGarageXY(shelf_num, spot_num, verbosity=verbosity)
        if not success:
            return
        x = self.xpos(verbosity=0)
        y = self.ypos(verbosity=0)
        
        # Lower so that the slot is aligned
        self.yr(-self._delta_y_slot, verbosity=verbosity)
        self.zabs(-60)
       
    #def pickandStage(self, shelf_num, spot_num,verbosity=3):
        #'''pick up bar from sample stage and leave in 'safe' position
        #'''
        #if verbosity>=2:
            #print('picking up from garage ({}, {})'.format(shelf_num, spot_num))
        #self.sequenceGetSampleFromGarage(shelf_num, spot_num, verbosity=verbosity)
        #time.sleep(2)
        #self.sequencePutSampleOntoStage(verbosity=verbosity) 
        #time.sleep(2)        

    #def pickandGarage(self, shelf_num, spot_num, verbosity=3):
        #'''pick up bar from sample stage and leave in 'safe' position
        #'''
        #if verbosity>=2:
            #print('return to garage ({}, {})'.format(shelf_num, spot_num))
        #self.sequenceGetSampleFromStage(verbosity=verbosity)
        #time.sleep(2)
        #self.sequencePutSampleInGarage(shelf_num, spot_num, verbosity=verbosity)        
        #time.sleep(2)        


    def pickupHolder(self, slot, gotoSafe=True, verbosity=3):
        
        #picking up the holer from Garage
        #shelf_num, spot_num: slot number of the holder
        [shelf_num, spot_num] = slot
        if verbosity>=3:
            print('picking up from garage ({}, {})'.format(shelf_num, spot_num))
        
        if self._sample is not None:
            print("ERROR: There is already a sample being gripped by robot arm (sample {}.".format(self._sample.name))
            return
        
        self.sequenceGetSampleFromGarage(shelf_num, spot_num, gotoSafe=gotoSafe, verbosity=verbosity)
        time.sleep(1)
        #always go back to safe position from or to the stage
        self.sequencePutSampleOntoStage(verbosity=verbosity)    
        

    def returnHolder(self, slot, gotoSafe=True, verbosity=3):
        
        #returning the holer back to Garage
        #shelf_num, spot_num: slot number of the holder
        [shelf_num, spot_num] = slot
        if verbosity>=3:
            print('returning back to garage ({}, {})'.format(shelf_num, spot_num))
        
        #always go back to safe position from or to the stage
        self.sequenceGetSampleFromStage(verbosity=verbosity)
        time.sleep(1)
        #only this one need options NOT to return robot to the default position
        self.sequencePutSampleInGarage(shelf_num, spot_num, gotoSafe=gotoSafe, verbosity=verbosity)



    def _stress_test(self, cycles=2, verbosity=5):

        if not self.checkSafe():
            return
        
        #self.home()
        
        if not self.checkSafe():
            return
        
        
        for i in range(cycles):
            if verbosity>=2:
                print('Stress test cycle {}'.format(i))
                
            for shelf_num in range(1, 4+1):
                for spot_num in range(1, 3+1):

                    if verbosity>=2:
                        print('Stress test garage ({}, {})'.format(shelf_num, spot_num))

                    
                    self.sequenceGetSampleFromGarage(shelf_num, spot_num, verbosity=verbosity)
                    self.sequencePutSampleOntoStage(verbosity=verbosity)
                    
                    time.sleep(3)
                                        
                    self.sequenceGetSampleFromStage(verbosity=verbosity)
                    self.sequencePutSampleInGarage(shelf_num, spot_num, verbosity=verbosity)
                    

    def run(self, cycles=1, verbosity=3):

        if not self.checkSafe():
            return
        
        for hol in Garage_holders:
            
            [shelf_num, spot_num] = hol.GaragePosition
            if verbosity>=2:
                print('Run test garage ({}, {})'.format(shelf_num, spot_num))
                
            self.sequenceGetSampleFromGarage(shelf_num, spot_num, verbosity=verbosity)
            time.sleep(2)
            self.sequencePutSampleOntoStage(verbosity=verbosity)

            hol.listSamples()
            time.sleep(2)
            hol.doSamples()
                
            self.sequenceGetSampleFromStage(verbosity=verbosity)
            time.sleep(2)
            self.sequencePutSampleInGarage(shelf_num, spot_num, verbosity=verbosity)        
            time.sleep(2)


    def run_test(self,  verbosity=3):

        if not self.checkSafe():
            return
        
        for hol in Garage_holders:
            
            [shelf_num, spot_num] = hol.GaragePosition
            if verbosity>=2:
                print('Run test garage ({}, {})'.format(shelf_num, spot_num))
                
            self.sequenceGetSampleFromGarage(shelf_num, spot_num, verbosity=verbosity)
            print('out of garage')
            time.sleep(2)
            self.sequencePutSampleOntoStage(verbosity=verbosity)
            
            hol.listSamples()
            time.sleep(2)
            hol.doSamples()
                
            self.sequenceGetSampleFromStage(verbosity=verbosity)
            time.sleep(2)
            self.sequencePutSampleInGarage(shelf_num, spot_num, gotoSafe=False, verbosity=verbosity)        
            time.sleep(2)
            
        self.sequenceGotoSafe(verbosity=verbosity)
                    
    def listGarage(self, verbosity=3):

        for hol in Garage_holders:
               
                [shelf_num, spot_num] = hol.GaragePosition
                print('In Garage ({}, {})'.format(shelf_num, spot_num))
                hol.listSamplesPositions()        
        

#class Queue(object):
class Queue(CoordinateSystem):
    '''
    Holds the current state of the sample queue, allowing samples settings
    to be 'extracted'; or even allowing a particular sample to be physically
    loaded.
    functions:
    1. check the status of the robot and the holder
    2. define the holders in the garage and the corresponding measurement methods and sequence
    3. run the robot without unecessary movement
    '''

    def __init__(self, name='Queue', base=None, **kwargs):
        
        if base is None:
            base = get_default_stage()
        
        #super().__init__(name=name, base=base, **kwargs)
        
        self._holders = {}
        self._current = None  #the current holder on the stage. 
        self._currentSample = None  #the current sample measured on the stage, self._currentSample = [holder, sample_number]
        self.status = None #status of the current robot, including 'onStage', 'onRobot', 'inGarage'
        self._sequence = {}  #the current holder on the stage
        
        self.reset_clock()

    def clock(self):
        '''Return the current value of the "clock" variable. This provides a
        way to set a clock/timer for a sample. For instance, you can call
        "reset_clock" when you initiate some change to the sample. Thereafter,
        the "clock" method lets you check how long it has been since that
        event.'''

        clock_delta = time.time() - self.clock_zero
        return clock_delta

    def reset_clock(self):
        '''Resets the sample's internal clock/timer to zero.'''

        self.clock_zero = time.time()

        return self.clock()
        
    def checkStatus(self, verbosity=3):
        '''check the status of the robot and holder
            including where is the robot 
            holder, which holder is on the stage. 
            
        '''

        #robot part

        # The region can be:
        #  'safe' : arm won't collid with anything, it is near the (+,+,+) limit of its travel.
        #  'parking' : arm is close to the parking lot (movement may hit a sample)
        #  'stage' : arm is close to the sample stage/stack (movement may collide with stack, on-axis camera, or downstream window)
        #  'undefined' : position is unknown (do not assume it is safe to move!)
        print('robot region = {}'.format(robot._region))
        print('robot holding sample = {}'.format(robot._sample!=None))
        #print('robot moving is {}'.format(robot.checkMove()))
        
        robot._region = 'safe'
        #holder part
        
        if robot._sample == True: #holder sitting on the robot
            self.status = 'onRobot'
        #elif robot._status == 'inGarage':
            #self.status = 'inGarage'
        #elif robot._status == 'onStage':
            #self.status = 'onStage'
        elif self._current == None:
            self.status = 'inGarage'
        else:
            self.status = 'onStage'
            #self._current = []
        
        #promp question to check the status of the current stage
        if verbosity >= 5:
            
            question = [
                ["Is there any holder on the stage? (y/n)"] ,
                ["Is there any holder on the robot? (y/n)"] ,
                ["If yes, what is the holder?"] ,
                ]
            try:
                print('Tell me more about what is on the stage ::: ')
                ret0 = input('  Q : {} : '.format(question[0]) )    
                ret1 = input('  Q : {} : '.format(question[1]) )    
                ret2 = input('  Q : {} : '.format(question[2]) )    
            except KeyboardInterrupt:
                    return

            print('Your input is:')
            print('There is holder on stage ::: {}', ret0)
            print('There is holder on robot ::: {}', ret1)
            print('The holder is ::: {}', ret2)
            ret3 = input('Is it correct? (y/n) ')
            if ret3 == 'y' or ret3 == 'yes':
                print('Thank you')
            else:
                return
            
            if ret0 == 'y' or ret0 == 'yes':
                self.status = 'onStage'
                for key, item in que._sequence.items():    
                #for ret2 in self._holders.items()):    
                    if item.name == ret2:
                        self._current = item
                        #print('There is no holder with the same name. Please double-check')
                if self._current==None:
                    print('ERROR : The holder name is not in the queue list. Please double-check')
                    return
               
            elif ret1 == 'y' or ret1 == 'yes':
                self.status = 'parking'
            else:
                self.status = 'inGarage'

        if verbosity >=3:
            print('Current queue status = {}'.format(self.status))
            if self._current == None:
                print ('The current holder is {}'.format(self._current)) 
            else:
                print ('The current holder is {}'.format(self._current.name)) 
            #print('Current robot region is safe')
            
        return self.status

    def setStatus(self, status, current, verbosity=3):
        #set the current status of the queue
        self.status = status
        self._current = current
        if verbosity>=3:
            self.checkStatus()

    def addHolder(self, holder, slot):
        '''add a holder (assembly of samples) to robot garage
           the slots are listed from slot_pos [1, 1] to [4, 3], corresponding to the slot_number from 1 to 12
        '''
        if slot is None:
            if len(self._holders)==0:
                slot_number = 1
                slot_pos = [1, 1]
            elif len(self._holders)==1:
                ki = [ int(key) for key in self._holders.keys() ]                
                slot_pos = [np.max(ki)/3, np.max(ki)/3+1]
                slot_number = slot
        elif len(slot)== 1:
            slot_pos = [int(slot/3)+1, slot%3+1]
            slot_number = slot
        elif len(slot)==2:
            slot_pos  = slot
            slot_number = (slot[0]-1)*3+slot[1]
        
        #print(slot_number)
                
        if slot_number in self._holders.keys():
            print('Warning: Slot pos {} is already defined". Use "replaceSample" if you are sure you want to eliminate the existing holder from the garage.'.format(slot_pos) )
            
        else:
            self._holders[slot_number] = holder
            
        self._holders[slot_number] = holder
        
        #holder.set_base_stage(self)
        holder.md['holder_number'] = slot_number
        holder.md['holder_position'] = slot_pos
        holder.slot_number = slot_number
        holder.slot_pos = slot_pos
        
    def addHolderIntoQueue(self, holder, slot, sequence_number):
        self.addHolder(holder, slot=slot)
        #holder.addGaragePosition(slot)
        holder.sequence_number=sequence_number
        
    def removeHolder(self, slot):
        '''Remove a particular holder from garage.'''
        
        del self._holders[slot]
        
    
    def removeHoldersAll(self):
        
        self._holders = {}            
        
    def replaceHolder(self, holder, slot):
        '''Replace a given holder on garage with a different sample.'''
        
        self.removeHolder(slot)
        self.addHolder(holder, slot)

    def getHolder(self, slot, verbosity=3):
        '''Return the requested sample object from this holder/bar.
        slot has 3 kinds of inputs:
           1. integer from 1 to 12
           2. list [1, 1] to [4, 3]
           3. holder name
        '''
        
        #TODO : 
        if type(slot) is int:
            #slot = [np.max(slot)/3, np.max(slot)/3+1]
            
            if slot not in self._holders:
                if verbosity>=1:
                    print('Error: Slot {} not defined.'.format(slot))
                return None
            
            slot_match = self._holders[slot]

            if verbosity>=3:
                print('{}: {:s}'.format(slot, slot_match.name))
            
            return slot_match
        
        elif type(slot) is list:
            if len(slot)>=2 and type(slot[0])==int and type(slot[1])==int:
                slot_number = (slot[0]-1)*3+slot[1]
                if slot_number not in self._holders:
                    if verbosity>=1:
                        print('Error: Slot {} not defined in the garage.'.format(slot))
                        #print('sss')
                    return None
                slot_match = self._holders[slot_number]

                if verbosity>=3:
                    print('{}: {:s}'.format(slot, slot_match.name))
                
                return slot_match
            else:
                if verbosity>=1:
                    print('Error: Slot {} not defined.'.format(slot))
                return None
            
        elif type(slot) is str:
            
            # First search for an exact name match
            matches = 0
            slot_match = None
            ct_match = None
            for ct, holder in sorted(self._holders.items()):
                if holder.name==slot:
                    matches += 1
                    if slot_match is None:
                        slot_match = holder
                        ct_match = ct
                    
            if matches==1:
                if verbosity>=3:
                    print('{}: {:s}'.format(ct_match, slot_match.name))
                return slot_match
                    
            elif matches>1:
                if verbosity>=2:
                    print('{:d} exact matches for "{:s}", returning slot {}: {:s}'.format(matches, slot, ct_match, holder_match.name))
                return slot_match
            
        #elif type(slot) is holder:
            #slot_match = slot
            #return slot_match
        #else:
            #return None

            ## Try to find a 'start of name' match
            #for slot_i, slot in sorted(self._holders.items()):
                #if slot.name.startswith(slot):
                    #matches += 1
                    #if slot_match is None:
                        #slot_match = slot
                        #slot_i_match = slot_i
                        
            #if matches==1:
                #if verbosity>=3:
                    #print('Beginning-name match: {}: {:s}'.format(slot_i_match, slot_match.name))
                #return slot_match
                    
            #elif matches>1:
                #if verbosity>=2:
                    #print('{:d} beginning-name matches for "{:s}", returning slot {}: {:s}'.format(matches, slot, slot_i_match, slot_match.name))
                #return slot_match
            
            ## Try to find a substring match
            #for slot_i, slot in sorted(self._holders.items()):
                #if slot in slot.name:
                    #matches += 1
                    #if slot_match is None:
                        #slot_match = slot
                        #slot_i_match = slot_i
                        
            #if matches==1:
                #if verbosity>=3:
                    #print('Substring match: {}: {:s}'.format(slot_i_match, slot_match.name))
                #return slot_match
                    
            #elif matches>1:
                #if verbosity>=2:
                    #print('{:d} substring matches for "{:s}", returning slot {}: {:s}'.format(matches, slot, slot_i_match, slot_match.name))
                #return slot_match
            
            #if verbosity>=1:
                #print('No slot has a name matching "{:s}"'.format(slot))
            #return None
            
            
        else:
            
            print('Error: Holder designation "{}" not understood.'.format(slot))
            return None

    import string
    def getHolders(self, holder_range=None, verbosity=3):
        '''Get the list of holders associated with this holder.
        
        If the optional holder_range argument is provided (2-tuple), then only holder
        numbers within that holder_range (inclusive) are run. If holder_range is instead a 
        string, then all holders with names that match are returned.'''
        
        holders = []
        
        if holder_range is None:
            for holder_number in sorted(self._holders):
                holders.append(self._holders[holder_number])
                
        elif type(holder_range) is list:
            if type(holder_range[0]) is int:
                if len(holder_range) == 2:
                    start, stop = holder_range
                    for holder_number in sorted(self._holders):
                        if holder_number>=start and holder_number<=stop:
                            holders.append(self._holders[holder_number])
                else: 
                    for holder_number in sorted(self._holders):
                        for ii in holder_range: 
                            if holder_number == ii:
                                holders.append(self._holders[holder_number])                
 
            elif type(holder_range[0]) is str: #For 96 well holder, format: A1, D2 ...
                for holder_number in sorted(self._holders):
                    holder_row = string.ascii_lowercase(holder_number[0])
                    holder_column = int(holder_number[1:])
                    holder_number = holder_row*12 + holder_column
                    holders.append(self._holders[holder_number])                 

        elif type(holder_range) is str:
            for holder_number, holder in sorted(self._holders.items()):
                if holder_range in holder.name:
                    holders.append(holder)
                    
        elif type(holder_range) is int:
            holders.append(self._holders[holder_range])
        
        else:
            if verbosity>=1:
                print('Range argument "{}" not understood.'.format(holder_range))
        return holders

    def listHolders(self):
        '''Print a list of the current holders in garage.'''
        
        for holder_number, holder in sorted(self._holders.items()):
            print( '{}: {:s}'.format(holder_number, holder.name) )

    def listSamples(self):
        '''Print a list of the current samples associated with the holder/
        bars in garage.'''
        
        for holder_number, holder in sorted(self._holders.items()):
            print( '{}: {:s}'.format(holder_number, holder.name) )
            for sample_number, sample in sorted(holder._samples.items()):
                print( '{}: {:s}'.format(sample_number, sample.name) )

    def returnHolder(self, holder='current', gotoSafe=True, force=False):
        '''return the holder from stage back to garage. 
        holder = None:  retrun to default position
        holder = [2 ,3]:  return to specific garage position
        '''
        if type(holder) == list or type(holder) == int:
            holder=self.getHolder(holder)
        if holder!='current':# and holder is not in sorted(self._holders.items()):
            print('Please use que.returnHoder().')
            #answer = input('Is this slot {} safe for the holder?'.format(slot))
            #if answer == 'yes' or 'y':
                #robot.returnHolder(holder.slot_pos, gotoSafe=gotoSafe)
            ##return

        if self.status == 'onStage':
            if holder == 'current':
                robot.returnHolder(self._current.slot_pos, gotoSafe=gotoSafe)
            else:
                if self._current == holder:
                    robot.returnHolder(holder.slot_pos, gotoSafe=gotoSafe)
                else:
                    #TODO: 
                    for hol in sorted(self._holders.items()):
                        if holder.slot_number == hol.slot_number and hol!=self._current:
                            print('There is holder position has been occupied in garage')
                            return
                   
                    answer = input('Is this slot {} safe for the holder?'.format(slot))
                    if answer == 'yes' or 'y':
                        robot.returnHolder(holder.slot_pos, gotoSafe=gotoSafe)
                    else:
                        print('The return of the holder is canceled')
            self.status = 'inGarage'
            self._current = None
        else:
            print('There is no holder on the stage')
        
    def pickupHolder(self, holder, force=False, gotoSafe=True, slack=False):
        '''pick up the holder from garage to stage. 
        '''        
        #holder = self.getHolder(slot, verbosity=0)
        #checkt the status
        self.checkStatus()
        
        if self.status == 'inGarage' and self._current==None:
            robot.pickupHolder(holder.slot_pos,gotoSafe=gotoSafe)
            self._current = holder
            self.status = 'onStage'
            post_to_slack(text='holder <<<{}>>> is onStage for measurements'.format(self._current.name), slack=slack)
            return self._current
        elif self.status == 'onStage':
            print('There is a holder on the stage.')
            if holder == self._current:
                print('The same holder on the stage')
                self._current = holder
                self.status = 'onStage'
                post_to_slack(text='holder <<<{}>>> is onStage for measurements'.format(self._current.name), slack=slack)
                return self._current
            if force == True:
                print('Remove the current holder from the stage')
                self.returnHolder()
                robot.pickupHolder(holder.slot_pos, gotoSafe=gotoSafe)
                self._current = holder
                self.status = 'onStage'
                post_to_slack(text='holder <<<{}>>> is onStage for measurements'.format(self._current.name), slack=slack)
                return self._current
            else:
                print('Nothing happened becasue the stage is occupied. Make sure force=True')
                return None
        else:
            print('There is holder on stage or robot arm. No room for the holder.')



    def gotoSample(self, holder, sample_number, force=False):
        
        holder = self.pickupHolder(holder, force=force)
        if holder is not None:
            sample = holder.getSample(sample_number, verbosity=0)
            sample.gotoAlignedPosition()
        return sample

    def setSequence(self):
        '''Print the sequence to measure the holders associated with this robot.'''
        self._sequence={}
        for slot, holder in sorted(self._holders.items()):
            
            #print( '{}: {:s}, {:d}'.format(holder.name, holder_slot_number))  
            try:
                self._sequence[holder.sequence_number] = holder
                #self._sequence[holder.name] = holder.name
            except AttributeError: 
                self._sequence[slot+100] = holder
                holder.sequence_number = slot+100
        self._sequenceList = sorted(self._sequence.items())
        self.listSequence()
        return self._sequence
    
    def listSequence(self):
        if self._sequence ==None:
            print('No sequence is defined.')
            print('Run que.setSequence() .')
        else:
            print('Current sequence is defined as: ')
            for seq, holder in sorted(self._sequence.items()):
                print('Sequence NO. {} ======>  {} at Garage {}'.format(seq, holder.name, holder.slot_number)) 

    def runSequence(self, startSample=None, endSample=None, gotoSafeForce=True, currentSample=False):
        '''run the sequence of the holders in garage. It allows to start from a given sample.
        startSample: [holder, sample], like [[2, 3], 2]
        endSample: [holder, sample], like [[2, 3], 2]
        '''
        self.setSequence()
        #The startSample and endSample have to be a standard list with 2 items, like [holder, sample]
        if startSample!=None and len(startSample)!=2:
            print('Please provide the correct sample position to start in garage. The format is like [[2, 3], 2], or [hol1, 3] or [5, 3]')
            return
        if endSample!=None and len(endSample)!=2:
            print('Please provide the correct sample position to finish in garage. The format is like [[2, 3], 2], or [hol1, 3] or [5, 3]')
            return

        if startSample==None: #when the input is None, the startSample from the first sample in the queue
            #startSample = [[0, 0], 0]
            startHolder = min(self._sequence.items())[-1]
            startSample = [startHolder.slot_pos, min(startHolder._samples.items())[0]]
        elif type(startSample[0])==list or type(startSample[0])==int: # when the input is holder position or the queue number
            startHolder = self.getHolder(startSample[0])
        else:  # when the input is holder name
            startHolder = startSample[0]
            
        if endSample==None:
            endHolder = max(self._sequence.items())[-1]
            endSample = [endHolder.slot_pos, max(endHolder._samples.items())[0]]
        elif type(endSample[0])==list or type(endSample[0])==int:
            endHolder = self.getHolder(endSample[0])
        else:
            endHolder = endSample[0]
        
        #check the corrent sequence of the start and end samples.
        #if startSample[0] != endSample[0]:
        if startHolder != endHolder:
            if startHolder.sequence_number > endHolder.sequence_number:
                return print('The start holder is listed after the last one in the sequence. Please double-check')
        #if the start and end samples are in the same bar
        else:
            if startSample[1] > endSample[1]:
                return print('The start sample is listed after the last one in the holder. Please double-check')
        
        #start the sequence
        for seq, holder in sorted(self._sequence.items()):
            #determine when the robot moves back to safe position. #TODO: test gotoSafe
            if gotoSafeForce == True:
                gotoSafe=True
            elif holder.slot_number< endHolder.slot_number:
                gotoSafe=False
            else:
                gotoSafe=True
            
            if holder.sequence_number==startHolder.sequence_number:
                #double-check self._current #TODO:pickupHolder
                if self._current==None or self._current.slot_number!= startHolder.slot_number:
                    self.pickupHolder(holder, force=True, gotoSafe=gotoSafe) 
                #self._current.doSamples()
                for sample_number, sample in sorted(self._current._samples.items()):
                    if sample_number>=int(startSample[1]):
                        print('working the the sample {} on holder {}'.format(sample.name, holder.name))
                        self._currentSample = [holder, sample_number]
                        sample.do() #run the sample
                        #self._currentSample = []
            elif holder.sequence_number>startHolder.sequence_number and holder.sequence_number<endHolder.sequence_number:
                self.pickupHolder(holder,force=True, gotoSafe=gotoSafe) 
                #self._current.doSamples()
                for sample_number, sample in sorted(self._current._samples.items()):
                    print('working the the sample {} on holder {}'.format(sample.name, holder.name))
                    self._currentSample = [holder, sample_number]
                    sample.do() #run the sample
            if holder.sequence_number==endHolder.sequence_number:
                self.pickupHolder(holder, force=True, gotoSafe=gotoSafe) 
                for sample_number, sample in sorted(self._current._samples.items()):
                    if int(sample_number)<=int(endSample[1]):
                        print('working the the sample {} on holder {}'.format(sample.name, holder.name))
                        self._currentSample = [holder, sample_number]
                        sample.do() #run the sample

    def runHolder(self, holder, slack=False):
        '''run a single holder with multiple samples.
        '''
        hol = self.pickupHolder(holder, force=True, slack=slack)
        hol.doSamples()
        
    def runHolders(self, startHolder=None, endHolder=None, gotoSafeForce=False, slack=False):
        '''run a single holder with multiple samples.
        '''
        if startHolder==None:
            startHolder = min(self._sequence.items())[-1]
        elif type(startHolder)==list or type(startHolder)==int: # when the input is holder position or the queue number
            startHolder = self.getHolder(startHolder)
        else:  # when the input is holder name
            startHolder = startHolder
            
        if endHolder==None:
            endHolder = max(self._sequence.items())[-1]
        elif type(endHolder)==list or type(endHolder)==int:
            endHolder = self.getHolder(endHolder)
        else:
            endHolder = endHolder

        for seq, holder in sorted(self._sequence.items()):
            #determine when the robot moves back to safe position. #TODO: test gotoSafe
            #if gotoSafeForce == False:
                #gotoSafe=False
            #elif holder.sequence_number< endHolder.sequence_number:
                #gotoSafe=False
            #else:
                #gotoSafe=True
            
            if holder.sequence_number>=startHolder.sequence_number and holder.sequence_number<=endHolder.sequence_number:
                self.pickupHolder(holder, force=True, slack=slack)
                #post_to_slack(text='holder <<<{}>>> is onStage for measurements'.format(que._current.name), slack=slack)
                #self.pickupHolder(holder, force=True, gotoSafe=gotoSafe) 
                holder.doSamples()

            
    #This setting is for individual holder. Each sample could set its own setting when adding into holder
    def exposure_setting(self, exposure_time=None, incident_angles=None, detectors=None, detector_positions=None, tiling=None):
        '''define the setting for exposures, including incident angles, exposure time, detector selection, detector positions. 
            incident_angles: [0.05, 0.08, 0,1]
            detectors = [pilatus2M, pilatus800]
            detector positions: optimized detector position for individual detectors, like [[60, -73], [-200, 24]] for two detectors, or [[60, -73]] for one detector  
            titing: 'ygaps', 'xygaps', None
        
        '''
        #if exposure_time != None:
            #self.exposure_time = exposure_time 
        #if incident_angles != None:
            #self.incident_angles = incident_angles 
        #if detectors != None:
            #self.detectors = detectors 
        if detector_positions != None and detectors != None:
            #self.detector_positions = detector_positions 
            if len(detector_positions) != len(detectors):
                print('The quantity of detector does not match the detector positions')
                return 
            detector_setting = []
            for ct, detector in enumerate(detectors):
                detector_setting.append =[detector, detector_positions(ct)]
                #detector.position = self.detector_positions(ct)
            
        #if tiling != None:
            #self.tiling = tiling 
        #if exposure_time != None:
            #self.exposure_time = exposure_time 
        return {'exposure_time':exposure_time,
                'incident_angles': incident_angles,
                'detector_setting': detector_setting,
                'tiling':tiling
                }


# Note: This will break until class is updated to not use gs at all.
robot = SampleExchangeRobot(use_gs=False)
que = Queue()
#robot._region='safe'

#que_setting1 = que.exposure_setting(exposure_time=10, incident_angles=[0.1, 0.5], detectors=[pilatus2M, pilatus800],  detector_positions = [[60, -73], [-200, 24]], tiling='ygaps')
#sam.measureIncidentAngles(que_setting1.

#config_load()

###############slack communication##############
import requests

slack_channel_xf11bm = 'https://hooks.slack.com/services/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'
slack_channel_CMSstatus = 'https://hooks.slack.com/services/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'
slack_channel_rp = None

#json_data = {"text":"test"}

def slack_post(json_data):
    requests.post(slack_channel_xf11bm, json=json_data) 

def post_to_slack(text, slack=True):
    if slack==True:
        try:
            channel = RE.md['slack_channel']
        except:
            channel = slack_channel_CMSstatus
        if channel is None:
            channel = slack_channel_CMSstatus
        post = {"text": "{0}".format(text)}
        try:
            #json_data = json.dumps(post)
            #req = request.Request(channel,
                                #data=json_data.encode('ascii'),
                                #headers={'Content-Type': 'application/json'}) 
            r = requests.post(channel,json=post, headers={'Content-Type': 'application/json', 'Accept':'text/plain'})
                                
        except Exception as em:
            print("EXCEPTION: " + str(em))

    else:
        print(text)

#define the info to send to slack
def status_to_slack():
    text = 'current holder is '
    return que._current.name
#!/usr/bin/python
# -*- coding: utf-8 -*-
# vi: ts=4 sw=4




################################################################################
#  Short-term settings (specific to a particular user/experiment) can
# be placed in this file. You may instead wish to make a copy of this file in
# the user's data directory, and use that as a working copy.
################################################################################


#logbooks_default = ['User Experiments']
#tags_default = ['CFN Soft-Bio']


config_load()


if False:
    # The following shortcuts can be used for unit conversions. For instance,
    # for a motor operating in 'mm' units, one could instead do:
    #     sam.xr( 10*um )
    # To move it by 10 micrometers. HOWEVER, one must be careful if using
    # these conversion parameters, since they make implicit assumptions.
    # For instance, they assume linear axes are all using 'mm' units. Conversely,
    # you will not receive an error if you try to use 'um' for a rotation axis!
    m = 1e3
    cm = 10.0
    mm = 1.0
    um = 1e-3
    nm = 1e-6
    
    inch = 25.4
    pixel = 0.172 # Pilatus
    
    deg = 1.0
    rad = np.degrees(1.0)
    mrad = np.degrees(1e-3)
    urad = np.degrees(1e-6)
    
    


def get_default_stage():
    return stg


class SampleTSAXS(SampleTSAXS_Generic):
    
    def __init__(self, name, base=None, **md):
        super().__init__(name=name, base=base, **md)
        self.naming_scheme = ['name', 'extra', 'exposure_time']

class SampleGISAXS(SampleGISAXS_Generic):
    
    def __init__(self, name, base=None, **md):
        super().__init__(name=name, base=base, **md)
        self.naming_scheme = ['name', 'extra', 'th', 'exposure_time']

class SampleCDSAXS(SampleCDSAXS_Generic):
    
    def __init__(self, name, base=None, **md):
        super().__init__(name=name, base=base, **md)
        self.naming_scheme = ['name', 'extra', 'phi', 'exposure_time']


class Sample(SampleTSAXS):
    
    def _measureTimeSeries(self, exposure_time=None, num_frames=10, wait_time=None, extra=None, measure_type='measureTimeSeries', verbosity=3, **md):
        
        self.naming_scheme_hold = self.naming_scheme
        self.naming_scheme = ['name', 'extra', 'clock', 'exposure_time']
        super().measureTimeSeries(exposure_time=exposure_time, num_frames=num_frames, wait_time=wait_time, extra=extra, measure_type=measure_type, verbosity=verbosity, **md)
        self.naming_scheme = self.naming_scheme_hold
    
    def goto(self, label, verbosity=3, **additional):
        super().goto(label, verbosity=verbosity, **additional)
        # You can add customized 'goto' behavior here
        
        


#cms.SAXS.setCalibration([247.5, 528.0], 2.395, [0, 27.52]) # 2017-01-30, 17 keV
#cms.SAXS.setCalibration([263.5, 552.0], 5.038, [0.00, 35.00]) # 2017-02-08, 13.5 keV
cms.SAXS.setCalibration([379.0, 552.0], 5.038, [20.00, 35.00]) # 2017-02-08, 13.5 keV

print('\n\n\nReminders:')
print('    Define your detectors using, e.g.: detselect(pilatus2M)')
print('    Reload your user-specific script, e.g.: %run -i /nsls2/xf11bm/data/2017_2/user_group/user.py')
print('\n')
        
if False:
    # For testing (and as examples...)
    # %run -i /opt/ipython_profiles/profile_collection/startup/98-user.py
    
    hol = CapillaryHolder(base=stg)
    hol.addSampleSlot( Sample('test_sample_01'), 1.0 )
    hol.addSampleSlot( Sample('test_sample_02'), 3.0 )
    hol.addSampleSlot( Sample('test_sample_03'), 5.0 )
    
    sam = hol.getSample(1)    
    
    
    
## We assume this is being run in a namespace (e.g. an IPython profile startup
## script) where an instance of databroker.Broker named `db` is already defined.


#from databroker_browser.qt import BrowserWindow, CrossSection, StackViewer


#search_result = lambda h: "{start[plan_name]} ['{start[uid]:.6}']".format(**h)
#text_summary = lambda h: "This is a {start[plan_name]}.".format(**h)


#def fig_dispatch(header, factory):
    #plan_name = header['start']['plan_name']
    #if 'image_det' in header['start']['detectors']:
        #fig = factory('Image Series')
        #cs = CrossSection(fig)
        #sv = StackViewer(cs, db.get_images(header, 'image'))
    #elif len(header['start'].get('motors', [])) == 1:
        #motor, = header['start']['motors']
        #main_det, *_ = header['start']['detectors']
        #fig = factory("{} vs {}".format(main_det, motor))
        #ax = fig.gca()
        #lp = LivePlot(main_det, motor, ax=ax)
        #db.process(header, lp)


#def browse():
    #return BrowserWindow(db, fig_dispatch, text_summary, search_result)
import logging
import caproto
#from caproto._log import LogFormatter, color_log_format, log_date_format

#handler = logging.FileHandler('caproto_log')
#handler.setFormatter(
    #LogFormatter(color_log_format, datefmt=log_date_format))
#log = logging.getLogger('caproto')
##log.setLevel('INFO')
#log.setLevel('DEBUG')
##log.setLevel('CRITICAL')
##log.disabled=True 
#log.handlers.clear()
#log.addHandler(handler)












'''
set the evn viarable in COMMAND LINE
export OPHYD_CONTROL_LAYER=caproto

unset OPHYD_CONTROL_LAYER

without caproto, 0.5s exposure time
total time. by %time RE(count([pilatus2M]))

1st try: 3.8s
2---4 try: 2.5-2.6s


with caproto and 'INFO' level login, 0.5s exposure time
total time. by %time RE(count([pilatus2M]))

1st try: 7.32s
2---4 try: 6.8-7s
 
 
with caproto and 'DEBUG' level login, 0.5s exposure time
total time. by %time RE(count([pilatus2M]))

1st try: 9.86s
2---4 try: 9.1-9.3s

with caproto and 'CRITICAL' level login, 0.5s exposure time
total time. by %time RE(count([pilatus2M]))

1st try: 7.35s
2---4 try: 6.9-7.1s

with caproto and disabled login, 0.5s exposure time
total time. by %time RE(count([pilatus2M]))

1st try: 7.36s
2---4 try: 6.9-7.1s

===================test the exposure time without caproto=================
In [1]: %time RE(count([pilatus2M])) 
Transient Scan ID: 867308     Time: 2018/11/02 15:03:31
Persistent Unique Scan ID: '6d5f506f-883f-488a-b664-f88f0f188729'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:03:33.4 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['6d5f506f'] (scan num: 867308)



CPU times: user 992 ms, sys: 152 ms, total: 1.14 s
Wall time: 3.89 s
Out[1]: ('6d5f506f-883f-488a-b664-f88f0f188729',)

In [2]: %time RE(count([pilatus2M])) 
Transient Scan ID: 867309     Time: 2018/11/02 15:03:57
Persistent Unique Scan ID: '8864949f-9909-4cd5-942d-c9cf24fce2a8'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:03:58.9 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['8864949f'] (scan num: 867309)



CPU times: user 648 ms, sys: 96 ms, total: 744 ms
Wall time: 2.56 s
Out[2]: ('8864949f-9909-4cd5-942d-c9cf24fce2a8',)

In [3]: %time RE(count([pilatus2M])) 
Transient Scan ID: 867310     Time: 2018/11/02 15:04:02
Persistent Unique Scan ID: 'f9555465-5712-4308-8fef-fa3dda9f4752'
/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
  'Error:' + str(exc))
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:04:03.8 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['f9555465'] (scan num: 867310)



CPU times: user 740 ms, sys: 88 ms, total: 828 ms
Wall time: 2.6 s
Out[3]: ('f9555465-5712-4308-8fef-fa3dda9f4752',)

In [4]: %time RE(count([pilatus2M])) 
Transient Scan ID: 867311     Time: 2018/11/02 15:04:07
Persistent Unique Scan ID: 'fdae09c9-b9dd-4234-aefb-1299edffb4ec'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:04:09.4 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['fdae09c9'] (scan num: 867311)



CPU times: user 700 ms, sys: 112 ms, total: 812 ms
Wall time: 2.55 s
Out[4]: ('fdae09c9-b9dd-4234-aefb-1299edffb4ec',)

In [5]: %time RE(count([pilatus2M])) 
Transient Scan ID: 867312     Time: 2018/11/02 15:04:21
Persistent Unique Scan ID: '29a011e4-58d9-4acd-a516-cfd1c5c9c260'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:04:23.7 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['29a011e4'] (scan num: 867312)



CPU times: user 668 ms, sys: 108 ms, total: 776 ms
Wall time: 2.53 s
Out[5]: ('29a011e4-58d9-4acd-a516-cfd1c5c9c260',)


===================test the exposure time with caproto at 'INFO' level=================

In [1]: %time RE(count([pilatus2M]))
Transient Scan ID: 867313     Time: 2018/11/02 15:05:49
Persistent Unique Scan ID: '4224c7b8-23d6-4392-b21b-561f949939f4'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:05:51.9 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['4224c7b8'] (scan num: 867313)



CPU times: user 1.49 s, sys: 196 ms, total: 1.69 s
Wall time: 7.32 s
Out[1]: ('4224c7b8-23d6-4392-b21b-561f949939f4',)

In [2]: %time RE(count([pilatus2M]))
Transient Scan ID: 867314     Time: 2018/11/02 15:06:50
Persistent Unique Scan ID: '46a01cdb-9f8a-4006-991f-96b506b6b207'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:06:52.4 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['46a01cdb'] (scan num: 867314)



CPU times: user 1.29 s, sys: 76 ms, total: 1.37 s
Wall time: 7.04 s
Out[2]: ('46a01cdb-9f8a-4006-991f-96b506b6b207',)

In [3]: %time RE(count([pilatus2M]))
Transient Scan ID: 867315     Time: 2018/11/02 15:07:11
Persistent Unique Scan ID: '9fcf9f42-434d-4dbe-9504-4c3292c6666b'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:07:13.7 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['9fcf9f42'] (scan num: 867315)



^[[A
^[[ACPU times: user 1.13 s, sys: 68 ms, total: 1.2 s
Wall time: 6.8 s
Out[3]: ('9fcf9f42-434d-4dbe-9504-4c3292c6666b',)

In [4]: %time RE(count([pilatus2M]))

Transient Scan ID: 867316     Time: 2018/11/02 15:07:18
Persistent Unique Scan ID: '7d91aa6c-de37-4a55-8a26-7710cafe9e5a'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:07:20.7 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['7d91aa6c'] (scan num: 867316)



CPU times: user 1.13 s, sys: 124 ms, total: 1.25 s
Wall time: 7.03 s
Out[4]: ('7d91aa6c-de37-4a55-8a26-7710cafe9e5a',)

In [5]: 

In [5]: %time RE(count([pilatus2M]))
Transient Scan ID: 867317     Time: 2018/11/02 15:07:27
Persistent Unique Scan ID: '83a615b1-d948-4ad7-a434-c4e772f8b37b'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:07:29.8 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['83a615b1'] (scan num: 867317)



CPU times: user 1.26 s, sys: 100 ms, total: 1.36 s
Wall time: 7.01 s
Out[5]: ('83a615b1-d948-4ad7-a434-c4e772f8b37b',)


===================test the exposure time with caproto at 'DEBUG' level=================
In [1]: log.setLevel('DEBUG')

In [2]: %time RE(count([pilatus2M]))
^[[A
Transient Scan ID: 867318     Time: 2018/11/02 15:08:47
Persistent Unique Scan ID: '6848fe0a-d71d-4a05-9e8e-b0157f8e2f02'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:08:50.7 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['6848fe0a'] (scan num: 867318)



CPU times: user 3.93 s, sys: 560 ms, total: 4.49 s
Wall time: 9.86 s
Out[2]: ('6848fe0a-d71d-4a05-9e8e-b0157f8e2f02',)

In [3]: %time RE(count([pilatus2M]))
Transient Scan ID: 867319     Time: 2018/11/02 15:08:56
Persistent Unique Scan ID: 'fb239da4-9e9d-4431-b177-cd00af54e679'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:08:59.8 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['fb239da4'] (scan num: 867319)



CPU times: user 3.42 s, sys: 332 ms, total: 3.75 s
Wall time: 9.03 s
Out[3]: ('fb239da4-9e9d-4431-b177-cd00af54e679',)

In [4]: %time RE(count([pilatus2M]))
^[[A
Transient Scan ID: 867320     Time: 2018/11/02 15:09:29
Persistent Unique Scan ID: 'ee2f0e3b-f792-4510-83bb-9007fb4555ec'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:09:32.5 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['ee2f0e3b'] (scan num: 867320)



CPU times: user 3.66 s, sys: 356 ms, total: 4.01 s
Wall time: 9.35 s
Out[4]: ('ee2f0e3b-f792-4510-83bb-9007fb4555ec',)

In [5]: %time RE(count([pilatus2M]))
Transient Scan ID: 867321     Time: 2018/11/02 15:09:38
Persistent Unique Scan ID: 'fa008494-5b6b-4f66-a7b9-2d8863f76b14'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:09:41.8 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['fa008494'] (scan num: 867321)



CPU times: user 3.59 s, sys: 340 ms, total: 3.93 s
Wall time: 9.28 s
Out[5]: ('fa008494-5b6b-4f66-a7b9-2d8863f76b14',)

In [6]: %time RE(count([pilatus2M]))
Transient Scan ID: 867322     Time: 2018/11/02 15:10:00
Persistent Unique Scan ID: '8b129720-4da7-4c84-9a2d-41fab456dadf'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:10:03.9 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['8b129720'] (scan num: 867322)



CPU times: user 3.44 s, sys: 388 ms, total: 3.82 s
Wall time: 9.13 s
Out[6]: ('8b129720-4da7-4c84-9a2d-41fab456dadf',)

In [7]: %time RE(count([pilatus2M]))
Transient Scan ID: 867323     Time: 2018/11/02 15:10:11
Persistent Unique Scan ID: '33101762-fc9b-4efa-8d8c-e55669924fbc'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:10:14.7 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['33101762'] (scan num: 867323)



CPU times: user 3.46 s, sys: 368 ms, total: 3.83 s
Wall time: 9.16 s
Out[7]: ('33101762-fc9b-4efa-8d8c-e55669924fbc',)


===================test the exposure time with caproto at 'CRITICAL' level=================


In [1]: log.setLevel('CRITICAL')

In [2]: %time RE(count([pilatus2M]))
Transient Scan ID: 867324     Time: 2018/11/02 15:11:27
Persistent Unique Scan ID: 'a0930f36-1127-49d4-8b98-5549341a313f'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:11:29.3 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['a0930f36'] (scan num: 867324)



CPU times: user 1.39 s, sys: 148 ms, total: 1.54 s
Wall time: 7.35 s
Out[2]: ('a0930f36-1127-49d4-8b98-5549341a313f',)

In [3]: %time RE(count([pilatus2M]))
Transient Scan ID: 867325     Time: 2018/11/02 15:11:37
Persistent Unique Scan ID: '8bb969e2-657d-4c10-b217-c2acd5e6d348'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
                                                                                                   
New stream: 'primary'
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:11:39.1 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['8bb969e2'] (scan num: 867325)



CPU times: user 1.33 s, sys: 100 ms, total: 1.43 s
Wall time: 7.05 s
Out[3]: ('8bb969e2-657d-4c10-b217-c2acd5e6d348',)

In [4]: %time RE(count([pilatus2M]))
Transient Scan ID: 867326     Time: 2018/11/02 15:11:44
Persistent Unique Scan ID: 'a3411531-b8a7-4a4c-be1b-38032cf42c80'
/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
  'Error:' + str(exc))
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:11:46.2 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['a3411531'] (scan num: 867326)



CPU times: user 1.21 s, sys: 124 ms, total: 1.34 s
Wall time: 6.97 s
Out[4]: ('a3411531-b8a7-4a4c-be1b-38032cf42c80',)

In [5]: %time RE(count([pilatus2M]))
Transient Scan ID: 867327     Time: 2018/11/02 15:11:56
Persistent Unique Scan ID: '03c919fa-9af9-4827-9de6-a3a6dc992b8a'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:11:58.0 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['03c919fa'] (scan num: 867327)



CPU times: user 1.26 s, sys: 100 ms, total: 1.36 s
Wall time: 6.9 s
Out[5]: ('03c919fa-9af9-4827-9de6-a3a6dc992b8a',)

In [6]: %time RE(count([pilatus2M]))
Transient Scan ID: 867328     Time: 2018/11/02 15:12:08
Persistent Unique Scan ID: '5a816fe6-8876-4249-811d-b6f125e899c0'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:12:10.1 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['5a816fe6'] (scan num: 867328)



CPU times: user 1.33 s, sys: 92 ms, total: 1.42 s
Wall time: 7.06 s
Out[6]: ('5a816fe6-8876-4249-811d-b6f125e899c0',)

In [7]: %time RE(count([pilatus2M]))
Transient Scan ID: 867329     Time: 2018/11/02 15:12:19
Persistent Unique Scan ID: '55d1387e-2f6a-4d9c-a19c-437999fa40a3'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:12:21.5 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['55d1387e'] (scan num: 867329)



CPU times: user 1.27 s, sys: 52 ms, total: 1.32 s
Wall time: 6.88 s
Out[7]: ('55d1387e-2f6a-4d9c-a19c-437999fa40a3',)


===================test the exposure time with caproto at  log.disabled=True =================
In [1]: log.disabled=True

In [2]: %time RE(count([pilatus2M]))
^[[A
Transient Scan ID: 867330     Time: 2018/11/02 15:13:32
Persistent Unique Scan ID: 'b219651b-2072-43a8-b2ee-3ee4babea253'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:13:34.4 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['b219651b'] (scan num: 867330)



CPU times: user 1.33 s, sys: 212 ms, total: 1.54 s
Wall time: 7.36 s
Out[2]: ('b219651b-2072-43a8-b2ee-3ee4babea253',)

In [3]: %time RE(count([pilatus2M]))
Transient Scan ID: 867331     Time: 2018/11/02 15:13:39
Persistent Unique Scan ID: 'f979ff47-b4ec-46e1-bea8-d8776339c605'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:13:41.5 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['f979ff47'] (scan num: 867331)



CPU times: user 1.25 s, sys: 124 ms, total: 1.37 s
Wall time: 7.1 s
Out[3]: ('f979ff47-b4ec-46e1-bea8-d8776339c605',)

In [4]: %time RE(count([pilatus2M]))
Transient Scan ID: 867332     Time: 2018/11/02 15:14:11
Persistent Unique Scan ID: 'd259a610-7edb-4bc6-b901-38b0deaf6e5e'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:14:13.8 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['d259a610'] (scan num: 867332)



CPU times: user 1.18 s, sys: 104 ms, total: 1.29 s
Wall time: 6.9 s
Out[4]: ('d259a610-7edb-4bc6-b901-38b0deaf6e5e',)

In [5]: %time RE(count([pilatus2M]))
Transient Scan ID: 867333     Time: 2018/11/02 15:14:33
Persistent Unique Scan ID: 'da6b9b84-2587-46ed-bc68-f45812ed70a9'

/opt/conda_envs/collection-2018-3.2/lib/python3.6/site-packages/nslsii/__init__.py:262: UserWarning: This olog is giving errors. This will not be logged.Error:0
New stream: 'primary'                                                                              
+-----------+------------+------------------------+------------------------+
|   seq_num |       time | pilatus2M_stats3_total | pilatus2M_stats4_total |
+-----------+------------+------------------------+------------------------+
|         1 | 15:14:35.6 |                      0 |                      0 |
+-----------+------------+------------------------+------------------------+
generator count ['da6b9b84'] (scan num: 867333)



CPU times: user 1.31 s, sys: 132 ms, total: 1.44 s
Wall time: 7.06 s
Out[5]: ('da6b9b84-2587-46ed-bc68-f45812ed70a9',)


'''#def wh_all():
    #wh_pos([mono_bragg,mono_pitch2,mono_roll2,mono_perp2])
    #wh_pos([mir_usx,mir_dsx,mir_usy,mir_dsyi,mir_dsyo,mir_bend])
    #wh_pos(s0)
    #wh_pos(s1)
    #wh_pos(s2)
    #wh_pos(s3)
    #wh_pos(s4)
    #wh_pos(s5)
    #wh_pos([bim3y,fs3y,bim4y,bim5y])
    #wh_pos([smx,smy,sth,schi,sphi,srot,strans,strans2,stilt,stilt2])
    #wh_pos([camx,camy,cam2x,cam2z])
    #wh_pos([DETx,DETy,WAXSx,SAXSx,SAXSy])
    #wh_pos([bsx,bsy,bsphi])
    #wh_pos([armz,armx,armphi,army,armr])


#def wh_offsets():
    #print('Direction: 0--Pos, 1--Neg\n')

    ### mono
    #wh_pos([mono_bragg,mono_pitch2,mono_roll2,mono_perp2])
    #print('mono_bragg:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr.DIR')))
    #print('mono_pitch2:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:P2}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:P2}Mtr.DIR')))
    #print('mono_roll2:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:R2}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:R2}Mtr.DIR')))
    #print('mono_perp2:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:Y2}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:Y2}Mtr.DIR')))

    ### mirror
    #wh_pos([mir_usx,mir_dsx,mir_usy,mir_dsyi,mir_dsyo,mir_bend])
    #print('mir_usx:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:XU}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:XU}Mtr.DIR')))
    #print('mir_dsx:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:XD}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:XD}Mtr.DIR')))
    #print('mir_usy:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:YU}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:YU}Mtr.DIR')))
    #print('mir_dsyi:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:YDI}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:YDI}Mtr.DIR')))
    #print('mir_dsyo:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:YDO}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:YDO}Mtr.DIR')))
    #print('mir_bend:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:UB}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:UB}Mtr.DIR')))

    ### slits S0
    #wh_pos(s0)
    #print('s0.tp:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:T}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:T}Mtr.DIR')))
    #print('s0.bt:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:B}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:B}Mtr.DIR')))
    #print('s0.ob:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:O}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:O}Mtr.DIR')))
    #print('s0.ib:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:I}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:I}Mtr.DIR')))

    ### slits S1
    #wh_pos(s1)
    #print('s1.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:XC}Mtr.DIR')))
    #print('s1.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:XG}Mtr.DIR')))
    #print('s1.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:YC}Mtr.DIR')))
    #print('s1.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:YG}Mtr.DIR')))

    ### slits S2
    #wh_pos(s2)
    #print('s2.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:XC}Mtr.DIR')))
    #print('s2.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:XG}Mtr.DIR')))
    #print('s2.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:YC}Mtr.DIR')))
    #print('s2.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:YG}Mtr.DIR')))

    ### slits S3
    #wh_pos(s3)
    #print('s3.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:XC}Mtr.DIR')))
    #print('s3.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:XG}Mtr.DIR')))
    #print('s3.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:YC}Mtr.DIR')))
    #print('s3.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:YG}Mtr.DIR')))

    ### slits S4
    #wh_pos(s4)
    #print('s4.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:XC}Mtr.DIR')))
    #print('s4.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:XG}Mtr.DIR')))
    #print('s4.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:YC}Mtr.DIR')))
    #print('s4.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:YG}Mtr.DIR')))

    ### slits S5
    #wh_pos(s5)
    #print('s5.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:XC}Mtr.DIR')))
    #print('s5.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:XG}Mtr.DIR')))
    #print('s5.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:YC}Mtr.DIR')))
    #print('s5.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:YG}Mtr.DIR')))


    ### diagnostic stages
    #wh_pos([bim3y,fs3y,bim4y,bim5y])
    #print('bim3y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{IM:3-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{IM:3-Ax:Y}Mtr.DIR')))
    #print('fs3y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{FS:3-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{FS:3-Ax:Y}Mtr.DIR')))
    #print('bim4y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{IM:4-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{IM:4-Ax:Y}Mtr.DIR')))
    #print('bim5y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{IM:5-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{IM:5-Ax:Y}Mtr.DIR')))


    ### sample stages
    #wh_pos([smx,smy,sth,schi,sphi,srot,strans])
    #print('smx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:X}Mtr.DIR')))
    #print('smy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:Z}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:Z}Mtr.DIR')))
    #print('sth:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:theta}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:theta}Mtr.DIR')))
    #print('schi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:chi}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:chi}Mtr.DIR')))
    #print('sphi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:phi}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:phi}Mtr.DIR')))
    #print('srot:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Srot}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Srot}Mtr.DIR')))
    #print('strans:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Strans}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Strans}Mtr.DIR')))
    #print('strans2:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Strans2}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Strans2}Mtr.DIR')))
    #print('stilt:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Stilt}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Stilt}Mtr.DIR')))
    #print('stilt2:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Stilt2}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Stilt2}Mtr.DIR')))


    ### camera
    #wh_pos([camx,camy])
    #print('camx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:X1}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:X1}Mtr.DIR')))
    #print('camy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y1}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y1}Mtr.OFF')))
    #print('cam2x:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:X2}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:X2}Mtr.DIR')))
    #print('cam2z:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y2}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y2}Mtr.OFF')))


    ### detector stages
    #wh_pos([DETx,DETy,WAXSx,SAXSx,SAXSy])
    #print('DETx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:Stg-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Det:Stg-Ax:X}Mtr.DIR')))
    #print('DETy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:Stg-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{Det:Stg-Ax:Y}Mtr.DIR')))
    #print('WAXSx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:WAXS-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Det:WAXS-Ax:X}Mtr.DIR')))
    #print('SAXSx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:SAXS-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Det:SAXS-Ax:X}Mtr.DIR')))
    #print('SAXSy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:SAXS-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{Det:SAXS-Ax:Y}Mtr.DIR')))


    ### beamstop
    #wh_pos([bsx,bsy,bsphi])
    #print('bsx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{BS:SAXS-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{BS:SAXS-Ax:X}Mtr.DIR')))
    #print('bsy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{BS:SAXS-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{BS:SAXS-Ax:Y}Mtr.DIR')))
    #print('bsphi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{BS:SAXS-Ax:phi}Mtr.OFF'),caget('XF:11BMB-ES{BS:SAXS-Ax:phi}Mtr.DIR')))


    ### sample exchanger
    #wh_pos([armz,armx,armphi,army,armr])
    #print('armz:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Z}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Z}Mtr.DIR')))
    #print('armx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:X}Mtr.DIR')))
    #print('armphi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Yaw}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Yaw}Mtr.DIR')))
    #print('army:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Y}Mtr.DIR')))
    #print('armr:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr.DIR')))


#def wh_all():
    #%wa([mono_bragg,mono_pitch2,mono_roll2,mono_perp2])
    #%wa([mir_usx,mir_dsx,mir_usy,mir_dsyi,mir_dsyo,mir_bend])
    #%wa(s0)
    #%wa(s1)
    #%wa(s2)
    #%wa(s3)
    #%wa(s4)
    #%wa(s5)
    #%wa([bim3y,fs3y,bim4y,bim5y])
    #%wa([smx,smy,sth,schi,sphi,srot,strans,strans2,stilt,stilt2])
    #%wa([camx,camy,cam2x,cam2z])
    #%wa([DETx,DETy,WAXSx,SAXSx,SAXSy])
    #%wa([bsx,bsy,bsphi])
    #%wa([armz,armx,armphi,army,armr])


#def wh_offsets():
    #print('Direction: 0--Pos, 1--Neg\n')

    ### mono
    #%wa([mono_bragg,mono_pitch2,mono_roll2,mono_perp2])
    #print('mono_bragg:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:Bragg}Mtr.DIR')))
    #print('mono_pitch2:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:P2}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:P2}Mtr.DIR')))
    #print('mono_roll2:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:R2}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:R2}Mtr.DIR')))
    #print('mono_perp2:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mono:DMM-Ax:Y2}Mtr.OFF'),caget('XF:11BMA-OP{Mono:DMM-Ax:Y2}Mtr.DIR')))

    ### mirror
    #%wa([mir_usx,mir_dsx,mir_usy,mir_dsyi,mir_dsyo,mir_bend])
    #print('mir_usx:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:XU}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:XU}Mtr.DIR')))
    #print('mir_dsx:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:XD}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:XD}Mtr.DIR')))
    #print('mir_usy:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:YU}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:YU}Mtr.DIR')))
    #print('mir_dsyi:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:YDI}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:YDI}Mtr.DIR')))
    #print('mir_dsyo:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:YDO}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:YDO}Mtr.DIR')))
    #print('mir_bend:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Mir:Tor-Ax:UB}Mtr.OFF'),caget('XF:11BMA-OP{Mir:Tor-Ax:UB}Mtr.DIR')))

    ### slits S0
    #%wa(s0)
    #print('s0.tp:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:T}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:T}Mtr.DIR')))
    #print('s0.bt:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:B}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:B}Mtr.DIR')))
    #print('s0.ob:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:O}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:O}Mtr.DIR')))
    #print('s0.ib:  offset = %f, direction = %d' % (caget('XF:11BMA-OP{Slt:0-Ax:I}Mtr.OFF'),caget('XF:11BMA-OP{Slt:0-Ax:I}Mtr.DIR')))

    ### slits S1
    #%wa(s1)
    #print('s1.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:XC}Mtr.DIR')))
    #print('s1.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:XG}Mtr.DIR')))
    #print('s1.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:YC}Mtr.DIR')))
    #print('s1.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:1-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:1-Ax:YG}Mtr.DIR')))

    ### slits S2
    #%wa(s2)
    #print('s2.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:XC}Mtr.DIR')))
    #print('s2.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:XG}Mtr.DIR')))
    #print('s2.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:YC}Mtr.DIR')))
    #print('s2.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:2-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:2-Ax:YG}Mtr.DIR')))

    ### slits S3
    #%wa(s3)
    #print('s3.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:XC}Mtr.DIR')))
    #print('s3.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:XG}Mtr.DIR')))
    #print('s3.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:YC}Mtr.DIR')))
    #print('s3.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:3-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:3-Ax:YG}Mtr.DIR')))

    ### slits S4
    #%wa(s4)
    #print('s4.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:XC}Mtr.DIR')))
    #print('s4.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:XG}Mtr.DIR')))
    #print('s4.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:YC}Mtr.DIR')))
    #print('s4.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:4-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:4-Ax:YG}Mtr.DIR')))

    ### slits S5
    #%wa(s5)
    #print('s5.xc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:XC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:XC}Mtr.DIR')))
    #print('s5.xg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:XG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:XG}Mtr.DIR')))
    #print('s5.yc:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:YC}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:YC}Mtr.DIR')))
    #print('s5.yg:  offset = %f, direction = %d' % (caget('XF:11BMB-OP{Slt:5-Ax:YG}Mtr.OFF'),caget('XF:11BMB-OP{Slt:5-Ax:YG}Mtr.DIR')))


    ### diagnostic stages
    #%wa([bim3y,fs3y,bim4y,bim5y])
    #print('bim3y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{IM:3-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{IM:3-Ax:Y}Mtr.DIR')))
    #print('fs3y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{FS:3-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{FS:3-Ax:Y}Mtr.DIR')))
    #print('bim4y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{IM:4-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{IM:4-Ax:Y}Mtr.DIR')))
    #print('bim5y:  offset = %f, direction = %d' % (caget('XF:11BMB-BI{IM:5-Ax:Y}Mtr.OFF'),caget('XF:11BMB-BI{IM:5-Ax:Y}Mtr.DIR')))


    ### sample stages
    #%wa([smx,smy,sth,schi,sphi,srot,strans])
    #print('smx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:X}Mtr.DIR')))
    #print('smy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:Z}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:Z}Mtr.DIR')))
    #print('sth:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:theta}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:theta}Mtr.DIR')))
    #print('schi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:chi}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:chi}Mtr.DIR')))
    #print('sphi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Chm:Smpl-Ax:phi}Mtr.OFF'),caget('XF:11BMB-ES{Chm:Smpl-Ax:phi}Mtr.DIR')))
    #print('srot:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Srot}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Srot}Mtr.DIR')))
    #print('strans:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Strans}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Strans}Mtr.DIR')))
    #print('strans2:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Strans2}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Strans2}Mtr.DIR')))
    #print('stilt:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Stilt}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Stilt}Mtr.DIR')))
    #print('stilt2:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Stilt2}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Stilt2}Mtr.DIR')))


    ### camera
    #%wa([camx,camy])
    #print('camx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:X1}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:X1}Mtr.DIR')))
    #print('camy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y1}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y1}Mtr.OFF')))
    #print('cam2x:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:X2}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:X2}Mtr.DIR')))
    #print('cam2z:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y2}Mtr.OFF'),caget('XF:11BMB-ES{Cam:OnAxis-Ax:Y2}Mtr.OFF')))


    ### detector stages
    #%wa([DETx,DETy,WAXSx,SAXSx,SAXSy])
    #print('DETx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:Stg-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Det:Stg-Ax:X}Mtr.DIR')))
    #print('DETy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:Stg-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{Det:Stg-Ax:Y}Mtr.DIR')))
    #print('WAXSx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:WAXS-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Det:WAXS-Ax:X}Mtr.DIR')))
    #print('SAXSx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:SAXS-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{Det:SAXS-Ax:X}Mtr.DIR')))
    #print('SAXSy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{Det:SAXS-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{Det:SAXS-Ax:Y}Mtr.DIR')))


    ### beamstop
    #%wa([bsx,bsy,bsphi])
    #print('bsx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{BS:SAXS-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{BS:SAXS-Ax:X}Mtr.DIR')))
    #print('bsy:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{BS:SAXS-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{BS:SAXS-Ax:Y}Mtr.DIR')))
    #print('bsphi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{BS:SAXS-Ax:phi}Mtr.OFF'),caget('XF:11BMB-ES{BS:SAXS-Ax:phi}Mtr.DIR')))


    ### sample exchanger
    #%wa([armz,armx,armphi,army,armr])
    #print('armz:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Z}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Z}Mtr.DIR')))
    #print('armx:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:X}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:X}Mtr.DIR')))
    #print('armphi:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Yaw}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Yaw}Mtr.DIR')))
    #print('army:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:Y}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:Y}Mtr.DIR')))
    #print('armr:  offset = %f, direction = %d' % (caget('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr.OFF'),caget('XF:11BMB-ES{SM:1-Ax:ArmR}Mtr.DIR')))


